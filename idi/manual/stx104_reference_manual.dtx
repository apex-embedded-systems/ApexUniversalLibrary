
@@Support Policy
\ \ 

@@Need Custom Modifications?
Contact us for customization or modifications to our standard
product. If you need large quantities we can generally save
you money through optimizing card designs to meet your exact
needs.

@@General Support Policy
We support all hardware products for a period of 3 months
from time of delivery. See limited warranty terms.

@@Recommended Sequence in Obtaining Customer Support
Review user manuals for additional information not found in
demo software.



Go to our website at <extlink http://www.apexembeddedsystems.com/support.asp>www.apexembeddedsystems/support.asp</extlink>.



Contact us via email at <extlink mailto:customer.service@apexembeddedsystems.com>customer.service@apexembeddedsystems.com</extlink>.
Technical support related inquiry answered typically within a
24-hour period.

@@Welcome
Dear Valued Customer:



Thank you for your interest in our products and services.



Apex Embedded Systems "Continuous improvement" policy
utilizes customer feedback to improve existing products and
create new product offerings based on needs of our customers.





Continued Success,



Apex Embedded Systems


@@Benefits and Features
\ \ 

@@Executive Summary
Summary
What is the %CARD_NAME%? The %CARD_NAME% is a 48-channel
opto-isolated digital input card.
Description
\ \ 

What are the Benefits of using the %CARD_NAME%? The
%CARD_NAME% has the following benefits:



* New Features as of February 14, 2008 (Revision 080407H) *
  * Supports both 8&#45; and 16&#45;bit PC/104 data busses
  * Supports 10&#45;bit or 16&#45;bit I/O addressing via
    jumper using jumper M4. DAS1602 register set located at
    base_address + 0x400 are also now relocated in an indexed
    register spaced within the 10&#45;



Please note that all of the new registers are designed such
that if they are not configured, everything defaults to the
classic modes of operation. Thus, existing software will
function without modification. Writing values to the new
registers enhances operations.

@@Photo
Description
<image STX104 (SKU - STX104-1MFIFO-DAQ) 72dpi copy>

@@Hardware Configuration
\ \ 

@@Base Address and Configuration
Summary
\ \ 
Description
\ \ 
* Base Address and Mode Configuration (J6) *

<emit \<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse" bordercolor="#111111"\>\\n      \<tr\>\\n\<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right; margin-top:0; margin-bottom:0"\> \<font face="Tahoma size="2""\>1\</font\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<span style="font-size:11.0pt"\> \<img border="0" width="12" height="12" src="image010.jpg" /\>\</span\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>2\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>A9 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>3\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>4\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>A8 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>5\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg"\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>6\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>A7 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\>\<font size="2"\>7\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>8\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>A6 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\>\<font size="2"\>9\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>10\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>A5 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>11\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>12\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>A4 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>13\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>14\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\>\<font size="2"\>1 MHz - Jumper\<font size="2"\>\</font\>\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>15\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>16\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>DMA3 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>17\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" v:shapes="_x0000_s1628" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>18\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>M4 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>19\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>20\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>M3 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>21\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>22\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>M2 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>23\</font\>\</td\>\\n        \<td align="center" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>24\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>M1 - Jumper\</font\>\</td\>\\n      \</tr\>\\n      \<tr\>\\n        \<td width="138" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\> \</font\>\</td\>\\n        \<td width="28" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="right" style="text-align:right"\> \<font size="2"\>25\</font\>\</td\>\\n        \<td align="center" style="border: medium none; border-bottom: 1.0pt solid windowtext; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td align="center" style="border-left: medium none; border-right: 1.0pt solid windowtext; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="center" style="text-align:center"\> \<img border="0" width="10" height="10" src="image012.jpg" /\>\</p\>\</td\>\\n        \<td width="28" style="border: medium none; border-bottom: medium none; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>26\</font\>\</td\>\\n        \<td width="154" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left"\> \<font size="2"\>M0 - Jumper\</font\>\</td\>\\n      \</tr\>\\n\\n      \<tr style="page-break-inside: avoid; height: 25.6pt"\>\\n        \<td width="396" colspan="6" style="border:medium none;padding-left:5.4pt; padding-right:5.4pt; padding-top:0in; padding-bottom:0in"\>\<p class="TableText" align="left" style="text-align:left; margin-top:0; margin-bottom:0"\> \</td\>\\n      \</tr\>\\n    \</table\>>

<table>
Jumper    \Description
========  --------------------------------------------------------------------------------
A9 - A4   Base Address Jumpers. See <link Base Address Table>.
1 MHz     Selects 8254 Clock source<p />0 = 10 MHz<p />1 = 1 MHz
DMA3      DMA Channel Select<p />0 = DMA Channel 1<p />1 = DMA
           Channel 3
M4 - M0   Mode Select Jumpers. See <link Compatibility Selection and Extended Functions>.
</table>
\Note: 1 = Jumper installed, 0 = Jumper not installed.

@@Base Address Table
Summary
Card Base Address set via installing jumpers at J6 positions
A9, A8, A7, A6, A5 and A4. Installing jumper M4 will reduce
address I/O decode from a full 16-bits to 10-bits, this
provides compatibility with CPU cards that only offer
10-address bits for I/O transactions.
Description
<table>
BASE ADDRESS<p />Full          BASE ADDRESS<p />10-bit   A9   A8   A7   A6   A5   A4
 16-bit Address Decode<p />M4   Address Decode<p />M4                              
 Jumper *not* Installed         Jumper Installed                                   
=============================  ========================  ===  ===  ===  ===  ===  ===
0x0220                         0x220                     1    0    0    0    1    0
0x0240                         0x240                     1    0    0    1    0    0
0x0250                         0x250                     1    0    0    1    0    1
0x0260                         0x260                     1    0    0    1    1    0
0x0280                         0x280                     1    0    1    0    0    0
0x0290                         0x290                     1    0    1    0    0    1
0x02A0                         0x2A0                     1    0    1    0    1    0
0x02B0                         0x2B0                     1    0    1    0    1    1
0x02C0                         0x2C0                     1    0    1    1    0    0
0x02D0                         0x2D0                     1    0    1    1    0    1
0x02E0                         0x2E0                     1    0    1    1    1    0
0x02F0                         0x2F0                     1    0    1    1    1    1
0x0300*                        0x300*                    1    1    0    0    0    0
0x0310                         0x310                     1    1    0    0    0    1
0x0320                         0x320                     1    1    0    0    1    0
0x0330                         0x330                     1    1    0    0    1    1
0x0340                         0x340                     1    1    0    1    0    0
0x0350                         0x350                     1    1    0    1    0    1
0x0360                         0x360                     1    1    0    1    1    0
0x0370                         0x370                     1    1    0    1    1    1
0x0380                         0x380                     1    1    1    0    0    0
0x0390                         0x390                     1    1    1    0    0    1
0x03A0                         0x3A0                     1    1    1    0    1    0
0x03B0                         0x3B0                     1    1    1    0    1    1
0x03C0                         0x3C0                     1    1    1    1    0    0
0x03D0                         0x3D0                     1    1    1    1    0    1
0x03E0                         0x3E0                     1    1    1    1    1    0
0x03F0                         0x3F0                     1    1    1    1    1    1
</table>
Notes: 1 = Jumper installed, 0 = Jumper not installed.

\* Factory Default

@@Compatibility Selection and Extended Functions
Summary
\ \ 
Description
* 10-BIT ADDRESS DECODE *
The %CARD_NAME% now supports CPU cards which only present the
first 10 address lines. Normally, the %CARD_NAME% will decode
all 16 address bits in order to fully decode an I/O command.
For 10-bit address decode, the upper 6 address bits are
ignored. A 10-bit address decode provides a typical I/O
address space from 0x000 to 0x3FF. The DAS1602 burst
registers are now alternatively available through indexed
register array access.

* DAS16jr/16 and DAS1602 LEGACY COMPATIBILITY *
The %CARD_NAME% is compatible with DAS16jr/16 and the
DAS1602. The DAS16jr/16 mode supports 8-bit or 16-bit systems
(XT or AT, respectively). The enhanced register set now
supports redirection of the DAS1602 extended burst registers
to the indexed array register set thus allowing more
addressing and data width options including both XT and AT
compatibility. Jumper position M0 selects one of these
compatibility modes.



The DAS1602 compatibility offers <link ADC-Sample, ADC-sample>
and <link ADC-Burst, ADC-bursting>.

* FIFO SUPERSET *
Data FIFO superset functionality can be selected for either
the DAS16jr/16 or the DAS1602 compatibility modes. The FIFO
superset functionality is very similar to other cards on the
market. Stuffing jumper position M1 enables FIFO superset
functionality. Note that for the DAS1602 compatibility mode,
the 1 mega-sample FIFO is enabled, however to maintain
register compatibility the FIFO status registers are only
visible once the M1 jumper is installed.



The HSFIFOEN bit found in the <link FIFO Configuration>
register can be used to enable a 2048 sample high speed
pre-queueing FIFO buffer between %CARD_NAME% main memory and
the ISA bus. In general, this will reduce/eliminate IOCHRDY
wait states and improve average system throughput.

* 12-/16-BIT DAC MODE *
The 16-bit DAC mode allows the DAC registers to provide
12-bit legacy functionality as well as full 16-bit DAC
functionality. Installing jumper M2 allows for full 16-bit
DAC operation.

* ADC 16-SAMPLE MOVING AVERAGE FILTER *
Installing jumper M3 enables the 16-sample moving average
filter for all channels. The filter can be reset (or cleared)
by writing to the Channel Register. The moving average filter
is enabled for all channels and operates completely
transparent to ADC acquisition modes. The ADC values read out
will be the current sample plus the last fifteen samples
summed together and divided by sixteen (average of sixteen
ADC samples). It is important to recognize that after the
filter is reset or at the beginning of data sampling that it
may require at least 16-data samples per channel be taken
until the data becomes current. In other words, there is an
inherent 16-sample delay in the ADC data that is read out of
the ADC Data Register.



<table>
MODE                                                      M4   M3   M2   M1   M0
--------------------------------------------------------  ===  ===  ===  ===  ===
10-Bit Address Decode (A15 to A10 ignored. DAS1602        1    X    X    X    X
 burst registers available in the indexed register                             
 array).                                                                       
DAS16jr/16 + DAC02 Compatibility                          X    X    X    0    0
DAS1602 Compatibility w/1MegaSample FIFO<p />(Single      X    X    X    0    1
 interrupt per sample during ADC-burst)                                        
DAS1602 Compatibility and FIFO Status Registers Visible   X    X    X    1    1
 (Single interrupt per ADC-burst completion)                                   
Enable FIFO Superset Functionality                        X    X    X    1    X
16-bit DAC Registers                                      X    X    1    X    X
16-Sample moving average filter for all 8 or 16 ADC       X    1    X    X    X
 channels                                                                      
</table>
\Note: 1 = Jumper installed, 0 = Jumper not installed.

@@Register Set
\ \ 

@@Summary
\ \ 
<table>
Register Name                                \NOTE   Mnemonic   \Size   Direction   Offset   Bank<p />(IA[2..0])
===========================================  ======  =========  ======  ==========  =======  ====================
<b>::::::::: DIGITAL INPUT VALUES                                                            
 \:::::::::</b><p />'0' --\> 0 mA, '1'                                                        
 \--\> \> 4.5V                                                                                
Digital Input Group 0                                dig0       BYTE    r           0        X
Digital Input Group 1                                dig1       BYTE    r           1        X
Digital Input Group 2                                dig2       BYTE    r           2        X
Digital Input Group 3                                dig3       BYTE    r           3        X
Digital Input Group 4                                dig4       BYTE    r           4        X
Digital Input Group 5                                dig5       BYTE    r           5        X
Interrupt Source Enable By Group<p />'0'             isebg      BYTE    rw          6        X
 \--\> disabled, '1' --\> Group enabled                                                       
Bank Select                                          bank       BYTE    rw          7        X
Zero Byte 0x00                               (1)     zb0        BYTE    r           8        000
Zero Byte 0x00                               (1)     zb1        BYTE    r           9        000
Zero Byte 0x00                               (1)     zb2        BYTE    r           10       000
Zero Byte 0x00                               (1)     zb3        BYTE    r           11       000
Zero Byte 0x00                               (1)     zb4        BYTE    r           12       000
Zero Byte 0x00                               (1)     zb5        BYTE    r           13       000
unused                                       (2)     \-         BYTE    \-          14       000
unused                                       (2)     \-         BYTE    \-          15       000
<b>::::::::: FALLING/RISING EDGE                                                             000
 DETECT :::::::::</b><p />'1' --\>                                                            
 Falling Edge (FE), '0' --\> Rising                                                           
 Edge (RE)                                                                                    
Edge Polarity Group 0                        (3)     ep0        BYTE    rw          8        001
Edge Polarity Group 1                        (3)     ep1        BYTE    rw          9        001
Edge Polarity Group 2                        (3)     ep2        BYTE    rw          10       001
Edge Polarity Group 3                        (3)     ep3        BYTE    rw          11       001
Edge Polarity Group 4                        (3)     ep4        BYTE    rw          12       001
Edge Polarity Group 5                        (3)     ep5        BYTE    rw          13       001
unused                                       (2)     \-         BYTE    \-          14       001
unused                                       (2)     \-         BYTE    \-          15       001
<b>::::::::: INTERRUPT BIT ENABLE                                                            
 \:::::::::</b>                                                                               
Interrupt Bit Enable Group 0                         ibe0       BYTE    rw          8        010
Interrupt Bit Enable Group 1                         ibe1       BYTE    rw          9        010
Interrupt Bit Enable Group 2                         ibe2       BYTE    rw          10       010
Interrupt Bit Enable Group 3                         ibe3       BYTE    rw          11       010
Interrupt Bit Enable Group 4                         ibe4       BYTE    rw          12       010
Interrupt Bit Enable Group 5                         ibe5       BYTE    rw          13       010
unused                                       (2)     \-         BYTE    \-          14       010
unused                                       (2)     \-         BYTE    \-          15       010
<b>::::::::: PENDING / CLEAR INTERRUPT                                                       
 \:::::::::</b><p />Read --\>Pending, Write                                                   
 \--\>Clear                                                                                   
Pending Clear Group 0                                pc0        BYTE    rw          8        011
Pending Clear Group 1                                pc1        BYTE    rw          9        011
Pending Clear Group 2                                pc2        BYTE    rw          10       011
Pending Clear Group 3                                pc3        BYTE    rw          11       011
Pending Clear Group 4                                pc4        BYTE    rw          12       011
Pending Clear Group 5                                pc5        BYTE    rw          13       011
unused                                       (2)     \-         BYTE    \-          14       011
unused                                       (2)     \-         BYTE    \-          15       011
<b>::::::::: MISC OPERATIONS :::::::::</b>                                                   
SPI FIFO Read / Write                        (4)     sfd        BYTE    rw          8        100
SPI Status                                   (4)     sfs        BYTE    r           9        100
SPI Configuration                            (4)     spic       BYTE    rw          10       100
\                                                               BYTE                11       
\                                                               BYTE                12       
\                                                               BYTE                13       
\                                                               BYTE                14       
\                                                               BYTE                15       
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
\                                                                                            
</table>
(1) Will always read back as 0x00

(2) Unused port locations. LED will not blink when reading or
writing to these specific port locations.

(3) If bit value = '1' then falling-edge (FE), otherwise
rising-edge (RE)

(4) Only available with jumper M0 installed


Summary
Overview of the %CARD_NAME% register set.
Example
<code lang="c++">
/* STX104 Register Set Definitions */
\#define STX104_SOFTWARE_STROBE                            0   /* offset (to be added to the base address) */
\#define STX104_ADC_DATA_LSB                               0
\#define STX104_ADC_DATA_MSB                               1
\#define STX104_ADC_DATA                                   0
\#define STX104_CHANNEL                                    2
\#define STX104_DIGITAL_OUTPUTS                            3
\#define STX104_DIGITAL_INPUTS                             3
\#define STX104_DAC_CHANA_LSB                              4
\#define STX104_DAC_CHANA_MSB                              5
\#define STX104_DAC_CHANA                                  4
\#define STX104_DAC_CHANB_LSB                              6
\#define STX104_DAC_CHANB_MSB                              7
\#define STX104_DAC_CHANB,DACB                             6
\#define STX104_CLEAR_INTERRUPTS                           8
\#define STX104_ADC_STATUS                                 8
\#define STX104_ADC_CONTROL                                9
\#define STX104_PACER_CLOCK_CONTROL                        10
\#define STX104_FIFO_FLAGS                                 10
\#define STX104_ADC_CONFIGURATION                          11
\#define STX104_CT0_DATA                                   12
\#define STX104_CT1_DATA                                   13
\#define STX104_CT2_DATA                                   14
\#define STX104_CT_CONFIGURATION                           15
\#define STX104_FIFO_DATA_STATUS                           15
\#define STX104_CONVERSION_DISABLE                         1028
\#define STX104_BURST_MODE_ENABLE                          1029
\#define STX104_BURST_FUNCTION                             1030
\#define STX104_EXTENDED_STATUS                            1031
/* Applicable to Firmware Revision 080214H and beyond    */
\#define STX104_INDEXED_DATA_LSB                           12  /* offset (to be added to the base address) */
\#define STX104_INDEXED_DATA_MSB                           13
\#define STX104_INDEX_DATA                                 12
\#define STX104_INDEX_POINTER                              14
// indexed register array
\#define STX104_GENERAL_CONFIGURATION                      0   /* index */
\#define STX104_INTERRUPT_SOURCE_SELECT                    2
\#define STX104_INTERRUPT_CONFIGURATION                    4
\#define STX104_INTERRUPT_THRESHOLD                        8
\#define STX104_DIGITAL_OUTPUT_CONFIGURATION               12
\#define STX104_DIGITAL_INPUT_CONFIGURATION                14
\#define STX104_TRIGGER_CONFIGURATION                      16
\#define STX104_TRIGGER_START_DELAY                        20
\#define STX104_ANALOG_INPUT_GENERAL_CONFIG                32
\#define STX104_ANALOG_INPUT_FRAME_TIMER                   36
\#define STX104_ANALOG_INPUT_BURST_TIMER                   40
\#define STX104_ANALOG_INPUT_FRAME_MAX                     44
\#define STX104_ANALOG_INPUT_FRAME_COUNT                   48
\#define STX104_CONVERSION_DISABLE_INDEXED                 64
\#define STX104_BURST_MODE_ENABLE_INDEXED                  65
\#define STX104_BURST_FUNCTION_ENABLE_INDEXED              66
\#define STX104_EXTENDED_STATUS_INDEXED                    67
\#define STX104_CT0_DATA_INDEXED                           68
\#define STX104_CT1_DATA_INDEXED                           69
\#define STX104_CT2_DATA_INDEXED                           70
\#define STX104_CT_CONFIGURATION_INDEXED                   71
\#define STX104_MISCELLANEOUS_OUTPUT_CONFIG                208
\#define STX104_FIFO_DATA_AVAILABLE                        224
\#define STX104_FIFO_CONFIGURATION                         228
\#define STX104_SCRATCH_PAD                                248
\#define STX104_BOARD_ID                                   250
</code>

@@Legal Notice
\ \ 

Apex Embedded Systems’ sole obligation for products that
prove to be defective within 1 year from date of purchase
will be for replacement or refund. Apex Embedded Systems
gives no warranty, either expressed or implied, and
specifically disclaims all other warranties, including
warranties for merchantability and fitness. In no event shall
Apex Embedded Systems’ liability exceed the buyer's purchase
price, nor shall Apex Embedded Systems be liable for any
indirect or consequential damages.



This warranty does not apply to products which have been
subject to misuse (including static discharge), neglect,
accident or modification, or which have been soldered or
altered during assembly and are not capable of being tested.



DO NOT USE PRODUCTS SOLD BY APEX EMBEDDED SYSTEMS AS CRITICAL
COMPONENTS IN LIFE SUPPORT DEVICES OR SYSTEMS!



Products sold by Apex Embedded Systems are not authorized for
use as critical components in life support devices or
systems. A critical component is any component of a life
support device or system whose failure to perform can be
reasonably expected to cause the failure of the life support
device or system, or to affect its safety or effectiveness.

@@PC/104 Insertion Caution
\ \ 
<align center>
Before powering up the PC/104 stack...<image image002>and
look for proper PC/104 connector alignment.



This simple step will prevent permanent board damage.





</align>
Helpful hint: During system prototyping install the spacers
to help guide installation and provide another means of
checking board alignment. We recommend having the bolt end of
the spacer facing up to act as a guide or alignment pin.

@@Definitions
Summary
Definition of terms.

@@Application Notes
\ \ 

@@High Speed Data Acquistion
\ \ 

@@High Impedance Sources
\ \ 


@@Linux
\ \ 

@@DOS
\ \ 

@@Generic
\ \ 
Summary
\ \ 
Description
\ \ 



Function Name, Description. Thies can be imported directly.

@@Windows
\ \ 

@@QNX
\ \ 


@@Labview
\ \ 

@@Accessory Items
\ \ 






@@Tips and Techniques
\ \ 



  1. Use a frequency counter and monitor SSH to determine the
     rate of analog input bursts.
  2. \  







@@ADC Data LSB
<title ADC Data LSB (Offset=0)>

Summary
ADC Data LSB. Please refer to <link ADC Data> Register for
further details.
See Also
<link Summary, Register Summary>

@@ADC Data MSB
<title ADC Data MSB (Offset=1)>

Summary
ADC Data MSB. Please refer to <link ADC Data> Register for
further details.
See Also
<link Summary, Register Summary>

@@ADC Data
<title ADC Data (Offset=0)>

Summary
ADC Data Register.
Description
The ADC LSB register provides the least significant data byte
and the ADC MSB register provides the most significant data
byte. Each of the two registers can be read in any order
(when FIFO Superset is not enabled). Writing any data to the
ADC LSB register issues a software trigger.

Data bandwidth between the %CARD_NAME% and CPU (PC/104 ISA
bus) can be doubled by simply reading the ADC register as a
16-bit register. Software examples are shown below. Further
improvement in bus bandwidth can be had by limiting the
CPU-burst readouts (i.e. Insw() function) to the data
fragment buffer size; thus eliminating I/O wait states.



When FIFO Superset is enabled (M1 jumper installed) the ADC
data is read out of the FIFO as either a word or a byte at a
time. To read out the data correctly as a byte at a time, you
must first read the LSB and then the MSB. Once the MSB is
read, the FIFO is considered to be read and FIFO is advanced
to the next value to be read (if not empty). You may continue
to read the data until the FIFO empty flag is set. It is
possible to continuously sample analog inputs (continuous ADC
sampling or triggering) and continuously read FIFO without
any breaks in sampling.



It is the programmer’s responsibility to be sure that data is
read out in the correct sequence, as well as starting and
stopping the acquisition as required.





<b>For the following tables below, please refer to the <link Analog Input General Configuration>
Register and the <link Analog Input Polarity (Index=33\, RB='1'), Analog Input Polarity>
Register for details on ADC input bit pattern encoding
schemes.</b>

* VOLTAGE INPUT RANGES --- STRAIGHT BINARY ENCODING (default legacy mode) *
<table>
\OUTPUT<p />RANGE   UNIPOLAR        ADC CFG REG<p />G1   ADC CFG REG<p />G0   RESOLUTION   NEG FULL            POS FULL            NEG FULL        POS FULL
                     JUMPER<p />J9                                                          SCALE<p />VOLTAGE   SCALE<p />VOLTAGE   SCALE<p />HEX   SCALE<p />HEX
                     \*                                                                                                                             
==================  ==============  ===================  ===================  ===========  ==================  ==================  ==============  ==============
\+/- 10 Volts       0               0                    0                    305 uV       \-10.00             \+10.00             0x0000          0xFFFF
\+/- 5 Volts        0               0                    1                    153 uV       \-5.000             \+5.000             0x0000          0xFFFF
\+/- 2.5 Volts      0               1                    0                    76 uV        \-2.500             \+2.500             0x0000          0xFFFF
\+/- 1.25           0               1                    1                    38 uV        \-1.250             \+1.250             0x0000          0xFFFF
 Volts                                                                                                                                              
0 - 10 Volts        1               0                    0                    153 uV       0.000               \+10.00             0x0000          0xFFFF
0 - 5 Volts         1               0                    1                    76 uV        0.000               \+5.000             0x0000          0xFFFF
0 - 2.5 Volts       1               1                    0                    38 uV        0.000               \+2.500             0x0000          0xFFFF
0 - 1.25 Volts      1               1                    1                    19 uV        0.000               \+1.250             0x0000          0xFFFF
</table>
\* '1' = Jumper installed. '0' = Jumper not installed.

* VOLTAGE INPUT RANGES --- BITWISE INVERTED STRAIGHT BINARY ENCODING *
<table>
\OUTPUT<p />RANGE   UNIPOLAR        ADC CFG REG<p />G1   ADC CFG REG<p />G0   RESOLUTION   NEG FULL            POS FULL            NEG FULL        POS FULL
                     JUMPER<p />J9                                                          SCALE<p />VOLTAGE   SCALE<p />VOLTAGE   SCALE<p />HEX   SCALE<p />HEX
                     \*                                                                                                                             
==================  ==============  ===================  ===================  ===========  ==================  ==================  ==============  ==============
\+/- 10 Volts       0               0                    0                    305 uV       \-10.00             \+10.00             0xFFFF          0x0000
\+/- 5 Volts        0               0                    1                    153 uV       \-5.000             \+5.000             0xFFFF          0x0000
\+/- 2.5 Volts      0               1                    0                    76 uV        \-2.500             \+2.500             0xFFFF          0x0000
\+/- 1.25           0               1                    1                    38 uV        \-1.250             \+1.250             0xFFFF          0x0000
 Volts                                                                                                                                              
0 - 10 Volts        1               0                    0                    153 uV       0.000               \+10.00             0xFFFF          0x0000
0 - 5 Volts         1               0                    1                    76 uV        0.000               \+5.000             0xFFFF          0x0000
0 - 2.5 Volts       1               1                    0                    38 uV        0.000               \+2.500             0xFFFF          0x0000
0 - 1.25 Volts      1               1                    1                    19 uV        0.000               \+1.250             0xFFFF          0x0000
</table>
\* '1' = Jumper installed. '0' = Jumper not installed.

* VOLTAGE INPUT RANGES --- TWOs COMPLEMENT ENCODING *
<table>
\OUTPUT<p />RANGE   UNIPOLAR        ADC CFG REG<p />G1   ADC CFG REG<p />G0   RESOLUTION   NEG FULL            POS FULL            NEG FULL        POS FULL
                     JUMPER<p />J9                                                          SCALE<p />VOLTAGE   SCALE<p />VOLTAGE   SCALE<p />HEX   SCALE<p />HEX
                     \*                                                                                                                             
==================  ==============  ===================  ===================  ===========  ==================  ==================  ==============  ==============
\+/- 10 Volts       0               0                    0                    305 uV       \-10.00             \+10.00             0x8000          0x7FFF
\+/- 5 Volts        0               0                    1                    153 uV       \-5.000             \+5.000             0x8000          0x7FFF
\+/- 2.5 Volts      0               1                    0                    76 uV        \-2.500             \+2.500             0x8000          0x7FFF
\+/- 1.25           0               1                    1                    38 uV        \-1.250             \+1.250             0x8000          0x7FFF
 Volts                                                                                                                                              
0 - 10 Volts        1               0                    0                    153 uV       0.000               \+10.00             0x8000          0x7FFF
0 - 5 Volts         1               0                    1                    76 uV        0.000               \+5.000             0x8000          0x7FFF
0 - 2.5 Volts       1               1                    0                    38 uV        0.000               \+2.500             0x8000          0x7FFF
0 - 1.25 Volts      1               1                    1                    19 uV        0.000               \+1.250             0x8000          0x7FFF
</table>
\* '1' = Jumper installed. '0' = Jumper not installed.

* VOLTAGE INPUT RANGES --- TWOs COMPLEMENT ENCODING MULTIPLIED BY -1 with CLAMPING ENABLED *
<table>
\OUTPUT<p />RANGE   UNIPOLAR        ADC CFG REG<p />G1   ADC CFG REG<p />G0   RESOLUTION   NEG FULL            POS FULL            NEG FULL        POS FULL
                     JUMPER<p />J9                                                          SCALE<p />VOLTAGE   SCALE<p />VOLTAGE   SCALE<p />HEX   SCALE<p />HEX
                     \*                                                                                                                             
==================  ==============  ===================  ===================  ===========  ==================  ==================  ==============  ==============
\+/- 10 Volts       0               0                    0                    305 uV       \-10.00             \+10.00             0x7FFF          0x8001
\+/- 5 Volts        0               0                    1                    153 uV       \-5.000             \+5.000             0x7FFF          0x8001
\+/- 2.5 Volts      0               1                    0                    76 uV        \-2.500             \+2.500             0x7FFF          0x8001
\+/- 1.25           0               1                    1                    38 uV        \-1.250             \+1.250             0x7FFF          0x8001
 Volts                                                                                                                                              
0 - 10 Volts        1               0                    0                    153 uV       0.000               \+10.00             0x7FFF          0x8001
0 - 5 Volts         1               0                    1                    76 uV        0.000               \+5.000             0x7FFF          0x8001
0 - 2.5 Volts       1               1                    0                    38 uV        0.000               \+2.500             0x7FFF          0x8001
0 - 1.25 Volts      1               1                    1                    19 uV        0.000               \+1.250             0x7FFF          0x8001
</table>
\* '1' = Jumper installed. '0' = Jumper not installed.



* USING THE INSW() FUNCTION or THE REP INSW INSTRUCTION *
Using the REP INSW instruction (or Insw() function in Linux)
provides a very high speed mechanism for reading out ADC data
from the FIFO. This instruction is available on 286 CPUs and
above. In fact, this is faster and easier to use than DMA;
both in implementation and execution. Using REP INSW
alleviates video problems related with DMA as well as
improved CPU timing management (i.e. DMA adds timing holes in
the system that are not easily managed by simple real-time
kernels). The speed of any ISA bus I/O transaction is
dependent on the CPU ISA bus speed which is usually set in
the BIOS setup; use this setting with caution as it may
affect performance of other cards and/or can cause data loss.
This is usually available on many CPU cards.

Limiting the size of the sample count to the %CARD_NAME% data
fragment buffer in the Insw() function call will eliminate
I/O bus wait states and further enhance overall throughput.
In most cases this will improve throughput by another factor
of two.
Register Layout
<b>ADC LSB. Offset=0x0, Byte 0. Offset=0, Word 0.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
AD7   AD6   AD5   AD4   AD3   AD2   AD1   AD0
</table>

<b>ADC MSB. Offset=0x1, Byte 1. Offset=0, Word 0.</b>
<table>
D15    D14    D13    D12    D11    D10    D9    D8
=====  =====  =====  =====  =====  =====  ====  ====
AD15   AD14   AD13   AD12   AD11   AD10   AD9   AD8
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -------------------------------------------------------------
AD[15:0]   r           \- na -   ADC data word. AD0 is the least significant bit. AD15 is
                                  the most significant data bit.<p />In the Straight
                                  Binary Encoding (legacy default) a reading of 0<sub>10</sub>
                                  (0x0000) represents a negative full scale input and a
                                  value of 65535<sub>10</sub> (0xFFFF) represents an input
                                  of positive full scale.<p />The two registers can both
                                  be read simultaneously by simply reading the data as a
                                  16-bit I/O transaction (Examples: “in ax, dx” or
                                  “inpw(base_address+0)” ).<p />
</table>
Example
\Examples of how to read the ADC data. All of the following
\examples assume that the we are using Straight Binary Data
Encoding which is the legacy default mode.

* 8-Bit Read in C/C++: *
<code lang="c++">
union { unsigned int word; unsigned char byte[2]; } ad_value[16];
...
adc_value(channel).byte[0] = inp(base_address+0);
adc_value(channel).byte[1] = inp(base_address+1);
<color SyntaxHighlight_Keyword>/* adc_value(channel).word now contains the full ADC word value */</color>
...
</code>

* 16-Bit Read in C/C++: *
<code lang="c++">
unsigned int ad_value[16];
...
adc_value(channel) = inpw(base_address+0);
...

</code>
* 8-Bit Read and FIFO enabled in C/C++: *
<code lang="c++">
union { unsigned int word; unsigned char byte[2]; } ad_value[16];
...
if ( fifo_not_empty() == true ) <color SyntaxHighlight_Keyword>/* function to check fifo status */</color>
{
 adc_value(channel).byte[0] = inp(base_address+0);
 adc_value(channel).byte[1] = inp(base_address+1);
<color SyntaxHighlight_Keyword> /* adc_value(channel).word now contains the full ADC word value */</color>
}
...
</code>

* 16-Bit Read and FIFO enabled in C/C++: *
<code lang="c++">
unsigned ad_value[16];
...
if ( fifo_not_empty() == true ) <color SyntaxHighlight_Keyword>/* function to check fifo status */</color>
{
adc_value(channel) = inpw(base_address+0);
}
...
</code>

* 16-Bit Read with FIFO enabled in C/C++ using REP INSW: *
<code lang="c++">
typedef unsigned int WORD;

void insw(WORD port, void *buf, int count)
{
 _ES = FP_SEG(buf); <color SyntaxHighlight_Keyword>/* Segment of buf */</color>
 _DI = FP_OFF(buf); <color SyntaxHighlight_Keyword>/* Offset of buf */</color>
 _CX = count; <color SyntaxHighlight_Keyword>/* Number to read */</color>
 _DX = port; <color SyntaxHighlight_Keyword>/* Port */</color>
 asm REP INSW;
}

void main()
{
 WORD *data[512];
 ...
 insw(0x300, data, 512); <color SyntaxHighlight_Keyword>/* assumes 512 samples (or two blocks) in FIFO */</color>
 ...
}
</code>

* An example shown below illustrating how to set the gain and use it to determine the actual input voltage. *
<code lang="c++">
/****************************************************************************
   Apex Embedded Systems
   Revised: 03MAR08
   STX104 Analog Input Demo
\****************************************************************************/

\#include \<conio.h\>
\#include \<stdio.h\>
\#include \<dos.h\>

/****************************************************************************/
float adc_gain[8] = { 20.0/65536.0, 10.0/65536.0, 5.0/65536.0, 2.5/65536.0,
              10.0/65536.0,  5.0/65536.0, 2.5/65536.0, 1.25/65536.0 };
float adc_offset[8] = { -10.0, -5.0, -2.5, -1.25, 0.0, 0.0, 0.0, 0.0 };

/****************************************************************************/
float Adc_Voltage ( void )
{
    \long sum;
    int index;
    float voltage;

    /* take several samples and average */
    sum = 0;
    for ( index=0; index \<256; index++ )
    {
       outportb(0x300, 0x00); /* start a sample */
       while ( (inportb(0x308) &amp; 0x80) != 0x00 ); /* wait for sample */
       sum = sum + ((long)inpw(0x300));
    }
    sum = sum / 256;
    index = inportb( 0x30B ) &amp; 0x07;
    voltage = ( (float) sum ) * adc_gain[index] + adc_offset[index];
    return voltage;
}

/****************************************************************************/
void main()
{
      int x,y;
      unsigned char channels;

      channels = 0x00; /* scan channel zero only */
      /* base address set to factory default at 0x300 */
      /* initialize STX104 */
      outportb(0x309, 0x00); /* no interrupts, no DMA and s/w trigger */

      /* Applies to firmware revision 080214H only: for non-zero <i>first_channel</i>
         please write to channel register twice to correct for <link Errata, errata> issue.  This
         is transparent for other firmware revisions (simply means that acquisition
         controller is reset twice).
      \*/
      outportb(0x302, channels);
      outportb(0x302, channels);
      while ((inportb(0x308) &amp; 0x80 ) == 0x80 ); /* wait       */

      printf("0) +10.0V   input\\n");
      printf("1)  +5.0V   input\\n");
      printf("2)  +2.5V   input\\n");
      printf("3)  +1.25V  input\\n");
      printf("9) Quit this test\\n");

      do {
           y = inportb( 0x30B ) &amp; 0x07;
           if ( (y &amp; 0x04) == 0x00 ) printf("Bipolar:  ");
           else printf("Unipolar: ");
           y = y &amp; 0x03;
           printf(" Gain=");
           if ( y == 0 )      printf("10V,   ");
           else if ( y == 1 ) printf(" 5V,   ");
           else if ( y == 2 ) printf(" 2.5V, ");
           else if ( y == 3 ) printf(" 1.25V,");
           printf(" Voltage = %+10.6f        \\r", Adc_Voltage());

           if ( kbhit() )
           {
              y = getch();
              /* set gain */
              if ( y == '0' )      { x = 0;    outportb( 0x30B, x ); }
              else if ( y == '1' ) { x = 1;    outportb( 0x30B, x ); }
              else if ( y == '2' ) { x = 2;    outportb( 0x30B, x ); }
              else if ( y == '3' ) { x = 3;    outportb( 0x30B, x ); }
              else if ( y == '9' ) x = 9;
           }
       } while ( x != 9 );
       printf("\\n\\n");
}
</code>
See Also
<link Summary, Register Summary>

@@Digital Outputs
<title Digital Outputs (Offset=3)>

Summary
Digital Output Register.
Description
Digital TTL Outputs.
Register Layout
<b>Offset=0x3, Byte 0.</b>
<table>
D7   D6   D5   D4   D3      D2      D1      D0
===  ===  ===  ===  ======  ======  ======  ======
X    X    X    X    DOUT3   DOUT2   DOUT1   DOUT0
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  --------------------------------------------------
X           \-          \-        Don't Care
DOUT[3:0]   w           0000      Digital Outputs. These bits are write only.
                                   Non-inverted digital output bits. You must
                                   maintain a copy in software for bit manipulation.
</table>

<table>
BIT NAME   DIRECTION   CONNECTOR PIN   PHYSICAL I/O TYPE
                        POSITION        
=========  ==========  ==============  ==================
DOUT3      \---\>      J7.5            LVTTL Output
DOUT2      \---\>      J7.6            LVTTL Output
DOUT1      \---\>      J7.7            LVTTL Output
DOUT0      \---\>      J7.8            LVTTL Output
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Digital Inputs
<title Digital Inputs (Offset=3)>

Summary
Digital Input Register.
Description
Digital TTL inputs.
Register Layout
<b>Offset=0x3, Byte 0.</b>
<table>
D7    D6    D5   D4   D3     D2               D1     D0
====  ====  ===  ===  =====  ===============  =====  =====
CM1   CM0   X    X    DIN3   DIN2<p />GATE0   DIN1   DIN0
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  --------------------------------------------------------------
CM[1:0]    r           M0        Compatibility mode. These bits are set to zero for
                                  DAS16jr/16 mode. These bits are set to one for DAS1602
                                  mode compatibility.
X          \-          \-        Don't Care
DIN[3:0]   r           0000      Digital Inputs.<p />DIN0 also functions as an ADC
                                  external trigger input. As a trigger input, it is
                                  deglitched by an internal match-filter and requires a
                                  minimum pulse width of no less than 200nS. See the
                                  Interrupt Summary section for further functionality.<p />DIN2
                                  also functions as counter-zero gate input.
</table>

DIN1 and DIN3 swapped to their correct positions
<table>
BIT NAME   DIRECTION   CONNECTOR PIN   PHYSICAL I/O TYPE
                        POSITION        
=========  ==========  ==============  ==================
DIN3       \<---       J7.11           TTL Input
DIN2       \<---       J7.10           TTL Input
DIN1       \<---       J7.9            TTL Input
DIN0       \<---       J7.12           TTL Input
</table>

Classic STX104 Configuration (supporting existing customers,
Default mode)
<table>
BIT NAME   DIRECTION   CONNECTOR PIN   PHYSICAL I/O TYPE
                        POSITION        
=========  ==========  ==============  ==================
DIN3       \<---       J7.9            TTL Input
DIN2       \<---       J7.10           TTL Input
DIN1       \<---       J7.11           TTL Input
DIN0       \<---       J7.12           TTL Input
</table>

Example
\ \ 
See Also
<link Summary, Register Summary>

@@DAC Channel-A LSB
<title DAC Channel-A LSB (Offset=4)>

Summary
DAC Channel-A LSB. Please Refer to <link DAC Channel-A>
Register Details.


See Also
<link Summary, Register Summary>

@@DAC Channel-A MSB
<title DAC Channel-A MSB (Offset=5)>

Summary
DAC Channel-A MSB. Please Refer to <link DAC Channel-A>
Register Details.
See Also
<link Summary, Register Summary>

@@DAC Channel-A
<title DAC Channel-A (Offset=4)>

Summary
DAC Channel-A Register
Description
Each channel is updated once the MSB is written. Writing only
the MSB will update the DAC channel output. The results of
changing jumper settings at J5 will only take affect after
writing the MSB on the DAC output. The two 8-bit DAC
registers can be written simultaneously by writing the data
as a 16-bit I/O transaction (Examples: “out dx, ax” or
“outpw(base_address+4, dac_value)” ).

DAC outputs are available in either DAS16jr/16 or DAS1602
modes. The DAC outputs are always enabled and available for
use. The DAC output bit alignments can be adjusted for either
12-bit legacy operation or full 16-bit DAC mode.

* POWER UP or RESET *
At power-up or reset the DAC outputs are cleared to zero
volts.

* OUTPUT VOLTAGE CONVERSION *
<table>
\OUTPUT<p />RANGE   DA1_UB<p />J5   DA1_R<p />J5   RESOLUTION   NEG FULL            POS FULL            NEG FULL        POS FULL
                     \*              \*                          SCALE<p />VOLTAGE   SCALE<p />VOLTAGE   SCALE<p />HEX   SCALE<p />HEX
==================  ==============  =============  ===========  ==================  ==================  ==============  ==============
\+/- 10             1               1              305 uV       \-10.00             \+10.00             0x0000          0xFFFF
 Volts                                                                                                                   
\+/- 5 Volts        1               0              153 uV       \-5.000             \+5.000             0x0000          0xFFFF
0 - 10 Volts        0               1              153 uV       0.000               \+10.00             0x0000          0xFFFF
0 - 5 Volts         0               0              76 uV        0.000               \+5.000             0x0000          0xFFFF
</table>
\* '1' = Jumper installed. '0' = Jumper not installed.
Register Layout
\ \ 

<b>DAC Channel-A LSB. Offset=0x4, Byte 0. Offset=0x4, Word 0.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
DA7   DA6   DA5   DA4   DA3   DA2   DA1   DA0
</table>

<b>DAC Channel-A MSB. Offset=0x5, Byte 1. Offset=0x4, Word 0.</b>
<table>
D15    D14    D13    D12    D11    D10    D9    D8
=====  =====  =====  =====  =====  =====  ====  ====
DA15   DA14   DA13   DA12   DA11   DA10   DA9   DA8
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -----------------------------------------------
DA[15:0]   w           \- na -   DAC Channel-A data word in 16-Bit mode. DA0 is
                                  the least significant bit and DA15 is the most
                                  significant data bit.
</table>

<table>
BIT STRING   DIRECTION   CONNECTOR PIN POSITION   PHYSICAL I/O TYPE
 NAME                                              
===========  ==========  =======================  ==================
DA[15:0]     \---\>      J7.17 (DAC_OUT_1)        Analog Output
</table>
Example
\Examples of how to write to the DAC output register in
16-bit DAC mode.

* 8-Bit Writes in C/C++: *
<c> unsigned int dac_value;</c>

<c> ...</c>

<c> outp( base_address+4, dac_value &amp; 0xFF );</c>

<c> outp( base_address+5, dac_value \>\> 8 );</c>

<c> ...</c>



<c>or</c>



<c> union { unsigned int word; unsigned char byte[2]; }
dac_value;</c>

<c> ...</c>

<c> outp( base_address+4, dac_value.byte[0] );</c>

<c> outp( base_address+5, dac_value.byte[1] );</c>

<c> ...</c>



* 16-Bit Write in C/C++: *
<c> unsigned int dac_value;</c>

<c> ...</c>

<c> outpw( base_address+4, dac_value );</c>

<c> ...</c>
See Also
<link Summary, Register Summary>

@@DAC Channel-B LSB
<title DAC Channel-B LSB (Offset=6)>

Summary
DAC Channel-B LSB. Please Refer to <link DAC Channel-B>
Register Details.
See Also
<link Summary, Register Summary>

@@DAC Channel-B MSB
<title DAC Channel-B MSB (Offset=7)>

Summary
DAC Channel-B MSB. Please Refer to <link DAC Channel-B>
Register Details.
See Also
<link Summary, Register Summary>

@@DAC Channel-B
<title DAC Channel-B (Offset=6)>

Summary
DAC Channel-B Register
Description
Each channel is updated once the MSB is written. Writing only
the MSB will update the DAC channel output. The results of
changing jumper settings at J5 will only take affect after
writing the MSB on the DAC output. The two 8-bit DAC
registers can be written simultaneously by writing the data
as a 16-bit I/O transaction (Examples: “out dx, ax” or
“outpw(base_address+4, dac_value)” ).

DAC outputs are available in either DAS16jr/16 or DAS1602
modes. The DAC outputs are always enabled and available for
use. The DAC output bit alignments can be adjusted for either
12-bit legacy operation or full 16-bit DAC mode.

* POWER UP or RESET *
At power-up or reset the DAC outputs are at set to zero
volts.

* OUTPUT VOLTAGE CONVERSION *
<table>
\OUTPUT<p />RANGE   DB1_UB<p />J5   DB1_R<p />J5   RESOLUTION   NEG FULL            POS FULL            NEG FULL        POS FULL
                     \*              \*                          SCALE<p />VOLTAGE   SCALE<p />VOLTAGE   SCALE<p />HEX   SCALE<p />HEX
==================  ==============  =============  ===========  ==================  ==================  ==============  ==============
\+/- 10             1               1              305 uV       \-10.00             \+10.00             0x0000          0xFFFF
 Volts                                                                                                                   
\+/- 5 Volts        1               0              153 uV       \-5.000             \+5.000             0x0000          0xFFFF
0 - 10 Volts        0               1              153 uV       0.000               \+10.00             0x0000          0xFFFF
0 - 5 Volts         0               0              76 uV        0.000               \+5.000             0x0000          0xFFFF
</table>
\* '1' = Jumper installed. '0' = Jumper not installed.
Register Layout
\ \ 

<b>DAC Channel-B LSB. Offset=0x6, Byte 0. Offset=0x6, Word 0.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
DB7   DB6   DB5   DB4   DB3   DB2   DB1   DB0
</table>

<b>DAC Channel-B MSB. Offset=0x7, Byte 0. Offset=0x6, Word 0.</b>
<table>
D15    D14    D13    D12    D11    D10    D9    D8
=====  =====  =====  =====  =====  =====  ====  ====
DB15   DB14   DB13   DB12   DB11   DB10   DB9   DB8
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -----------------------------------------------
DB[15:0]   w           \- na -   DAC Channel-A data word in 16-Bit mode. DA0 is
                                  the least significant bit and DB15 is the most
                                  significant data bit.
</table>

<table>
BIT STRING   DIRECTION   CONNECTOR PIN POSITION   PHYSICAL I/O TYPE
 NAME                                              
===========  ==========  =======================  ==================
DB[15:0]     \---\>      J7.16 (DAC_OUT_2)        Analog Output
</table>
Example
\Examples of how to write to the DAC output register in
16-bit DAC mode.

* 8-Bit Writes in C/C++: *
<c>unsigned int dac_value;</c>

<c>...</c>

<c>outp( base_address+6, dac_value &amp; 0xFF );</c>

<c>outp( base_address+7, dac_value \>\> 8 );</c>

<c>...</c>



<c>or</c>



<c>union { unsigned int word; unsigned char byte[2]; }
dac_value;</c>

<c>...</c>

<c>outp( base_address+6, dac_value.byte[0] );</c>

<c>outp( base_address+7, dac_value.byte[1] );</c>

<c>...</c>



* 16-Bit Write in C/C++: *
<c>unsigned int dac_value;</c>

<c>...</c>

<c>outpw( base_address+6, dac_value );</c>

<c>...</c>
See Also
<link Summary, Register Summary>

@@Clear Interrupts
<title Clear Interrupts (Offset=8)>

Summary
Clear Interrupt Register
Description
Writing to this register will clear any pending interrupts.
Register Layout
\ \ 

<b>Offset=0x8, Byte 0.</b>
<table>
D7   D6   D5   D4   D3   D2   D1   D0
===  ===  ===  ===  ===  ===  ===  ===
X    X    X    X    X    X    X    X
</table>
Bit Definitions
\ \ 
<table>
NAME   DIRECTION   DEFAULT   \DESCRIPTION
=====  ==========  ========  -------------
X      \-          \-        Don't Care
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@ADC Status
<title ADC Status (Offset=8)>

Summary
ADC Status Register.
Description
\ \ 
Register Layout
\ \ 

<b>Offset=0x8, Byte 0. ISSBE='1' (refer to the <link Interrupt Configuration, Interrupt Configuration Register>).</b>
<table>
D7    D6   D5   D4    D3    D2       D1     D0
====  ===  ===  ====  ====  =======  =====  =====
CNV   UB   SD   INT   TAS   FF_INT   ISSB   ISSA
</table>

<b>Offset=0x8, Byte 0. ISSBE='0' (default).</b>
<table>
D7    D6   D5   D4    D3    D2    D1    D0
====  ===  ===  ====  ====  ====  ====  ====
CNV   UB   SD   INT   CH3   CH2   CH1   CH0
</table>
Bit Definitions
<table>
NAME      DIRECTION   DEFAULT   \DESCRIPTION
========  ==========  ========  ---------------------------------------------------------------
CNV       r           0         ADC Conversion (and/or ADC-Burst in DAS1602 mode) in
                                 progress. Writing to the Channel Register may cause the CNV
                                 bit to become active indicating that a %CARD_NAME% internal
                                 \reset is in progress (typically less than 1uS, and less
                                 than 10uS when moving average filter is enabled).<p />1 =
                                 ADC conversion, scan or acquisition reset in progress.<p />0
                                 = ADC Idle (default)
UB        r           \-        Unipolar / Bipolar ADC input mode setting (J9):<p />0 =
                                 bipolar. Measure both negative and positive input<p />voltages
                                 (J9 not stuffed)<p />1 = unipolar. Measure only positive
                                 \input values
SD        r           \-        Single-ended / Differential ADC input mode setting (J8):<p />0
                                 = Single-ended<p />1 = Differential (J8 not stuffed)
INT       r           0         Interrupt request status bit.<p />0 = No interrupt pending
                                 (default)<p />1 = Interrupt is pending; ADC trigger or
                                 ADC-Burst conversion<p />has completed<p />Note: ADC
                                 conversions continue to occur on schedule (via selected
                                 trigger source) regardless of whether this bit is cleared.
                                 If a new conversion occurs before this bit is cleared, an
                                 over-run condition may have occurred. Therefore, the
                                 programmer must ensure that the interrupt rate is not
                                 faster than the capacity of the CPU and software to
                                 respond.<p />If FIFO Superset is enabled (jumper M1
                                 installed), then the only over-run that will occur is if
                                 the FIFO is full (FIFO Full flag is true or FF=’1’). Thus,
                                 interrupt latency requirements are greatly relaxed.<p />If
                                 ADC interrupts are not enabled, this bit can still be used
                                 to determine when an ADC conversion has occurred when
                                 polling this bit.
CH[3:0]   r           0000      Current ADC channel. This is the channel currently selected
                                 on the board and is the channel that will be used for the
                                 next ADC conversion provided CNV=0 (unless a new value is
                                 written to the channel register). The CH[3:0] will change
                                 shortly after an ADC trigger.
TAS       r           0         Trigger Activity State. This is the same status bit as the
                                 TRG bit found in the <link ADC Configuration> Register. The
                                 trigger status is provided here so that interrupt and board
                                 status can be read as one value, thus keeping an interrupt
                                 service routine short as possible.<p />0 = trigger inactive
                                 (default)<p />1 = trigger active
FF_INT    r           0         FIFO Interrupt Status (Please refer to <link FIFO Status MSB>
                                 Register for further details):<p />0 = Not Active<p />1 =
                                 Interrupt Active
ISSB      r           0         Interrupt Status Source B:<p />0 = Not Active<p />1 =
                                 Interrupt Active
ISSA      r           0         Interrupt Status Source A:<p />0 = Not Active<p />1 =
                                 Interrupt Active
X         \-          \-        Don't Care
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@ADC Control
<title ADC Control (Offset=9)>

Summary
ADC Control Register
Description
The ADC Control Register is used to configure interrupts,
select DMA mode and select ADC trigger source.

See <link Interrupt Summary> for more information on
interrupts.

* DMA NOTE *
We strongly encourage you to use the REP INSW instruction (or
Insw() function in Linux) as it performs better than DMA and
is substantially simpler to set up and use. Note that DMA
performs I/O to memory transfers a byte at a time (DMA 1 and
DMA 3 are byte wide transfers) while REP INSW performs I/O to
memory transfers a word at a time. If you are designing a
real-time system, you will have better timing control over
your system by using REP INSW instruction over DMA. Since
processor generated I/O cycles are faster than DMA generated
cycles (typically 350ns versus 800ns), data transfer can take
place faster than DMA. Note that 8-bit bus transactions
(including DMA) are typically at least twice as long as
16-bit bus transactions; this alone is reason enough to avoid
DMA.

When DMA is enabled, the 1 mega-sample FIFO is used
internally.

In DMA mode, receiving a terminal count from the CPU will
generate an interrupt, if the interrupt is enabled. If you
are in DAS1602 mode (jumper M0 is installed), receiving a
terminal count will set the Conversion Disable bit to false,
thus disabling any additional ADC triggers (or sampling).
Writing 0x00 to the Conversion Disable Register will allow
ADC sampling to continue.

In order to use DMA, you must set up the computer’s DMA
controller and page registers before enabling DMA on the
%CARD_NAME% board.

The speed of any ISA bus I/O transaction is dependent on the
CPU ISA bus speed which is usually set in the BIOS setup; use
this setting with caution as it may affect performance of
other cards and/or can cause data loss. This is usually
available on many CPU cards.
Register Layout
\ \ 

<b>Offset=0x9, Byte 0. EIS='1', Please refer to the <link Interrupt Configuration, Interrupt Configuration Register>.</b>
<table>
D7     D6     D5     D4     D3        D2     D1          D0
=====  =====  =====  =====  ========  =====  ==========  ==========
IES3   IES2   IES1   IES0   FIE (a)   DMAE   ALSS1 (b)   ALSS0 (b)
</table>

<b>Offset=0x9, Byte 0. EIS='0' (default), Please refer to the
<link Interrupt Configuration, Interrupt Configuration Register>.</b>
<table>
D7    D6      D5      D4      D3        D2     D1          D0
====  ======  ======  ======  ========  =====  ==========  ==========
AIE   INTS2   INTS1   INTS0   FIE (a)   DMAE   ALSS1 (b)   ALSS0 (b)
</table>

(a) FIFO Superset Enabled (jumper M1 installed), otherwise
the bit is a don’t care.



(b) Was previously named TSx. The term “ADC-sample” or
“ADC-burst” is used to replace the term “trigger”, since
triggering takes on a more generalized definition.
Bit Definitions
\ \ 
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ----------------------------------------------------------------
IES[3:0]    rw          0000      Interrupt enhanced select (available only in Enhanced
                                   Register Set Mode):<p />0000 = Not valid, interrupts
                                   disabled (default)<p />0001 = Not valid, interrupts
                                   disabled<p />0010 = IRQ9/2 (IRQ2 for 8-bit or XT, IRQ9
                                   for 16-bit or AT)<p />0011 = IRQ3<p />0100 = IRQ4<p />0101
                                   = IRQ5<p />0110 = IRQ6<p />0111 = IRQ7<p />1000 = Not
                                   valid, interrupts disabled<p />1001 = IRQ9/2 (IRQ2 for
                                   8-bit or XT, IRQ9 for 16-bit or AT)<p />1010 = IRQ10<p />1011
                                   = IRQ11<p />1100 = IRQ12<p />1101 = Not valid, interrupts
                                   disabled<p />1110 = IRQ14<p />1111 = IRQ15
AIE         rw          0         ADC Interrupt Enable.<p />0 = Disable interrupt (default)<p />1
                                   = Enable interrupt
INTS[2:0]   rw          000       Interrupt select:<p />000 = Not valid, interrupts
                                   disabled (default)<p />001 = Not valid, interrupts
                                   disabled<p />010 = IRQ2<p />011 = IRQ3<p />100 = IRQ4<p />101
                                   = IRQ5<p />110 = IRQ6<p />111 = IRQ7
FIE         rw          0         FIFO Interrupt Enable (only when jumper M1 is installed):<p />0
                                   = Disable FIFO interrupt (default)<p />1 = Enable FIFO
                                   interrupt
DMAE        rw          0         Direct Memory Access (DMA) enable:<p />0 = Disable DMA
                                   transactions (default)<p />1 = Enable DMA transactions<p />The
                                   DMA request lines are tri-stated until the DMA bit is
                                   enabled, thus allowing multiple DMA devices to share the
                                   selected DMA channel provided that they are not enabled
                                   at the same time.
ALSS[1:0]   rw          00        ADC-Sample or ADC-Burst Legacy Sampling Select:<p />0X =
                                   Software (default)<p />10 = DIN0 rising/falling edge<p />11
                                   = 8254 Counter 1 &amp; 2 Pacer CT_OUT2 rising edge
X           \-          \-        Don’t Care
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Pacer Clock Control
<title Pacer Clock Control (Offset=10)>

Summary
Pacer Clock Control
Description
\ \ 
Register Layout
\ \ 

<b>Offset=0xA, Byte 0. DAS16jr/16 Compatibility Mode (M0
jumper *not* installed).</b>
<table>
D7   D6   D5   D4   D3   D2   D1        D0
===  ===  ===  ===  ===  ===  ========  ======
X    X    X    X    X    X    CT_SRC0   GCTRL
</table>

<b>Offset=0xA, Byte 0. DAS1602 Compatibility Mode (M0 jumper
installed).</b>
<table>
D7     D6     D5     D4     D3   D2   D1        D0
=====  =====  =====  =====  ===  ===  ========  ======
ABL3   ABL2   ABL1   ABL0   X    X    CT_SRC0   GCTRL
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -----------------------------------------------------------------
ABL[3:0]   w           \-        ADC-Burst Length. Determines the number of conversions per
                                  trigger when in burst mode. One to sixteen samples
                                  (single-ended) or up to eight channels (differential) in a
                                  burst. When not in Burst mode, then these bits have no
                                  function. The burst length is only used in the DAS1602
                                  compatibility mode.<p /><p />If ABL[3:0]=0x0, then
                                  1-channel burst is performed. If ABL[3:0]=0xF, then
                                  16-channel ADC-burst is performed.<p />
CT_SRC0    w           1         Counter 0 Clock Source:<p />1 = Counter 0 Clock Source is
                                  a 100KHz on-board reference frequency. CT_SRC0 (J7.4)
                                  gates this signal. When this bit is high (default), the
                                  100KHz signal runs, otherwise the 100KHz clock is stopped.<p />0
                                  = Counter 0 Clock Source to Counter 0 is an inverted
                                  polarity copy of CT_CLK0 input. CT_CLK0 is connected to a
                                  10K ohm pull-up resistor.<p />
GCTRL      w           0         Counters 1 and 2 gate control:<p />0 = Counters 1 and 2
                                  run freely with no gating.<p />1 = Counters 1 and 2 are
                                  gated by DIN0 (J7.12). DIN0 is connected to a 10K ohm
                                  pull-up resistor.<p />
X          \-          \-        Don't Care
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@ADC Configuration
<title ADC Configuration (Offset=11)>

Summary
ADC Configuration Register
Description
* REGISTER BANK SELECT *
Register Bank Select is a mechanism for providing additional
configuration options for the %CARD_NAME%, while preserving
the existing register set foot-print within the I/O space.
Writing the sequence 0xFX, 0x5X, 0xDX will enable the Indexed
Register Array Bank. Writing the sequence 0x3X, 0xBX, 0xAX
will disable the Indexed Register Array Bank. Writing any
other sequence will not change the state of the register
bank. The sequences preserve upward compatibility and ensure
that the bank select remains set even under existing software
activity. Bank select can be verified by reading the RB bit
shown above.

* GAIN SUMMARY *
Writing to this register sets the analog input gain for all
8/16 analog inputs. The ADBU bit is set by hardware. The
current input gain is determined by reading this register.

<table>
\INPUT RANGE   RESOLUTION   ADBU   G1   G0
=============  ===========  =====  ===  ===
\+/- 10 V      305 uV       0      0    0
\+/- 5 V       153 uV       0      0    1
\+/- 2.5 V     76 uV        0      1    0
\+/- 1.25 V    38 uV        0      1    1
0 - 10 V       153 uV       1      0    0
0 - 5 V        76 uV        1      0    1
0 - 2.5 V      38 uV        1      1    0
0 - 1.25 V     19 uV        1      1    1
</table>

The ADC data range is –32768<sub>10</sub> to 32767<sub>10</sub>
for each of the input ranges listed below.

See the software example in the ADC Data Register section
earlier in this chapter.

The gain setting is the ratio between the ADC full-scale
range and the effective input signal range. For example, if
the ADC full-scale range is 0-10V, a gain setting of 2
creates an input signal range of 0-5V, and gain setting of 4
creates an input range of 0-2.5V.
Register Layout
\ \ 

<b>Offset=0xB, Byte 0. Write Only Pattern.</b>
<table>
D7     D6     D5     D4     D3   D2   D1      D0
=====  =====  =====  =====  ===  ===  ======  ======
RBK3   RBK2   RBK1   RBK0   X    X    GAIN1   GAIN0
</table>

<b>Offset=0xB, Byte 0. Read Only Pattern.</b>
<table>
D7   D6   D5   D4   D3    D2     D1      D0
===  ===  ===  ===  ====  =====  ======  ======
RB   X    X    X    TRG   ADBU   GAIN1   GAIN0
</table>
Bit Definitions
\ \ 
<table>
NAME        DIRECTION   DEFAULT      \DESCRIPTION
==========  ==========  ===========  -----------------------------------------------------------------
RB          r           0            Register Bank Status (only available in Enhanced Register
                                      Mode):<p />0 = 8254 Counter/Timer Bank Active (default)<p />1
                                      = Indexed Register Array Bank Active
RBK[3:0]    w           8254 Bank    Register Bank Key Select (only available in Enhanced
                                      Register Mode). Writing a special sequence will bank
                                      select either the 8254 counter/timer or an Indexed
                                      Register Array Set. The default state is always with the
                                      8254 bank selected (i.e. original register set
                                      configuration).<p /><p />1111 --\> 0101 --\> 1101 F 5 D<p />0011
                                      \--\> 1011 --\> 1010 3 B A<p /><p />Writing the sequence
                                      0xFX, 0x5X, 0xDX will enable the Indexed Register Array
                                      Bank. Writing the sequence 0x3X, 0xBX, 0xAX will disable
                                      the Indexed Register Array Bank. The sequences preserve
                                      upward compatibility and ensure that the bank select
                                      remains set even under existing software activity.
TRG         r           0            Trigger Activity State. This same status bit is available
                                      at the <link ADC Status> Register TAS bit. This bit is
                                      available here as well as in the event that classic
                                      interrupts are required which would make the TAS bit
                                      unavailable.<p />0 = trigger inactive (default)<p />1 =
                                      trigger active
ADBU        r           depends on   ADC bipolar/unipolar:<p />0 = bipolar setting (jumper J9
                         J9           not installed)<p />1 = unipolar setting<p />
GAIN[1:0]   rw          00           ADC gain setting:<p />00 = gain of x1 (default)<p />01 =
                                      gain of x2<p />10 = gain of x4<p />11 = gain of x8<p />
X           \-          \-           Don’t care
</table>
Example
* BANKING BETWEEN 8254 AND THE INDEXED REGISTER ARRAY *
<code lang="c++">
/*****************************************************************
/                                      SET BANK 8254/INDEXED-ARRAY
/
/ Call this function when changing from one bank to another.  Recommend only
/ changing the bank when one read/writes to the 8254, since that is likely to
/ be read/written to the least amount compared to the indexed register array.
/
/ Alternatively, one could check the RB bit each time an indexed register
/ is read or written; it will then take longer on average to read/write registers.
\*/
void STX104_Set_Bank( int board, char bank )
{
    unsigned char scratch;
    unsigned char value;
    unsigned int address;

    address = stx104_base_address[board] + STX104_ADC_CONFIGURATION;
    scratch = inp( address );
    if ( bank == 0 ) /* request banking to the 8254 */
    { /* test for RB bit in ADC configuration register */
        if ( (scratch &amp; 0x80) == 0x80 )
        {
            scratch = scratch &amp; 0x0F;
            value = scratch | 0x30;
            outp( address, value );
            value = scratch | 0x30;
            outp( address, value );
            value = scratch | 0xB0;
            outp( address, value );
            value = scratch | 0xA0;
            outp( address, value );
        }
    }
    else
    {   /* request banking to the indexed register array */
        if ( (scratch &amp; 0x80) == 0 )
        {
            scratch = scratch &amp; 0x0F;
            value = scratch | 0xF0;
            outp( address, value );
            value = scratch | 0xF0;
            outp( address, value );
            value = scratch | 0x50;
            outp( address, value );
            value = scratch | 0xD0;
            outp( address, value );
        }
    }
}
</code>
See Also
<link Summary, Register Summary>

@@8254 CT0 Data
<title 8254 CT0 Data (Offset=12\, RB='0'.  Index=68\, RB='1')>

Summary
8254 CTO Data Register. Please refer to the <link 8254 Configuration>
Register for further details.
See Also
<link Summary, Register Summary>

@@8254 CT1 Data
<title 8254 CT1 Data (Offset=13\, RB='0'.  Index=69\, RB='1')>

Summary
8254 CT1 Data Register. Please refer to the <link 8254 Configuration>
Register for further details.
See Also
<link Summary, Register Summary>

@@8254 CT2 Data
<title 8254 CT2 Data (Offset=14\, RB='0'.  Index=70\, RB='1')>

Summary
8254 CT2 Data Register. Please refer to the <link 8254 Configuration>
Register for further details.
See Also
<link Summary, Register Summary>

@@8254 Configuration
<title 8254 Configuration (Offset=15\, RB='0'.  Index=71\, RB='1')>

Summary
8254 Configuration Register
Description
This register is available when Register Bank Status is '0'
(see <link ADC Configuration> Register bit RB).
Register Layout
\ \ 

<b> Offset=0xC, RB='0'. 8254 Counter/Timer Zero Data
Register.This register is available when Register Bank Status
is '0' (see <link ADC Configuration> Register bit RB).</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
CT0D7   CT0D6   CT0D5   CT0D4   CT0D3   CT0D2   CT0D1   CT0D0
</table>

<b>Offset=0xD, RB='0'. 8254 Counter/Timer One Data Register.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
CT1D7   CT1D6   CT1D5   CT1D4   CT1D3   CT1D2   CT1D1   CT1D0
</table>

<b>Offset=0xE, RB='0'. 8254 Counter/Timer Two Data Register.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
CT2D7   CT2D6   CT2D5   CT2D4   CT2D3   CT2D2   CT2D1   CT2D0
</table>

<b>Offset=0xF, RB='0'. 8254 Counter/Timer Configuration
Register.</b>
<table>
D7    D6    D5    D4    D3   D2   D1   D0
====  ====  ====  ====  ===  ===  ===  ====
SC1   SC0   RW1   RW0   M2   M1   M0   BCD
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ----------------------------------------------------------------
CT0D[7:0]   rw          \-        8254 Counter/Timer Zero Data Register
CT1D[7:0]   rw          \-        8254 Counter/Timer One Data Register
CT2D[7:0]   rw          \-        8254 Counter/Timer Two Data Register
SC[1:0]     w           \-        Select Counter:<p />00 = Select Counter 0<p />01 =
                                   Select Counter 1<p />10 = Select Counter 2<p />11 =
                                   Read-Back Command (see read operations)<p />
RW[1:0]     w           \-        Read/Write:<p />00 = Counter latch command<p />01 =
                                   Read/Write least significant byte only<p />10 =
                                   Read/Write most significant byte only<p />11 =
                                   Read/Write least significant byte first, then<p />most
                                   significant byte.<p />
M[2:0]      w           \-        Counter/Timer Mode Select:<p />000 = Mode 0, Interrupt
                                   on terminal count<p />001 = Mode 1, Hardware
                                   retriggerable one-shot<p />X10 = Mode 2, Rate generator<p />X11
                                   = Mode 3, Square wave generator<p />100 = Mode 4,
                                   Software triggered strobe<p />101 = Mode 5, Hardware
                                   triggered strobe (retriggerable)<p />
BCD         w           \-        Binary Coded Decimal (BCD) Counter (4 decades) if set
                                   to one, otherwise 16-bit binary counter.
</table>
Example
\ \ 
<code lang="c++">
/*****************************************************************
/                           ANALOG INPUT 8254 COUNTER 1 &amp; 2 TIMING
\*/
static void STX104_AI_Timing_8254_Set( int board, long time_interval_ns )
{
    \long high_count;
    \long low_count;
    unsigned int octet;

    STX104_Set_Bank( board, 0 );

    /* assumes 10MHz clock (i.e. no 1MHz jumper) */
    low_count  = 10L; /* 1 microsecond intervals */

    high_count = time_interval_ns / 1000;
    while ( high_count \> 65536L )
    {
        high_count = high_count \>\> 1;
        low_count  = low_count \<\< 1;
    }
    while ( high_count \< 2L )
    {
        high_count = high_count \<\< 1;
        low_count  = low_count \>\> 1;
    }
\#ifdef STX104_DEBUG_MODE
     fprintf( stdout, "low_count=%ld, high_count=%ld\\n",low_count,high_count);
     fprintf( stdout, "Actual Interval (uSec) = %ld\\n",time_interval_ns);
\#endif
    /* set counter/timer 2  */
    outportb( stx104_base_address[board] + STX104_CT_CONFIGURATION, 0xB4 );
    octet = ((unsigned int) high_count) &amp; 0x00FF;
    outp( stx104_base_address[board] + STX104_CT2_DATA, octet );
\#ifdef STX104_DEBUG_MODE
    fprintf( stdout, "CT2 LB=%u\\n",octet );
\#endif
    octet = ((unsigned int) high_count) \>\> 8;
    outp( stx104_base_address[board] + STX104_CT2_DATA, octet );
\#ifdef STX104_DEBUG_MODE
    fprintf( stdout, "CT2 HB=%u\\n",octet );
\#endif
    /* set counter/timer 1  */
    outportb( stx104_base_address[board] + STX104_CT_CONFIGURATION, 0x74 );
    octet = ((unsigned int) low_count) &amp; 0x00FF;
    outp( stx104_base_address[board] + STX104_CT1_DATA, octet );
\#ifdef STX104_DEBUG_MODE
    fprintf( stdout, "CT1 LB=%u\\n",octet );
\#endif
    octet = ((unsigned int) low_count) \>\> 8;
    outp( stx104_base_address[board] + STX104_CT1_DATA, octet );
\#ifdef STX104_DEBUG_MODE
    fprintf( stdout, "CT1 HB=%u\\n",octet );
\#endif
}
</code>
See Also
<link Summary, Register Summary>



<link ADC Configuration, ADC Configuration Register>



<extlink Intel 82C54 PIT.pdf>8254 Data Sheet</extlink>

@@FIFO Status MSB
<title FIFO Status MSB (Offset=10)>

Summary
FIFO Status MSB Register.
Description
The FIFO Status Registers are only available when FIFO
Superset is Enabled (M1 jumper installed).



The number of data blocks used in order to generate a FIFO
interrupt (FIFO_INT), can be adjusted via the FIBLK[1:0] bits
in the <link Interrupt Source Select> or the <link Interrupt Threshold>
registers. In many cases utilizing the FIBLK[1:0] bits is
sufficient and keeps the Interrupt Threshold Register
available for other functions.

* IOCHRDY and FIFO DATA FRAGMENT *
In order to avoid using IOCHRDY or I/O bus wait states the
%CARD_NAME% incorporates an intermediate data buffer to
support CPU-burst reads which avoid changing the state of the
IOCHRDY line.



When DFR is true, then the data fragment is ready to be read
out, typically using the Insw() function which incorporates
the REP INSW instruction.



There is theoretically no limit, other than the maximum size
of the entire %CARD_NAME% FIFO memory, on the number of
consecutive CPU reads that can occur. However, by limiting
the number of samples readout by the CPU using the Insw() to
approximately the size of the Data Fragment buffer, one can
avoid I/O bus wait states and further improve bus bandwidth.



It should be further stated that the CPU can still readout
data at any rate along with any ADC sampling mode. In fact,
the data fragment buffer will be used in nearly all cases,
thus bus wait states become a thing of the past. The only
case where I/O bus wait states will exist are cases where the
number of samples read out by the CPU in a CPU-bursting
readout (i.e. Insw() function) exceeds the data fragment
buffer size.

* FIFO CLEAR or RESET *
\Note that writing to the Channel Register will reset the
FIFO.
Register Layout
\ \ 

<b>Offset=0xA, Byte 0. FIFO Status MSB Register. </b>
<table>
D7         D6        D5   D4   D3      D2      D1     D0
=========  ========  ===  ===  ======  ======  =====  =====
FIFO_INT   DFR (a)   FF   FE   FBR11   FBR10   FBR9   FBR8
</table>

<b> Offset=0xF, Byte 0.</b> <b>FIFO Status LSB Register.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
FBR7   FBR6   FBR5   FBR4   FBR3   FBR2   FBR1   FBR0
</table>
Bit Definitions
\ \ 
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ---------------------------------------------------------------
FIFO_INT    r           0         FIFO Data Interrupt. An interrupt will occur for 512 or
                                   more samples queued in the FIFO in legacy mode. If
                                   FIBLK[1:0] not zero (refer to <link Interrupt Source Select>),
                                   then an interrupt will be generated with larger block
                                   counts. This bit can be polled and/or use to generate an
                                   interrupt to the CPU (setting FIE bit true in the ADC
                                   Control Register).<p />0 = No FIFO interrupt (default at
                                   \reset or power-up)<p />1 = FIFO interrupt active. To
                                   Clear Interrupt Register, write any value at Clear
                                   Interrupt Register.
DFR         r           0         Data Fragment Ready Flag:<p />0 = Data Fragment not ready
                                   (default at reset or power-up)<p />1 = Data Fragment
                                   ready.
FF          r           0         FIFO Full Flag.<p />0 = FIFO not full (default at reset or
                                   power-up)<p />1 = FIFO full/overflow has occurred.
FE          r           1         FIFO Empty Flag.<p />1 = Empty (default at reset or
                                   power-up)<p />0 = FIFO not empty, data is present
FBR[11:0]   r           0x000     FIFO Data Blocks Remaining. This provides a mechanism for
                                   measuring amount of data remaining within the FIFO. Each
                                   block is 256 samples. For example, if FBR=0x05 then at
                                   least 1,280 samples remain to be read out of the
                                   %CARD_NAME% FIFO. If FBR=0x00 and FE=’0’ then there are
                                   less than 256 samples remaining to be read out of the
                                   FIFO. When FBR\>0, use REP INSW to read in 256 samples at
                                   a time (1 block). When FBR=0, use a software loop that
                                   monitors the FE bit while reading in the samples until the
                                   FIFO is empty.
</table>
Example
\ \ 
* Below is an example of properly reading the FIFO status. This applies to firmware revisions specifically before 080214H (although it will still work fine for any revision 080214H or higher). *
<code lang="c++">

static int stx104_fifo_status_blocks[STX104_BOARDS_COUNT_MAX];
static unsigned char stx104_fifo_status_full[STX104_BOARDS_COUNT_MAX];
static unsigned char stx104_fifo_status_empty[STX104_BOARDS_COUNT_MAX];


/*****************************************************************
/                                                      FIFO STATUS
/ Revision History:
/ 15JAN07 - read FIFO status twice to remove the possibility
/           of reading an incorrect value due to FIFO status
/           changing during a 25nSec interval.
\*/
\#define STX104_FIFO_STATUS_READ_COUNT_MAX   1
void STX104_FIFO_Status( int board )
{
    union { unsigned int value; unsigned char octet[2]; } ff_stat[STX104_FIFO_STATUS_READ_COUNT_MAX+1];
    unsigned int fbr_blocks;
    unsigned int fbr_blocks_minimum;
    unsigned char i;

    fbr_blocks_minimum = 0x0FFF;

    for ( i=0; i\<=STX104_FIFO_STATUS_READ_COUNT_MAX; i++ )
    {
        ff_stat[i].octet[0] = inp( stx104_base_address[board] + STX104_FIFO_DATA_STATUS );
        ff_stat[i].octet[1] = inp( stx104_base_address[board] + STX104_FIFO_FLAGS );

        fbr_blocks = ff_stat[i].value &amp; 0x0FFF;
        if ( fbr_blocks \< fbr_blocks_minimum )
        {
            fbr_blocks_minimum = fbr_blocks;
        }
    }
    stx104_fifo_status_blocks[board] = (int) fbr_blocks_minimum;

    if ( (ff_stat[STX104_FIFO_STATUS_READ_COUNT_MAX].value &amp; 0x1000) != 0x0000) stx104_fifo_status_empty[board] = true;
    else stx104_fifo_status_empty[board] = false;
    if ( (ff_stat[STX104_FIFO_STATUS_READ_COUNT_MAX].value &amp; 0x2000) != 0x0000) stx104_fifo_status_full[board] = true;
    else stx104_fifo_status_full[board] = false;
}
</code>

* For firmware revisions 080214H or higher: *
<code lang="c++">

static int stx104_fifo_status_blocks[STX104_BOARDS_COUNT_MAX];
static unsigned char stx104_fifo_status_full[STX104_BOARDS_COUNT_MAX];
static unsigned char stx104_fifo_status_empty[STX104_BOARDS_COUNT_MAX];


/*****************************************************************
/                                                      FIFO STATUS
\*/
void STX104_FIFO_Status( int board )
{
    union { unsigned int value; unsigned char octet[2]; } ff_stat;

    ff_stat.octet[0] = inp( stx104_base_address[board] + STX104_FIFO_DATA_STATUS );
    ff_stat.octet[1] = inp( stx104_base_address[board] + STX104_FIFO_FLAGS );

    stx104_fifo_status_blocks[board] = ff_stat.value &amp; 0x0FFF;

    if ( (ff_stat.value &amp; 0x1000) != 0x0000) stx104_fifo_status_empty[board] = true;
    else stx104_fifo_status_empty[board] = false;
    if ( (ff_stat.value &amp; 0x2000) != 0x0000) stx104_fifo_status_full[board] = true;
    else stx104_fifo_status_full[board] = false;
}
</code>
See Also
<link Summary, Register Summary>

@@FIFO Status LSB
<title FIFO Status LSB (Offset=15)>

Summary
FIFO Status LSB Register. Please refer to <link FIFO Status MSB>
Register for details.
See Also
<link Summary, Register Summary>

@@CPU Limitation Accommodations
Summary
\ \ 
Description
\ \ 

The %CARD_NAME% can support the following CPU card
variations:

  * 10- or 16-bit Address decoding
  * 8- or 16-bit PC/104 data bus (without or with 40-pin
    connector, respectively).

@@ADC Channel
<title ADC Channel (Offset=2)>

Summary
ADC Channel Scan Register
Description
The channel register contains <i>first-channel</i> and the <i>last-channel</i>
in the scanning range of the analog multiplexer. When the
channel register is written the first-channel value is also
written to the <i>current-channel</i> which sets the analog
channel to be sampled. Upon an ADC trigger, the ADC samples
the <i>current-channel</i>, and the multiplexer is advanced
to the next channel. The current-channel value will wrap from
the <i>last-channel</i> to the to the <i>first-channel</i>
once the <i>last-channel </i> has been sampled.



The<i> current-channel</i> value is incremented only when the
ADC is sampled or triggered. For every ADC trigger, the <i>current-channel</i>
is incremented. The <i>current-channel</i> is presented as
CH[3:0] in the <link ADC Status, ADC Status Register>.



If the %CARD_NAME% is configured for differential input mode,
the most significant bit of the <i>current-channel</i> (and
therefore <i>first-</i> and<i> last-channel</i>) is ignored.



If the FIFO function is enabled, the user software must track
the channel being read out of the FIFO. In other words, it is
the software which must maintain synchronization.



If the <i>first-channel</i> is the same as the <i>last-channel</i>,
then the analog channel (multiplexer) is not changed. This
can be useful for sampling the same channel continuously.



It is recommended to have <i>first-channel</i> \<<i>
last-channel</i> to prevent confusion of the channel
sequencing as illustrated in examples (C) and (D) below.

* FIFO RESET *
Writing to the channel register will reset the FIFO when the
FIFO Superset mode is enabled (jumper M1 is installed) and/or
DAS1602 mode enabled (jumper M0 is installed).

* ACQUISITION CONTROLLER RESET *
Writing to the Channel Register resets the internal
acquisition controller in all modes.

* MOVING AVERAGE FILTER RESET *
Writing to the Channel Register also resets the internal
moving average filter in all modes when jumper M3 is
installed. The CNV bit (see <link ADC Status, ADC Status Register>)
will become active for approximately six microseconds while
the moving average filter is reset.

* SS&amp;H OUTPUT *
The Start Sample and Hold (SS&amp;H) signal, at pin 14 of the
I/O connector, is a TTL output used to drive the sample and
holds line of external simultaneous sample and hold cards.
The behavior of the SS&amp;H output signal is related to the
Channel Register. Writing any value to the Channel Register
will bring the SS&amp;H line active high. The SS&amp;H line
will go low, indicating a hold, when the <i>first_channel</i>
sampling has completed (i.e. the input multiplexers now
looking at the next channel). The SS&amp;H line will return
high when <i>last_channel</i> has been sampled and the
multiplexers wrap back to the <i>first_channel</i>.
Register Layout
<b>Offset=0x2, Byte 0.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
LC3   LC2   LC1   LC0   FC3   FC2   FC1   FC0
</table>
Bit Definitions
<table>
NAME      DIRECTION   DEFAULT   \DESCRIPTION
========  ==========  ========  ---------------------------------------------------------------------------
CH[3:0]   r           0000      Current Channel to be sampled. See <link ADC Status, ADC Status Register>.
                                 This value is sent to the analog multiplexers to set
                                 the current analog channel to be sampled. This value
                                 can be read in the ADC Status Register.<p />Shown here
                                 for completeness only.
FC[3:0]   rw          0000      First Channel. This is the first analog channel that is
                                 sampled. When this value is written, it will also set
                                 the current-channel ( CH = FC ).
LC[3:0]   rw          0000      Last Channel. This is the last analog channel that is
                                 sampled. Once this channel has been sampled, the
                                 current-channel value will wrap to the first-channel
                                 value.
</table>
Example
\Example channel sequencing (all in hexadecimal values):



a) LC[3:0] = D, FC[3:0] = 3

16-Channel, Single Ended: 3,4,5,6,7,8,9,A,B,C,D,3,4,5,...

8-Channel, Differential: 3,4,5,3,4,5,...



b) LC[3:0] = 1, FC[3:0] = 9

16-Channel, Single Ended: 9,A,B,C,D,E,F,0,1,9,A,B,C,...

8-Channel, Differential: 1,1,1,1,...



c) LC[3:0] = 6, FC[3:0] = 5

16-Channel, Single Ended: 5,6,5,6,...

8-Channel, Differential: 5,6,5,6,...



d) LC[3:0] = 5, FC[3:0] = 6

16-Channel, Single Ended:
5,6,7,8,9,A,B,C,D,E,F,0,1,2,3,4,5,6,7,8,9,...

8-Channel, Differential: 6,7,0,1,2,3,4,5,6,7,0,1,2,...
See Also
<link Summary, Register Summary>



<link Errata>

@@Index Data LSB
<title Index Data LSB (Offset=12\, RB='1')>

Summary
Indexed Data I/O least significant byte (or lower 8-bits).
Please refer to <link Index Data> Register for further
details.
See Also
<link Summary, Register Summary>

@@Index Data MSB
<title Index Data MSB (Offset=13\, RB='1')>

Summary
Indexed Data I/O most significant byte (or upper 8-bits). Please
refer to <link Index Data> Register for further details.
See Also
<link Summary, Register Summary>

@@Index Data
<title Index Data (Offset=12\, RB='1')>

Summary
Index Data Register
Description
\ \ 
Register Layout
\ \ 

<b>Offset=12, Byte 0. Offset=12, Word 0. RB='1'.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
ID7   ID6   ID5   ID4   ID3   ID2   ID1   ID0
</table>

<b>Offset=13, Byte 1. Offset=12, Word 0. RB='1'.</b>
<table>
D15    D14    D13    D12    D11    D10    D9    D8
=====  =====  =====  =====  =====  =====  ====  ====
ID15   ID14   ID13   ID12   ID11   ID10   ID9   ID8
</table>
Bit Definitions
\ \ 
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -------------
ID[15:0]   rw          \-        Indexed Data
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Index Pointer
<title Index Pointer  (Offset=14\, RB='1')>

Summary
Index Pointer Register. The purpose of utilizing an indexed
array of registers is to fit a large number of registers into
a small region of I/O address space. The indexed array of
registers are banked onto the 8254 I/O address space. At
power up or reset, the entire %CARD_NAME% register set will
appear and function exactly as the previous firmware version
of the %CARD_NAME% card. By writing a special pattern to the <link ADC Configuration>
Register one can bank between the 8254 and indexed array
registers as well as configure other %CARD_NAME% registers
for enhanced modes of operation.
Description
\ \ 

The drawing below illustrates the ISA bus interface to the
indexed register array.

<image index_summary>
* Index Register Description *
The Index Register is an address pointer that points into the
register set array. The Index Register can address any byte
or word. Read or writing any data within the indexed array
will cause the Index Register to automatically increment (if
AIID='0', refer to <link General Configuration> Register). If
the data read or written is 16-bits, then the Index Register
is automatic incremented by two. If the data read or written
is 8-bits (one byte), then the Index Register is incremented
by one. The auto-increment feature is implemented to reduce
overall software overhead. The auto-increment feature can be
disabled by setting the AIID bit in the General Configuration
Register. One can modify the value of the Indexed Register at
any time.



A logical representation of the indexed register array is
illustrated below. The internal registers can consist of
bytes (<i>signed</i> or <i>unsigned char</i>), words (<i>signed</i>
or <i>unsigned ints</i>) or double words (<i>signed</i> or <i>unsigned
\long</i>). For advanced configuration it is possible to
create a structure that can be simply uploaded to the indexed
register array.

<image index_array>
Register Layout
<b>Offset=14, Byte 0, RB='1'.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
IP7   IP6   IP5   IP4   IP3   IP2   IP1   IP0
</table>
Bit Definitions
\ \ 
<table>
NAME      DIRECTION   DEFAULT   \DESCRIPTION
========  ==========  ========  ------------------------
IP[7:0]   rw          0x00      Index Pointer Register.
</table>
Example
Below are examples of functions used to read/write the
indexed array. It is assumed that the indexed array has been
properly <link ADC Configuration, banked> into position.
Since it is likely that the 8254 registers will not be
regularly accessed in most situations, one could arrange to
check/set the banking bit RB when one needs to read/write the
8254 register.
<code lang="c++">
/*****************************************************************
/                                     INDEXED ARRAY DATA BYTE READ
\*/
static unsigned char STX104_Read_Indexed_Data_Byte( int board, unsigned char index )
{
    unsigned char value;

    outp( stx104_base_address[board]  + STX104_INDEX_POINTER, index );
    value = (unsigned char) inp( stx104_base_address[board] + STX104_INDEX_DATA );
    return( value );
}
/*****************************************************************
/                                     INDEXED ARRAY DATA WORD READ
\*/
static unsigned int STX104_Read_Indexed_Data_Word( int board, unsigned char index )
{
    unsigned int value;

    outp( stx104_base_address[board]  + STX104_INDEX_POINTER, index );
    value = inpw( stx104_base_address[board] + STX104_INDEX_DATA );
    return( value );
}
/*****************************************************************
/                                    INDEXED ARRAY DATA DWORD READ
\*/
static unsigned long STX104_Read_Indexed_Data_Dword( int board, unsigned char index )
{
    union{ unsigned long dword; unsigned int word[2]; } dvalue;

    outp( stx104_base_address[board]  + STX104_INDEX_POINTER, index );
    dvalue.word[0] = inpw( stx104_base_address[board] + STX104_INDEX_DATA );
    dvalue.word[1] = inpw( stx104_base_address[board] + STX104_INDEX_DATA );
    return( dvalue.dword );
}
/*****************************************************************
/                                    INDEXED ARRAY DATA BYTE WRITE
\*/
static void STX104_Write_Indexed_Data_Byte( int board, unsigned char index, unsigned char value )
{
    outp( stx104_base_address[board] + STX104_INDEX_POINTER, index );
    outp( stx104_base_address[board] + STX104_INDEX_DATA,    (unsigned int) value );
}
/*****************************************************************
/                                    INDEXED ARRAY DATA WORD WRITE
\*/
static void STX104_Write_Indexed_Data_Word( int board, unsigned char index, unsigned int value )
{
    outp( stx104_base_address[board]  + STX104_INDEX_POINTER, index );
    outpw( stx104_base_address[board] + STX104_INDEX_DATA,    value );
}
/*****************************************************************
/                                   INDEXED ARRAY DATA DWORD WRITE
\*/
static void STX104_Write_Indexed_Data_Dword( int board, unsigned char index, unsigned long value )
{
    union{ unsigned long dword; unsigned int word[2]; } dvalue;
    dvalue.dword = value;
    outp( stx104_base_address[board]  + STX104_INDEX_POINTER, index );
    outpw( stx104_base_address[board] + STX104_INDEX_DATA,    dvalue.word[0] );
    outpw( stx104_base_address[board] + STX104_INDEX_DATA,    dvalue.word[1] );
}
</code>
See Also
<link Summary, Register Summary>

@@Conversion Disable
<title Conversion Disable (Offset=1028; Index=64\, RB='1')>

Summary
Conversion Disable Register. DAS1602 Compatible Configuration
Register. In 10-bit address decode mode, the DAS1602
compatible registers are also accessible through the indexed
register set.
Description
Conversion Disable Register. On power-up or reset the
conversion triggers are enabled. This register is only
available if FE bit is true (DAS1602 Functions are enabled).
Writing a 0x00 to this register enables ADC triggering.
Writing 0x40 (64<sub>10</sub>) to this register disables ADC
triggering. If the FIFO Superset jumper M1 is not installed,
then when conversions are disabled, the FIFO is reset. If the
jumper M1 is installed, the FIFO is only reset by writing to
the channel register.
Register Layout
<b>Offset=0x404, RB=X. Also located at: Index=0x40, Byte 0,
RB='1'.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
CD7   CD6   CD5   CD4   CD3   CD2   CD1   CD0
</table>
Bit Definitions
<table>
NAME      DIRECTION   DEFAULT   \DESCRIPTION
========  ==========  ========  -------------------------------------------------------
CD[7:0]   w           0x00      Conversion Disable Register. On power-up or reset the
                                 conversion triggers are enabled. This register is only
                                 available if FE bit is true (DAS1602 Functions are
                                 enabled). Writing a 0x00 to this register enables ADC
                                 triggering. Writing 0x40 (64<sub>10</sub>) to this
                                 register disables ADC triggering. If the FIFO Superset
                                 jumper M1 is not installed, then when conversions are
                                 disabled, the FIFO is reset. If the jumper M1 is
                                 installed, the FIFO is only reset by writing to the
                                 channel register.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Burst Mode Enable
<title Burst Mode Enable  (Offset=1029; Index=65\, RB='1')>

Summary
ADC Burst Mode Enable Register. DAS1602 Compatible
Configuration Register. In 10-bit address decode mode, the
DAS1602 compatible registers are also accessible through the
indexed register set.
Description
ADC Burst Mode Enable Register. On power-up or reset the
ADC-burst mode is disabled. This register is only available
if FE bit is true (DAS1602 Functions are enabled). Writing a
0x00 to this register disables ADC-burst mode. Writing 0x40
(6410) to this register enables ADC-burst mode.
Register Layout
<b>Offset=0x405, RB=X. Also located at: Index=0x41, Byte 0,
RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
ABME7   ABME6   ABME5   ABME4   ABME3   ABME2   ABME1   ABME0
</table>
Bit Definitions
\ \ 
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ------------------------------------------------------
ABME[7:0]   w           0x00      ADC-Burst Mode Enable Register. On power-up or reset
                                   the ADC-burst mode is disabled. This register is only
                                   available if FE bit is true (DAS1602 Functions are
                                   enabled). Writing a 0x00 to this register disables
                                   ADC-burst mode. Writing 0x40 (6410) to this register
                                   enables ADC-burst mode.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Burst Function Enable
<title Burst Function Enable  (Offset=1030; Index=66\, RB='1')>

Summary
ADC Function Enable Register. DAS1602 Compatible
Configuration Register. In 10-bit address decode mode, the
DAS1602 compatible registers are also accessible through the
indexed register set.
Description
DAS1602 Function Enable Register. On power-up or reset the
DAS1602 functions are disabled. Writing 0x40 (64<sub>10</sub>)
to this register enables the DAS1602 functions. Writing a
0x00 to this register disables DAS1602 functions.
Register Layout
<b>Offset=0x406, RB=X. Also located at: Index=0x42, Byte 0,
RB='1'.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
FE7   FE6   FE5   FE4   FE3   FE2   FE1   FE0
</table>
Bit Definitions
\ \ 
<table>
NAME      DIRECTION   DEFAULT              \DESCRIPTION
========  ==========  ===================  ---------------------------------------------
FE[7:0]   w           0x00<p />(function   DAS1602 Function Enable Register. On
                       disabled)            power-up or reset the DAS1602 functions
                                            are disabled. Writing 0x40 (64<sub>10</sub>)
                                            to this register enables the DAS1602
                                            functions. Writing a 0x00 to this
                                            register disables DAS1602 functions.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Extended Status
<title Extended Status  (Offset=1031; Index=67\, RB='1')>

Summary
ADC Extended Status Register. DAS1602 Compatible
Configuration Register. In 10-bit address decode mode, the
DAS1602 compatible registers are also accessible through the
indexed register set.
Description
\ \ 
Register Layout
<b>Offset=0x407, RB=X. Also located at: Index=0x43, Byte 0,
RB='1'.</b>
<table>
D7   D6     D5   D4   D3   D2   D1   D0
===  =====  ===  ===  ===  ===  ===  ====
0    ABME   FE   CD   0    0    WS   CLK
</table>
Bit Definitions
<table>
NAME   DIRECTION   DEFAULT              \DESCRIPTION
=====  ==========  ===================  ----------------------------------------------
ABME   r           0                    ADC-Burst Mode Enabled:<p />0 = disabled
                                         (default)<p />1 = enabled<p />
FE     r           0                    DAS1602 Function Enabled:<p />0 = disabled,
                                         DAS16jr/16 functionality only (default)<p />1
                                         = enabled<p />
CD     r           1                    Conversions Allowed:<p />0 = ADC Conversions
                                         Disabled<p />1 = ADC Conversions Allowed
                                         (default)<p />
WS     r           0                    Wait States. This bit is always zero for no
                                         wait states.
CLK    r           J6.1MHz<p />Jumper   Counter/Timer clock source:<p />0 = 1MHz
                                         selected (based on jumper 1MHz)<p />1 = 10MHz
                                         selected<p />
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@General Configuration
<title General Configuration (Index=0\, RB='1')>

Summary
General Configuration Register
Description
\ \ 
Register Layout
<b>Index=0x00, Byte 0. RB='1'.</b>
<table>
D7     D6    D5     D4    D3    D2    D1    D0
=====  ====  =====  ====  ====  ====  ====  ====
AIID   CLK   DMAJ   M4J   M3J   M2J   M1J   M0J
</table>
Bit Definitions
<table>
NAME   DIRECTION   DEFAULT   \DESCRIPTION
=====  ==========  ========  -----------------------------------------------------
AIID   rw          0         Auto Index Increment Disable. Index register is
                              automatically incremented by the size (byte/word) of
                              the data that is read or written.<p />0 = Auto index
                              increment enabled (default)<p />1 = Auto index
                              increment disabled
CLKJ   r           J6.1MHZ   Mode jumper 1MHZ state at connector J6.<p />0 =
                    jumper    Jumper is not installed<p />1 = Jumper is installed
DMAJ   r           J6.DMA    Mode jumper DMA state at connector J6.<p />0 =
                    jumper    Jumper is not installed<p />1 = Jumper is installed
M4J    r           J6.M4     Mode jumper M4 state at connector J6.<p />0 = Jumper
                    jumper    is not installed<p />1 = Jumper is installed
M3J    r           J6.M3     Mode jumper M3 state at connector J6.<p />0 = Jumper
                    jumper    is not installed<p />1 = Jumper is installed
M2J    r           J6.M2     Mode jumper M2 state at connector J6.<p />0 = Jumper
                    jumper    is not installed<p />1 = Jumper is installed
M1J    r           J6.M1     Mode jumper M1 state at connector J6.<p />0 = Jumper
                    jumper    is not installed<p />1 = Jumper is installed
M0J    r           J6.M0     Mode jumper M0 state at connector J6.<p />0 = Jumper
                    jumper    is not installed<p />1 = Jumper is installed
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Interrupt Threshold
<title Interrupt Threshold (Index=8\, RB='1')>

Summary
Interrupt Threshold Register
Description
When the number of events defined by the Interrupt Threshold
Source Counter Select (refer to the <link Interrupt Source Select>
Register) is reached, an output is generated which can
subsequently be used to generate an interrupt or be used to
cause an ADC-sample or ADC-burst, depending on
configurations.



It is possible for this counter to be used as a form of an
event pre-scalar for ADC-sampling or ADC-bursting or
interrupt generation.



One time: Interrupt_time_interval = ITH *
interrupt_count_source_time_interval.



Periodic: Interrupt_time_interval = ( ITH + 1 ) *
interrupt_count_source_time_interval.
Register Layout
<b>Index=0x08, Byte 0. Index=0x08, Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
ITH7   ITH6   ITH5   ITH4   ITH3   ITH2   ITH1   ITH0
</table>

<b>Index=0x09, Byte 1. Index=0x08, Word 0. RB='1'.</b>
<table>
D15     D14     D13     D12     D11     D10     D9     D8
======  ======  ======  ======  ======  ======  =====  =====
ITH15   ITH14   ITH13   ITH12   ITH11   ITH10   ITH9   ITH8
</table>

<b>Index=0x0A, Byte 2. Index=0x0A, Word 1. RB='1'.</b>
<table>
D23     D22     D21     D20     D19     D18     D17     D16
======  ======  ======  ======  ======  ======  ======  ======
ITH23   ITH22   ITH21   ITH20   ITH19   ITH18   ITH17   ITH16
</table>

<b>Index=0x0B, Byte 3. Index=0x0A, Word 1. RB='1'.</b>
<table>
D31     D30     D29     D28     D27     D26     D25     D24
======  ======  ======  ======  ======  ======  ======  ======
ITH31   ITH30   ITH29   ITH28   ITH27   ITH26   ITH25   ITH24
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT      \DESCRIPTION
==========  ==========  ===========  ----------------------------------
ITH[31:0]   rw          0x00000000   Interrupt Threshold Register. See
                                      \Description section for further
                                      information.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Digital Output Configuration
<title Digital Output Configuration (Index=12\, RB='1')>

Summary
Digital Output Configuration Register
Description
The Digital Output Configuration Register sets the polarity
on the digital outputs and the SSH pin.
Register Layout
<b>Index=0x0C, Byte 0. Index=0x0C, Word 0. RB='1'.</b>
<table>
D7     D6   D5      D4      D3     D2     D1     D0
=====  ===  ======  ======  =====  =====  =====  =====
SSHP   X    CT0OP   CT2OP   DOP3   DOP2   DOP1   DOP0
</table>

<b>Index=0x0D, Byte 1. Index=0x0C, Word 0. RB='1'.</b>
<table>
D15        D14        D13        D12        D11        D10        D9         D8
=========  =========  =========  =========  =========  =========  =========  =========
DO3_MAP1   DO3_MAP0   DO2_MAP1   DO2_MAP0   DO1_MAP1   DO1_MAP0   DO0_MAP1   DO0_MAP0
</table>
Bit Definitions
<table>
NAME           DIRECTION   DEFAULT   \DESCRIPTION
=============  ==========  ========  -----------------------------------------------------------------------------------------------------------
DO3_MAP[1:0]   rw          00        Digital Output DOUT3 (J7.5) Mapping. NOTE: This
                                      selection occurs before polarity control.<p />00 =
                                      Digital Output Register.DOUT3. This is the default <link Digital Outputs, Digital Output Register>.<p />01
                                      = unused<p />10 = unused<p />11 = unused
DO2_MAP[1:0]   rw          00        Digital Output DOUT2 (J7.6) Mapping. NOTE: This
                                      selection occurs before polarity control.<p />00 =
                                      Digital Output Register.DOUT2. This is the default <link Digital Outputs, Digital Output Register>.<p />01
                                      = SPI Module Chip Select Output (High Voltage or High
                                      Gain Buffer Board)<p />10 = unused<p />11 = unused
DO1_MAP[1:0]   rw          00        Digital Output DOUT1 (J7.7) Mapping. NOTE: This
                                      selection occurs before polarity control.<p />00 =
                                      Digital Output Register.DOUT1. This is the default <link Digital Outputs, Digital Output Register>.<p />01
                                      = SPI Module Clock Output (High Voltage or High Gain
                                      Buffer Board)<p />10 = unused<p />11 = unused
DO0_MAP[1:0]   rw          00        Digital Output DOUT0 (J7.8) Mapping. NOTE: This
                                      selection occurs before polarity control.<p />00 =
                                      Digital Output Register.DOUT0. This is the default <link Digital Outputs, Digital Output Register>.<p />01
                                      = SPI Module Data Output (High Voltage or High Gain
                                      Buffer Board)<p />10 = unused<p />11 = unused
SSHP           rw          0         SSH (J7.14) Polarity<p />0 = Non-inverting (default)<p />1
                                      = Inverted
CT0OP          rw          0         CT_OUT0 (J7.3) Polarity<p />0 = Non-inverting (default)<p />1
                                      = Inverted
CT2OP          rw          0         CT_OUT2 (J7.2) Polarity<p />0 = Non-inverting (default)<p />1
                                      = Inverted
DOP3           rw          0         Digital Output DOUT3 (J7.5) Polarity<p />0 =
                                      Non-inverting (default)<p />1 = Inverted
DOP2           rw          0         Digital Output DOUT2 (J7.6) Polarity<p />0 =
                                      Non-inverting (default)<p />1 = Inverted
DOP1           rw          0         Digital Output DOUT1 (J7.7) Polarity<p />0 =
                                      Non-inverting (default)<p />1 = Inverted
DOP0           rw          0         Digital Output DOUT0 (J7.8) Polarity<p />0 =
                                      Non-inverting (default)<p />1 = Inverted
X              \-          \-        Don't Care
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Digital Input Configuration
<title Digital Input Configuration (Index=14\, RB='1')>

Summary
Digital Input Register
Description
Sets the polarity and deglitch filters for the digital
\inputs.
Register Layout
<b>Index=0x0E, Byte 0. RB='1'.</b>
<table>
D7     D6      D5   D4   D3     D2     D1     D0
=====  ======  ===  ===  =====  =====  =====  =====
SDGF   SDI31   X    X    DIP3   DIP2   DIP1   DIP0
</table>
Bit Definitions
<table>
NAME    DIRECTION   DEFAULT   \DESCRIPTION
======  ==========  ========  ------------------------------------------------------------
SDGF    rw          0         \Short Deglitch Filter<p />0 = 200 nSec deglitch
                               (default)<p />1 = 100 nSec deglitch
X       \-          \-        Don't Care
SDI31   rw          0         Swap DIN1 and DIN3<p />0 = Classic mode. DIN1 wired to
                               J7.11 and DIN3 to J7.9 to support existing customers.<p />1
                               = Normal mode. DIN1 wired to J7.9 and DIN3 to J7.11.
DIP3    rw          0         DIN3 (J7.9) Polarity<p />0 = Non-inverting (default)<p />1
                               = Inverted
DIP2    rw          0         DIN2 (J7.10) Polarity<p />0 = Non-inverting (default)<p />1
                               = Inverted
DIP1    rw          0         DIN1 (J7.11) Polarity<p />0 = Non-inverting (default)<p />1
                               = Inverted
DIP0    rw          0         DIN0 (J7.12) Polarity<p />0 = Non-inverting (default)<p />1
                               = Inverted
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Trigger Configuration
<title Trigger Configuration (Index=16\, RB='1')>

Summary
Trigger Configuration Register
Description
Configures the trigger section for a variety of ADC data
collection start and stop situations.
Register Layout
\ \ 

<b>Index=0x10 Byte 0. Index=0x10 Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
ETS3   ETS2   ETS1   ETS0   STS3   STS2   STS1   STS0
</table>

<b>Index=0x11 Byte 1. Index=0x10 Word 0. RB='1'.</b>
<table>
D15   D14   D13    D12    D11    D10    D9     D8
====  ====  =====  =====  =====  =====  =====  =====
TEN   X     STM1   STM0   TSS3   TSS2   TSS1   TSS0
</table>
Bit Definitions
\ \ 
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -------------------------------------------------------------
X          \-          \-        Don't Care
TEN        rw          0         Trigger Enable<p />0 = disabled (default)<p />1 = enabled
STM[1:0]   rw          00        Start Trigger Mode.<p />00 = trigger source (default)<p />01
                                  = trigger followed by trigger delay<p />10 = trigger
                                  followed by sync followed by trigger delay<p />11 =
                                  Reserved
TSS[3:0]   rw          0000      Start Trigger Synchronization Source.<p />0000 = none
                                  (default)<p />0001 = writing 0x5A to the software strobe
                                  register<p />0010 = none<p />0011 = Analog Input
                                  \Sample/Frame Timer<p />0010 = none<p />0011 = none<p />0100
                                  = 8254 Counter 0 Output (CT_OUT0) rising-edge<p />0101 =
                                  8254 Counter 0 Output (CT_OUT0) falling-edge<p />0110 =
                                  8254 Counter 2 Output (CT_OUT2) rising-edge<p />0111 =
                                  8254 Counter 2 Output (CT_OUT2) falling-edge<p />1000 =
                                  DIN0 rising edge<p />1001 = DIN0 falling edge<p />1010 =
                                  DIN1 rising edge<p />1011 = DIN1 falling edge<p />1100 =
                                  DIN2 rising edge<p />1101 = DIN2 falling edge<p />1110 =
                                  DIN3 rising edge<p />1111 = DIN3 falling edge
ETS[3:0]   rw          0000      End/Stop Trigger Source<p />0000 = none (default)<p />0001
                                  = writing 0xAA to the software strobe register<p />0010 =
                                  Analog Input Frame Maximum<p />0011 = Analog Input
                                  \Sample/Frame Timer<p />0100 = 8254 Counter 0 Output
                                  (CT_OUT0) rising-edge<p />0101 = 8254 Counter 0 Output
                                  (CT_OUT0) falling-edge<p />0110 = 8254 Counter 2 Output
                                  (CT_OUT2) rising-edge<p />0111 = 8254 Counter 2 Output
                                  (CT_OUT2) falling-edge<p />1000 = DIN0 rising edge<p />1001
                                  = DIN0 falling edge<p />1010 = DIN1 rising edge<p />1011 =
                                  DIN1 falling edge<p />1100 = DIN2 rising edge<p />1101 =
                                  DIN2 falling edge<p />1110 = DIN3 rising edge<p />1111 =
                                  DIN3 falling edge
STS[3:0]   rw          0000      Start Trigger Source<p />0000 = none (default)<p />0001 =
                                  writing 0x55 to the software strobe register<p />0010 =
                                  none<p />0011 = Analog Input Sample/Frame Timer<p />0100 =
                                  8254 Counter 0 Output (CT_OUT0) rising-edge<p />0101 =
                                  8254 Counter 0 Output (CT_OUT0) falling-edge<p />0110 =
                                  8254 Counter 2 Output (CT_OUT2) rising-edge<p />0111 =
                                  8254 Counter 2 Output (CT_OUT2) falling-edge<p />1000 =
                                  DIN0 rising edge<p />1001 = DIN0 falling edge<p />1010 =
                                  DIN1 rising edge<p />1011 = DIN1 falling edge<p />1100 =
                                  DIN2 rising edge<p />1101 = DIN2 falling edge<p />1110 =
                                  DIN3 rising edge<p />1111 = DIN3 falling edge
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Trigger Start Delay
<title Trigger Start Delay (Index=20\, RB='1')>

Summary
Trigger Start Delay Register. Range is 0 to 107.37 Seconds in
steps of 25 nanoseconds.
Description
The actual delay interval is calculated as:



Delay_nanoseconds = 25 * TSD. Where 0 \<= TSD \<=
4,294.967.295. UINT32_MAX.





Thus, the trigger start delay is adjustable from 0 nSec to
107.37 Seconds.



Range: 0 to 107.37 Seconds.

Resolution: 25 nanoseconds.
Register Layout
<b>Index=0x14 Byte 0. Index=0x14 Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
TSD7   TSD6   TSD5   TSD4   TSD3   TSD2   TSD1   TSD0
</table>

<b>Index=0x15 Byte 1. Index=0x14 Word 0. RB='1'.</b>
<table>
D15     D14     D13     D12     D11     D10     D9     D8
======  ======  ======  ======  ======  ======  =====  =====
TSD15   TSD14   TSD13   TSD12   TSD11   TSD10   TSD9   TSD8
</table>

<b>Index=0x16 Byte 2. Index=0x16 Word 1. RB='1'.</b>
<table>
D23     D22     D21     D20     D19     D18     D17     D16
======  ======  ======  ======  ======  ======  ======  ======
TSD23   TSD22   TSD21   TSD20   TSD19   TSD18   TSD17   TSD16
</table>

<b>Index=0x17 Byte 3. Index=0x16 Word 1. RB='1'.</b>
<table>
D31     D30     D29     D28     D27     D26     D25     D24
======  ======  ======  ======  ======  ======  ======  ======
TSD31   TSD30   TSD29   TSD28   TSD27   TSD26   TSD25   TSD24
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT      \DESCRIPTION
==========  ==========  ===========  -------------
TSD[31:0]   rw          0x00000000   
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Analog Input General Configuration
<title Analog Input General Configuration (Index=32\, RB='1')>

Summary
Analog Input General Configuration Register
Description
The Analog Input General Configuration Register configures
the source of ADC-sampling or ADC-burst signalling (in legacy
terms it is the old ADC-triggering sources). Upon reset or
power up it defaults to legacy mode of operation.
Register Layout
<b>Index=0x20, Byte 0. Index=0x20, Word 0. RB='1'.</b>
<table>
D7         D6        D5        D4       D3      D2      D1      D0
=========  ========  ========  =======  ======  ======  ======  ======
MAVG_INV   SAIFTTS   SAIFCTS   nSGATE   AISS3   AISS2   AISS1   AISS0
</table>

<b>Index=0x21, Byte 1. Index=0x20, Word 0. RB='1'.</b>
<table>
D15   D14   D13   D12   D11   D10         D9                    D8
====  ====  ====  ====  ====  ==========  ====================  ====================
X     X     X     X     X     AI_ENCODE   AI_ENCODE_BEHAVIOR1   AI_ENCODE_BEHAVIOR0
</table>
Bit Definitions
\ \ 
<table>
NAME                 DIRECTION   DEFAULT   \DESCRIPTION
===================  ==========  ========  ---------------------------------------------------------------------------
X                    \-          \-        Don't Care
AI_ENCODE_BEHAVIOR   rx          00        Analog Input data encoding behavior.<p /><p />If
                                            AI_ENCODE='0' then straight binary and the following
                                            behavior:<p />X0 = Normal (legacy default). Polarity bit
                                            ignored. Most negative (0x0000) to most positive
                                            (0xFFFF).<p />X1 = Multiply by -1, but only if polarity
                                            bit for channel is set.<p />polarity = '1': Most
                                            negative (0xFFFF) to most positive (0x0000).<p />polarity
                                            = '0'. Most negative (0x0000) to most positive (0xFFFF).<p /><p />If
                                            AI_ENCODE='1' then two's complement encoding with the
                                            following behavior:<p />00 = Normal. Polarity bit
                                            ignored. Most negative (0x8000) to most postive
                                            (0x7FFF).<p />01 = Multiply by -1, but only if polarity
                                            bit for channel is set. (NOTE: 0x8000 value is
                                            suppressed.)<p />ai_polarity[channel] = '1': Most
                                            negative (0x7FFF) to most positive (0x8001).<p />ai_polarity[channel]
                                            = '0'. Most negative (0x8001) to most positive (0x7FFF).<p />1X
                                            = Absolute value.<p />ai_polarity[channel] = '1': Range:
                                            most negative (0x8001) to most positive (0x0000).<p />ai_polarity[channel]
                                            = '0'. Range: most negative (0x0000) to most positive
                                            (0x7FFF).
AI_ENCODE            rw          0         Analog Input data encoding or formatting. Straight
                                            binary or twos complement for all analog input values.<p />0
                                            = Straight Binary (default). Most negative (0x0000) to
                                            most positive (0xFFFF).<p />1 = Twos Complement. Most
                                            negative (0x8000) to most postive (0x7FFF).
MAVG_INV             rw          0         Invert the state of the moving average filter jumper
                                            (M4). This allows one to enable/disable moving average
                                            filter through software.<p />0 = non-inverted or normal
                                            operation (default)<p />1 = invert state of jumper to
                                            enable/disable moving average filter function. Observe
                                            the state at <link General Configuration> Register. If
                                            the M4J bit is set in the General Configuration
                                            Register, then the moving average filter is enabled.
SAIFTTS              rw          0         Sync Analog Input Frame Timer to Trigger Start. If set,
                                            then also moves the first sample to just after the
                                            trigger start rather than sampling at any time (i.e. 0
                                            to 1 sample interval) after the trigger start.<p />0 =
                                            disabled (default). Timing between samples remains fixed
                                            regardless of point of trigger.<p />1 = Clear Analog
                                            \Input Frame Timer upon Trigger Start. Sampling begins
                                            just after the trigger-start, thus synchronizing the
                                            sampling to the trigger start.
SAIFCTS              rw          0         Sync Analog Input Frame Counter to Trigger Start. This
                                            can be used to synchronize sample or frame counting to a
                                            trigger start.<p />0 = disabled (default).<p />1 = Clear
                                            Analog Input Frame Counter upon Trigger Start
nSGATE               rw          0         Sampling Gate<p />0 = Ignore triggering subsystem
                                            (default)<p />1 = Use triggering subsystem for
                                            ADC-sampling
AISS[3:0]            rw          0000      Analog Input Sampling Sources. This select the signal
                                            that is used to generate ADC-samples or ADC-bursts.<p />0000
                                            = use ALSS[1:0] configuration (default, legacy
                                            ADC-sampling/-burst source)<p />0001 = Analog Input
                                            \Sample/Frame Timer.<p />0010 = Interrupt Threshold
                                            Counter<p />0011 = none<p />0100 = none<p />0101 = none<p />0110
                                            = none<p />0111 = none<p />1000 = DIN0 rising edge<p />1001
                                            = DIN0 falling edge<p />1010 = DIN1 rising edge<p />1011
                                            = DIN1 falling edge<p />1100 = DIN2 rising edge<p />1101
                                            = DIN2 falling edge<p />1110 = DIN3 rising edge<p />1111
                                            = DIN3 falling edge<p />
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Analog Input Frame Counter
<title Analog Input Frame Counter (Index=48\, RB='1')>

Summary
Analog Input Frame Count Register.
Description
The Analog Input Frame Count Register indicates the actual
number of samples (when ADC set for non-ADC-bursting mode of
operation) or the number of frames (when ADC set for
ADC-burst mode of operation).
Register Layout
\ \ 

<b>Index=0x30, Byte 0. Index=0x30, Word 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
AIFC7   AIFC6   AIFC5   AIFC4   AIFC3   AIFC2   AIFC1   AIFC0
</table>

<b>Index=0x31, Byte 1. Index=0x30, Word 0. RB='1'.</b>
<table>
D15      D14      D13      D12      D11      D10      D9      D8
=======  =======  =======  =======  =======  =======  ======  ======
AIFC15   AIFC14   AIFC13   AIFC12   AIFC11   AIFC10   AIFC9   AIFC8
</table>

<b>Index=0x32, Byte 2. Index=0x32, Word 1. RB='1'.</b>
<table>
D23      D22      D21      D20      D19      D18      D17      D16
=======  =======  =======  =======  =======  =======  =======  =======
AIFC23   AIFC22   AIFC21   AIFC20   AIFC19   AIFC18   AIFC17   AIFC16
</table>

<b>Index=0x33, Byte 3. Index=0x32, Word 1. RB='1'.</b>
<table>
D31      D30      D29      D28      D27      D26      D25      D24
=======  =======  =======  =======  =======  =======  =======  =======
AIFC31   AIFC30   AIFC29   AIFC28   AIFC27   AIFC26   AIFC25   AIFC24
</table>
Bit Definitions
\ \ 
<table>
NAME   DIRECTION   DEFAULT      \DESCRIPTION
=====  ==========  ===========  -------------------------
AIFC   r           0x00000000   Analog Input Frame Count
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Memory Configuration
<title Memory Configuration (Index=240\, RB='1')>

Summary
Memory Configuration Register
Description
\ \ 
Register Layout
\ \ 

<b>Index=0xF0, Byte 0. RB='1'. Write Only.</b>
<table>
D7   D6   D5   D4   D3     D2     D1     D0
===  ===  ===  ===  =====  =====  =====  =====
X    X    X    X    MIK3   MIK2   MIK1   MIK0
</table>

<b>Index=0xF0, Byte 0. RB='1'. Read Only.</b>
<table>
D7      D6     D5     D4     D3   D2   D1   D0
======  =====  =====  =====  ===  ===  ===  ===
MOPEN   MKS2   MKS1   MKS0   X    X    X    X
</table>
Bit Definitions
\ \ 
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -------------------------------------------------------------
X          \-          \-        Don't Care
MIK[3:0]   w           \-        Memory Input Key. The purpose of key entry is to prevent
                                  software from writing into the memory during normal
                                  operation.<p /><p />Sequence to open/unlock memory
                                  access:<p />1111 --\> 0101 --\> 1101 F 5 D<p /><p />Sequence
                                  to close/lock memory access:<p />0011 --\> 1011 --\>
                                  1010 3 B A<p /><p />Writing the sequence 0xFX, 0x5X,
                                  0xDX will open the memory for read/write access. Writing
                                  the sequence 0x3X, 0xBX, 0xAX will close the memory for
                                  read/write access. 
MOPEN      r           0         Memory Unlocked<p />0 = Memory access closed<p />1 =
                                  Memory access open
MKS[2:0]   r           000       Memory Key State. State of the key decode state machine.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Memory Data
<title Memory Data (Index=242\, RB='1')>

Summary
Memory Data Register
Description
\ \ 
Register Layout
<b>Index=0xF2, Byte 0. RB='1'.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
MD7   MD6   MD5   MD4   MD3   MD2   MD1   MD0
</table>
Bit Definitions
<table>
NAME      DIRECTION   DEFAULT   \DESCRIPTION
========  ==========  ========  -------------
MD[7:0]   rw          \-        
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Scratch Pad
<title Scratch Pad (Index=248\, RB='1')>

Summary
Scratch Pad Register
Description
Can be used for temporarily storing a previous state. Also
used to verify ISA bus interface.
Register Layout
<b>Index=0xF8, Byte 0. Index=0xF8 Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
SCR7   SCR6   SCR5   SCR4   SCR3   SCR2   SCR1   SCR0
</table>

<b>Index=0xF9, Byte 1. Index=0xF8 Word 0. RB='1'.</b>
<table>
D15     D14     D13     D12     D11     D10     D9     D8
======  ======  ======  ======  ======  ======  =====  =====
SCR15   SCR14   SCR13   SCR12   SCR11   SCR10   SCR9   SCR8
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ---------------------
SCR[15:0]   rw          0x0000    Scratch Pad Register
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Board ID
<title Board ID (Index=250\, RB='1')>

Summary
Board Identification Register
Description
\ \ 
Register Layout
\ \ 

<b>Index=0xFA, Byte 0. Index=0xFA Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
BID7   BID6   BID5   BID4   BID3   BID2   BID1   BID0
</table>

<b>Index=0xFB, Byte 1. Index=0xFA Word 0. RB='1'.</b>
<table>
D15     D14     D13     D12     D11     D10     D9     D8
======  ======  ======  ======  ======  ======  =====  =====
BID15   BID14   BID13   BID12   BID11   BID10   BID9   BID8
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  --------------------------------------------------
BID[15:0]   r           \-        Board ID = 0x1008. Revision 080214 (14FEB08) and
                                   Revision 080407H (07APR08)<p />Board ID = 0x1009.
                                   Revision 090115 (15JAN09)<p />Board ID = 0x100A.
                                   Revision 111021 (30OCT11)
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Board Serial Number
<title Board Serial Number (Index=252\, RB='1')>

Summary
Board Serial Number
Description
\ \ 
Register Layout
\ \ 

<b>Index=0xFC, Byte 0. Index=0xFC Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
BSN7   BSN6   BSN5   BSN4   BSN3   BSN2   BSN1   BSN0
</table>

<b>Index=0xFD, Byte 1. Index=0xFC Word 0. RB='1'.</b>
<table>
D15     D14     D13     D12     D11     D10     D9     D8
======  ======  ======  ======  ======  ======  =====  =====
BSN15   BSN14   BSN13   BSN12   BSN11   BSN10   BSN9   BSN8
</table>

<b>Index=0xFE, Byte 2. Index=0xFE Word 1. RB='1'.</b>
<table>
D23     D22     D21     D20     D19     D18     D17     D16
======  ======  ======  ======  ======  ======  ======  ======
BSN23   BSN22   BSN21   BSN20   BSN19   BSN18   BSN17   BSN16
</table>

<b>Index=0xFF, Byte 3. Index=0xFE Word 1. RB='1'.</b>
<table>
D31     D30     D29     D28     D27     D26     D25     D24
======  ======  ======  ======  ======  ======  ======  ======
BSN31   BSN30   BSN29   BSN28   BSN27   BSN26   BSN25   BSN24
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  --------------------
BSN[31:0]   r           \-        Board Serial Number
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Analog Input Burst Timer
<title Analog Input Burst Timer (Index=40\, RB='1')>

Summary
Analog Input Burst Timer. Adjusts timing between samples
during ADC-burst mode.
Description
Adjusts the time between ADC-samples in a ADC-Burst mode
(i.e. the intra-sample time). In legacy mode this is 5
microseconds.



The actual time interval is calculated as:



ai_time_intra_sample_ns = AIBT * ( 25 nSec ) + ( 5000 nSec ).

Where 0 \<= AIBT \<= 2147483648.



Thus, the ADC burst time (or intra-sample time) is adjustable
from 5 microseconds to 53.68 seconds in 25 nanosecond steps.



Range: 5 uSec to 53.68 Seconds.

Resolution: 25 nanoseconds.



How to determine optimal ADC-Burst timing value? Since the
ADC input is multiplexed, the speed limitation is the overall
RC time constant or settling time to achieve 16-bit
resolution. The equation below describes how to determine
minimum intra-burst timing.

* Settling Time in ADC-Burst Mode: *
Some background. A burst, once started will sample from <i>first_channel</i>
to<i> last_channel</i> in 5uS intervals in legacy mode. So,
eight channels will take 40uS to complete. The trigger for
the next burst can actually come early (i.e. before the last
\sample completes) and it should start the next burst
immediately as if one is continuously sampling at 5uS/sample.



As with all multiplexed front-ends, it is desirable to keep
the source impedance of the signals driving each of the
\inputs as low as possible to minimize cross-talk (i.e. more
specifically settling time). Differential inputs have 47pF
\input capacitance and single ended inputs have 27pF input
capacitance (we tend to lean on the high side or worse case).
So, to keep

signal settle times to less than 1 LSB requires:



Rmax \<= ( settle_time ) / [ Cin * bits_resolution * ln(2) ]

\<= 4uS / [ 47pF * 16 * ln(2) ]

\<= 7674 ohms.



You will want to keep the devices driving the %CARD_NAME%
\inputs with source impedance of less than 8K ohms when
operating in Burst mode at its maximum speed and assuming no
other source of input capacitance (short cables, for
\example).



This equation above comes from:

V(t) = Vf + ( Vi - Vf ) exp(-t / RC )

in which you go from maximum to minimum input voltages

(i.e. +10V to -10V and settle to within 1 LSB).



\Note that in the above calculation we set the settle time to
within 1 LSB over 4uS time frame; we could go as far as 5uS,
but 4uS gives us a little extra margin.

* Increasing Settle Time in ADC-Burst Mode: *
To increase settle time, you have to set the Analog Input
Burst Timer to a non-zero value. Here is an example with a
sensor with a source impedance of 10K ohms.



Settle_time = Rin * [ Cin * bits_resolution * ln(2) ]

= 10K * [ 300pF * 16 * ln(2) ] = 11.09 * Rin * Cin

= 34uS



Thus, the Analog Input Burst Timer Register should be set to:

AIBT = [ ( 34 uSec ) - ( 5 uSec ) ] / 25 nSec = 1160 or
0x00000488.
Register Layout
\ \ 

<b>Index=0x28, Byte 0. Index=0x28, Word 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
AIBT7   AIBT6   AIBT5   AIBT4   AIBT3   AIBT2   AIBT1   AIBT0
</table>

<b>Index=0x29, Byte 1. Index=0x28, Word 0. RB='1'.</b>
<table>
D15      D14      D13      D12      D11      D10      D9      D8
=======  =======  =======  =======  =======  =======  ======  ======
AIBT15   AIBT14   AIBT13   AIBT12   AIBT11   AIBT10   AIBT9   AIBT8
</table>

<b>Index=0x2A, Byte 2. Index=0x2A, Word 1. RB='1'.</b>
<table>
D23      D22      D21      D20      D19      D18      D17      D16
=======  =======  =======  =======  =======  =======  =======  =======
AIBT23   AIBT22   AIBT21   AIBT20   AIBT19   AIBT18   AIBT17   AIBT16
</table>

<b>Index=0x2B, Byte 3. Index=0x2A, Word 1. RB='1'.</b>
<table>
D31      D30      D29      D28      D27      D26      D25      D24
=======  =======  =======  =======  =======  =======  =======  =======
AIBT31   AIBT30   AIBT29   AIBT28   AIBT27   AIBT26   AIBT25   AIBT24
</table>
Bit Definitions
\ \ 
<table>
NAME         DIRECTION   DEFAULT      \DESCRIPTION
===========  ==========  ===========  -------------
AIBT[31:0]   rw          0x00000000   
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Memory Address
<title Memory Address (Index=244\, RB='1')>

Summary
Memory Address Register
Description
When memory is enabled (MOPEN='1'), it is possible to read
and write directly to %CARD_NAME% memory. The primary purpose of
the direct memory access is for purposes of testing and
verifying memory operation.

<table>
DEVICE   START ADDRESS       END ADDRESS
=======  ==================  ==================
U14      <c>0x00000000</c>   <c>0x0007FFFF</c>
U33      <c>0x00080000</c>   <c>0x000FFFFF</c>
U13      <c>0x00100000</c>   <c>0x0017FFFF</c>
U34      <c>0x00180000</c>   <c>0x0017FFFF</c>
</table>
Register Layout
\ \ 

<b>Index=0xF4 Byte 0. Index=0xF4 Word 0. RB='1'.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
MA7   MA6   MA5   MA4   MA3   MA2   MA1   MA0
</table>

<b>Index=0xF5 Byte 1. Index=0xF4 Word 0. RB='1'.</b>
<table>
D15    D14    D13    D12    D11    D10    D9    D8
=====  =====  =====  =====  =====  =====  ====  ====
MA15   MA14   MA13   MA12   MA11   MA10   MA9   MA8
</table>

<b>Index=0xF6 Byte 2. Index=0xF6 Word 1. RB='1'.</b>
<table>
D23    D22    D21    D20    D19    D18    D17    D16
=====  =====  =====  =====  =====  =====  =====  =====
MA23   MA22   MA21   MA20   MA19   MA18   MA17   MA16
</table>

<b>Index=0xF7 Byte 3. Index=0xF6 Word 1. RB='1'.</b>
<table>
D31    D30    D29    D28    D27    D26    D25    D24
=====  =====  =====  =====  =====  =====  =====  =====
MA31   MA30   MA29   MA28   MA27   MA26   MA25   MA24
</table>
Bit Definitions
\ \ 
<table>
NAME       DIRECTION   DEFAULT      \DESCRIPTION
=========  ==========  ===========  ---------------
MA[31:0]   rw          0x00000000   Memory Address
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Analog Input Frame Maximum
<title Analog Input Frame Maximum (Index=44\, RB='1')>

Summary
Analog Input Frame Maximum Register. Maximum Frame range is 0
to 2,147,483,648 Frames.
Description
When the value of the Analog Input Frame Counter reaches the
value in the Analog Input Frame Maximum Register, and output
is generated which can be used to generate such things as
interrupts, trigger-stops, etc.



Frame Count Maximum Range: 1 \<= AIFM \<= 2147483648.



Range: 0 to 2147483648 Frames.

Resolution: 1 Frame.



Counting every ADC-sample at 5 microsecond sample rate, the
maximum can be set to just under 3 hours.

Counting every ADC-Burst at 50uSec/ADC-Burst (20KHz), the
maximum can be set to just under 29 hours.
Register Layout
\ \ 

<b>Index=0x2C, Byte 0. Index=0x2C, Word 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
AIFM7   AIFM6   AIFM5   AIFM4   AIFM3   AIFM2   AIFM1   AIFM0
</table>

<b>Index=0x2D, Byte 1. Index=0x2C, Word 0. RB='1'.</b>
<table>
D15      D14      D13      D12      D11      D10      D9      D8
=======  =======  =======  =======  =======  =======  ======  ======
AIFM15   AIFM14   AIFM13   AIFM12   AIFM11   AIFM10   AIFM9   AIFM8
</table>

<b>Index=0x2E, Byte 2. Index=0x2E, Word 1. RB='1'.</b>
<table>
D23      D22      D21      D20      D19      D18      D17      D16
=======  =======  =======  =======  =======  =======  =======  =======
AIFM23   AIFM22   AIFM21   AIFM20   AIFM19   AIFM18   AIFM17   AIFM16
</table>

<b>Index=0x2F, Byte 3. Index=0x2E, Word 1. RB='1'.</b>
<table>
D31      D30      D29      D28      D27      D26      D25      D24
=======  =======  =======  =======  =======  =======  =======  =======
AIFM31   AIFM30   AIFM29   AIFM28   AIFM27   AIFM26   AIFM25   AIFM24
</table>
Bit Definitions
\ \ 
<table>
NAME         DIRECTION   DEFAULT      \DESCRIPTION
===========  ==========  ===========  ---------------------------
AIFM[31:0]   rw          0x00000000   Analog Input Frame Maximum
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>


@@Software Strobe
<title Software Strobe (Offset=0)>

Summary
Software Strobe Register. Expanded version of the ADC
Software Trigger Register.
Description
if triggering is disabled (TEN='0') then any value written to
the Software Strobe Register will cause a ADC-sample or
ADC-burst can occur depending on configuration.



if triggering is enabled (TEN='1') then specific values
written to the Software Stobe Register will cause either an
ADC-sample or ADC-burst or trigger signalling as shown below.

<table>
DATA VALUE WRITTEN    TEN   \DESCRIPTION
--------------------  ----  -----------------------------------------
0xXX (Don't care)     0     Software controlled ADC-Sample or
                             ADC-Burst
0x55                  1     Software generated trigger start
0xAA                  1     Software generated trigger end (or stop)
0x5A                  1     Software generated trigger sync
Any value not equal   1     Software controlled ADC-Sample or
 to 0x55 or 0xAA or          ADC-Burst
 0x5A                        
</table>
Register Layout
<b>Offset = 0.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
SSR7   SSR6   SSR5   SSR4   SSR3   SSR2   SSR1   SSR0
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  -------------------------
SSR[7:0]   w           \-        Software Strobe Register
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Analog Input Frame Timer
<title Analog Input Frame Timer (Index=36\, RB='1')>

Summary
Analog Input Frame Timer Register. Range is 5 uSec to 53.68
Seconds in steps of 25 nanoseconds.
Description
The actual time interval is calculated as:



ai_time_frame_ns = ( AIFT + 1 ) * ( 25 nSec ).

Where 0 \<= AIFT \<= 2147483648.



Anything below 5 uSec will be limited by the intra-sample
timing which is limited to 5 uSec at a minimum.

Thus, the ADC frame time is adjustable from 5 microseconds to
53.68 seconds in 25 nanosecond steps.



Range: 5 uSec to 53.68 Seconds.

Resolution: 25 nanoseconds.
Register Layout
\ \ 

<b>Index=0x24 Byte 0. Index=0x24 Word 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
AIFT7   AIFT6   AIFT5   AIFT4   AIFT3   AIFT2   AIFT1   AIFT0
</table>

<b>Index=0x25 Byte 1. Index=0x24 Word 0. RB='1'.</b>
<table>
D15      D14      D13      D12      D11      D10      D9      D8
=======  =======  =======  =======  =======  =======  ======  ======
AIFT15   AIFT14   AIFT13   AIFT12   AIFT11   AIFT10   AIFT9   AIFT8
</table>

<b>Index=0x26 Byte 2. Index=0x26 Word 1. RB='1'.</b>
<table>
D23      D22      D21      D20      D19      D18      D17      D16
=======  =======  =======  =======  =======  =======  =======  =======
AIFT23   AIFT22   AIFT21   AIFT20   AIFT19   AIFT18   AIFT17   AIFT16
</table>

<b>Index=0x27 Byte 3. Index=0x26 Word 1. RB='1'.</b>
<table>
D31      D30      D29      D28      D27      D26      D25      D24
=======  =======  =======  =======  =======  =======  =======  =======
AIFT31   AIFT30   AIFT29   AIFT28   AIFT27   AIFT26   AIFT25   AIFT24
</table>
Bit Definitions
<table>
NAME         DIRECTION   DEFAULT      \DESCRIPTION
===========  ==========  ===========  -------------
AIFT[31:0]   rw          0x00000000   
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Operating Systems
\ \ 


@@FIFO Data Available
<title FIFO Data Available (Index=224\, RB='1')>

Summary
FIFO Data Available Register
Description
The number of 16-bit words in the FIFO or buffer.
Register Layout
\ \ 

<b>Index=0xE0, Byte 0. Index=0xE0, Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
FDA7   FDA6   FDA5   FDA4   FDA3   FDA2   FDA1   FDA0
</table>

<b>Index=0xE1, Byte 1. Index=0xE0, Word 0. RB='1'.</b>
<table>
D15     D14     D13     D12     D11     D10     D9     D8
======  ======  ======  ======  ======  ======  =====  =====
FDA15   FDA14   FDA13   FDA12   FDA11   FDA10   FDA9   FDA8
</table>

<b>Index=0xE2, Byte 2. Index=0xE2, Word 1. RB='1'.</b>
<table>
D23     D22     D21     D20     D19     D18     D17     D16
======  ======  ======  ======  ======  ======  ======  ======
FDA23   FDA22   FDA21   FDA20   FDA19   FDA18   FDA17   FDA16
</table>

<b>Index=0xE3, Byte 3. Index=0xE2, Word 1. RB='1'.</b>
<table>
D31     D30     D29     D28     D27     D26     D25     D24
======  ======  ======  ======  ======  ======  ======  ======
FDA31   FDA30   FDA29   FDA28   FDA27   FDA26   FDA25   FDA24
</table>
Bit Definitions
\ \ 
<table>
NAME   DIRECTION   DEFAULT      \DESCRIPTION
=====  ==========  ===========  --------------------------------------------
FDA    r           0x00000000   FIFO Data Available. Number of analog input
                                 samples that remain in the FIFO.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@ESD Caution
Summary
<align center>
<image caution>



</align>
A discharge of static electricity from your hands can
seriously damage certain electrical components on any circuit
board. Before handling any board, discharge static
electricity from yourself by touching a grounded conductor
such as your computer chassis (your computer must be turned
off). Whenever you handle a board, hold it by the edges and
avoid touching any board components or cable connectors.

@@ADC-Sample
Summary
Analog Input sample or data from an individual analog input
channel.

@@ADC-Burst
Summary
A group of analog input samples defined by the number of
channels for a burst operation. When an ADC-burst is started,
the timing between samples is controlled by the <link Analog Input Burst Timer>
or in classic mode it is defined strictly as 5 microseconds.

@@Interrupt Source Select
<title Interrupt Source Select (Index=2\, RB='1')>

Summary
Interrupt Source Select Register
Description
\ \ 
Register Layout
<b>Index=0x02, Byte 0, Word 0. RB='1'.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
ISB3   ISB2   ISB1   ISB0   ISA3   ISA2   ISA1   ISA0
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  ------------------------------------------------------------------
ISB[3:0]   rw          0000      Interrupt Source B. Sets the ISB bit in the ADC Status
                                  Register when ISSBE=’1’.<p />0000 = none (default)<p />0001
                                  = Reserved<p />0010 = <link Interrupt Threshold> Counter<p />0011
                                  = <link Analog Input Frame Maximum><p />0100 = Trigger
                                  Start and transition to active trigger state<p />0101 =
                                  Trigger Stop and transition to inactive trigger state<p />0110
                                  = none<p />0111 = none<p />1000 = DIN0 rising edge<p />1001
                                  = DIN0 falling edge<p />1010 = DIN1 rising edge<p />1011 =
                                  DIN1 falling edge<p />1100 = DIN2 rising edge<p />1101 =
                                  DIN2 falling edge<p />1110 = DIN3 rising edge<p />1111 =
                                  DIN3 falling edge
ISA[3:0]   rw          0000      Interrupt Source A. Sets the ISA bit in the ADC Status
                                  Register when ISSBE=’1’.<p />0000 = none (default)<p />0001
                                  = Reserved<p />0010 = <link Interrupt Threshold> Counter<p />0011
                                  = <link Analog Input Frame Maximum><p />0100 = Trigger
                                  Start and transition to active trigger state<p />0101 =
                                  Trigger Stop and transition to inactive trigger state<p />0110
                                  = none<p />0111 = none<p />1000 = DIN0 rising edge<p />1001
                                  = DIN0 falling edge<p />1010 = DIN1 rising edge<p />1011 =
                                  DIN1 falling edge<p />1100 = DIN2 rising edge<p />1101 =
                                  DIN2 falling edge<p />1110 = DIN3 rising edge<p />1111 =
                                  DIN3 falling edge
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Interrupt Configuration
<title Interrupt Configuration (Index=4\, RB='1')>

Summary
Interrupt Source Select Register
Description
\ \ 
Register Layout
\ \ 

<b>Index=0x04, Byte 0, Word 0. RB='1'.</b>
<table>
D7   D6   D5   D4   D3       D2       D1       D0
===  ===  ===  ===  =======  =======  =======  =======
X    X    X    X    FIBLK3   FIBLK2   FIBLK1   FIBLK0
</table>

<b>Index=0x05, Byte 1, Word 0. RB='1'.</b>
<table>
D15   D14     D13       D12    D11    D10    D9     D8
====  ======  ========  =====  =====  =====  =====  =====
EIS   ISSBE   nINT_FF   SITT   ITS3   ITS2   ITS1   ITS0
</table>
Bit Definitions
<table>
NAME         DIRECTION   DEFAULT   \DESCRIPTION
===========  ==========  ========  -----------------------------------------------------------------------
EIS          rw          0         Enhanced Interrupt Selection<p />0 = Normal interrupt
                                    selection in <link ADC Control, ADC control register>
                                    (default)<p />1 = Enhanced interrupt selection in ADC
                                    control register
ISSBE        rw          0         Interrupt Source Status Bank Enable<p />0 = ADC channel
                                    mapped to <link ADC Status, ADC Status Register> (default)<p />1
                                    = Interrupt Source Status mapped to lower nibble of ADC
                                    Status Register
nINT_FF      rw          0         Interrupt Flip-Flop Disable. Classic DMA and FIFO interrupt
                                    generation is independent of this setting.<p />0 = Allows
                                    classic ADC-sample and ADC-bursts to generate interrupts
                                    (default)<p />1 = Disallows or blocks classic ADC-sample
                                    and ADC-bursts from generating interrupts. Setting the DMA
                                    bit, however over-rides this function. Use alternate
                                    interrupt generation to achieve desired interrupts.
ITS[3:0]     rw          0000      Interrupt Threshold Counter Source Select. Increment by:<p />0000
                                    = none (default)<p />0001 = Sample or Frame (i.e. ADC
                                    burst)<p />0010 = Block (i.e. 256 samples)<p />0011 =
                                    Analog Input Maximum Frame Count<p />0100 = Trigger Start
                                    and transition to active trigger state<p />0101 = Trigger
                                    Stop and transition to inactive trigger state<p />0110 =
                                    none<p />0111 = none<p />1000 = DIN0 rising edge<p />1001 =
                                    DIN0 falling edge<p />1010 = DIN1 rising edge<p />1011 =
                                    DIN1 falling edge<p />1100 = DIN2 rising edge<p />1101 =
                                    DIN2 falling edge<p />1110 = DIN3 rising edge<p />1111 =
                                    DIN3 falling edge
SITT         rw          0         Sync Interrupt Threshold Counter to the beginning of active
                                    trigger. This can be used to synchronize interrupts to
                                    trigger start.<p />0 = disabled (default)<p />1 = Clear
                                    Interrupt Threshold Counter to the beginning of the active
                                    trigger.
FIBLK[3:0]   rw          0000      Number of Blocks to generate a FIFO Interrupt. This is the
                                    number of samples written to the FIFO in order to generate
                                    an interrupt; if the sample timing is constant, then this
                                    interrupt will be at a constant rate as well.<p /><c>0000 =
                                    2 Blocks or 512 Samples (default)</c><p /><c>0001 = 4
                                    Blocks or 1,024 Samples</c><p /><c>0010 = 8 Blocks or 2,048
                                    Samples</c><p /><c>0011 = 16 Blocks or 4,096 Samples</c><p /><c>0100
                                    = 32 Blocks or 8,192 Samples</c><p /><c>0101 = 64 Blocks or
                                    16,384 Samples</c><p /><c>0110 = 128 Blocks or 32,768
                                    Samples</c><p /><c>0111 = 256 Blocks or 65,536 Samples</c><p /><c>1000
                                    = 512 Blocks or 131,072 Samples</c><p /><c>1001 = 1024
                                    Blocks or 262,144 Samples</c><p /><c>1010 = 2048 Blocks or
                                    524,288 Samples</c><p /><c>1011 = 0.0625 Block or 16
                                    Samples</c><p /><c>1100 = 0.125 Block or 32 Samples</c><p /><c>1101
                                    = 0.25 Block or 64 Samples</c><p /><c>1110 = 0.5 Block or
                                    128 Samples</c><p /><c>1111 = 1 Block or 256 Samples</c>
X            \-          \-        Don't Care
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Miscellaneous Output Configuration
<title Miscellaneous Output Configuration Register (Index=208\, RB='1')>

Summary
Miscellaneous Output Configuration Register
Description
This register is used to configure the CT_OUT2 (J7.2) and the
CT_OUT0 (J7.3) outputs. In other words, these outputs are now
generalized and various signals can be routed to these
outputs.
Register Layout
<b>Index=0xD0, Byte 0. Word 0. RB='1'.</b>
<table>
D7         D6           D5           D4           D3         D2           D1           D0
=========  ===========  ===========  ===========  =========  ===========  ===========  ===========
CTOUT2PE   CTOUT2SEL2   CTOUT2SEL1   CTOUT2SEL0   CTOUT0PE   CTOUT0SEL2   CTOUT0SEL1   CTOUT0SEL0
</table>

<b>Index=0xD1, Byte 1. Word 0. RB='1'.</b>
<table>
D15   D14   D13   D12   D11   D10   D9   D8
====  ====  ====  ====  ====  ====  ===  ===
X     X     X     X     X     X     X    X
</table>
Bit Definitions
<table>
NAME             DIRECTION   DEFAULT   \DESCRIPTION
===============  ==========  ========  ----------------------------------------------------------------------------
CTOUT2PE         rw          0         CT_OUT2 (J7.2) pulse extender<p />0 = disabled
                                        (default)<p />1 = enabled, extend selected signal by
                                        100nSec approximately.
CTOUT2SEL[2:0]   rw          000       CT_OUT2 (J7.2) source select<p />000 = 8254 CT2 output
                                        (default)<p />001 = Digital Output, DOUT5. Reference <link Digital Outputs>
                                        Register.<p />010 = Analog Input ADC-sample / ADC-Burst
                                        \sample pulse<p />011 = Active ADC Sampling<p />100 =
                                        Analog Input Frame Timer<p />101 = Interrupt Counter
                                        Increment<p />110 = zero<p />111 = IOCHRDY
CTOUT0PE         rw          0         CT_OUT0 (J7.3) pulse extender<p />0 = disabled
                                        (default)<p />1 = enabled, extend selected signal by
                                        100nSec approximately.
CTOUT0SEL[2:0]   rw          000       CT_OUT0 (J7.3) source select<p />000 = 8254 CT0 output
                                        (default)<p />001 = Digital Output, DOUT4. Reference <link Digital Outputs>
                                        Register.<p />010 = Trigger delay end pulse<p />011 =
                                        Trigger delay start pulse<p />100 = Interrupt Threshold
                                        Counter maximum reached<p />101 = Active ADC Sampling<p />110
                                        = ADC Data MSB address decode<p />111 = Interrupt
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Classic DAS16jr/16
<title Classic DAS16jr/16>

Summary
  * Single ADC-sample per analog input sample event.
  * Analog input sampling events enhanced from 3 to 13
    possible sources.
  * Supports DMA (see note).
Description
\ \ 

The DAS16jr/16 mode is the simplest of all STX104 modes, and
this mode is compatible with many other cards. In this case,
as seen by the illustration below, sampling is equally
spaced. If phase delay between channels is not important,
this mode offers maximum settling time between channels.



<image DAS16jr>



This mode typically uses the 8254 timer to set the sampling
rate, however, other sampling sources can now be configured
via the <link Analog Input General Configuration, Analog Input General Configuration Register>.
The <link Analog Input Frame Counter, frame counter> will
actually count samples rather than frames, and the <link Analog Input Frame Timer>
will produce the timing for each sample rather than each
frame.

@@Classic DAS1602
<title Classic DAS1602>

Summary
  * ADC-sample per analog input sample event.
  * ADC-burst (one or more channels collected) per analog
    \input sample event. Timing between ADC-samples within a
    burst are adjustable from 5 microseconds to 53 seconds to 25
    nanosecond resolution.
  * Analog input sampling events enhanced from 3 to 13
    possible sources.
  * Large FIFO depth allows for greater interrupt latency or
    readout latency.
  * Supports DMA (see note).
See Also
<link Conversion Disable>

<link Burst Mode Enable>

<link Burst Function Enable>

<link Extended Status>

<link Analog Input Burst Timer>
Description
\ \ 

The DAS1602 mode is a step up from the DAS16jr/16 mode in
that this mode additionally supports ADC-bursting. In other
words, one sample strobe will produce and ADC-burst or one
complete scan from the <i><link ADC Channel, first_channel></i>
to the <i><link ADC Channel, last_channel></i>.



<image DAS1602>



This mode typically uses the 8254 timer to set the sampling
rate, however, other sampling sources can now be configured
via the <link Analog Input General Configuration, Analog Input General Configuration Register>.
The <link Analog Input Frame Counter, frame counter> will
actually count samples rather than frames, and the <link Analog Input Frame Timer>
will produce the timing for each sample rather than each
frame.

@@Continuous High Speed Sampling
Summary
  * CPU read-out N-blocks of data per unit of time (i.e.
    CPU-burst reads)
  * Sample timing and intra-sample timing in ADC-burst modes
    adjustable to 25 nanosecond resolution.
  * FIFO interrupt generated interrupts and events are very
    flexible and support optimal CPU bursting (ultimately
    dependent on other CPU overhead or rhythmic behavior such as
    flash drives).
  * Data fragment buffer reduces PC/104 generated IOCHRDY or
    wait conditions, further enhancing PC/104 data bus
    throughput.
  * Large FIFO depth enhances the time decoupling between CPU
    activities and precise sample timing.
See Also
<link FIFO Status MSB>

<link Interrupt Configuration>
Description
\ \ 





<image continuous>

@@Start/Stop-Trigger Encased Frame Groups
Summary
  * Start-Trigger to begin sampling, then Stop-Trigger to
    stop sampling. Repeat sequence.
  * Large FIFO depth offers ability to collect large groups
    of data with a post-readout scheme.
See Also
<link Trigger Configuration>

<link Analog Input Frame Maximum>
Description
\ \ 



The most generalized sampling scheme is illustrated below.

<image encapsulated>

@@N-Sample Collection
Summary
  * Start-Trigger to begin sampling, stop sampling when
    N-samples/-Frames reached (i.e. Stop-Trigger event).
  * Large FIFO depth offers set it and forget it methodology,
    thus drastically reducing CPU software monitoring overhead.
See Also
<link Analog Input Frame Maximum>
Description
\ \ 





<image n-sample>

@@Analog Input
<title Analog Inputs>

\ \ 

@@Data Acquisition
<title Data Acquisition Modes>

Summary
\ \ 
Description
The following functions are available for each of the data
acquisition modes:
  * The timing between samples and frames (i.e. ADC&#45;burst)
    are adjustable to 25 nanosecond resolution via 32&#45;bit
    timers.
  * Analog Input Frame timing can be selected from a variety
    of sources including:
    * Internal Analog Input Frame Timer (AIFT) to 25ns
      resolution (50 ppm over temp).
    * External digital input (i.e. GPS pulses or other
      precision synchronizing timing sources)
  * Triggering subsystem. Triggering starts and stops can
    originate from internal or external events.
  * Interrupt subsystem. Variety of interrupts can be
    generated based on both internal and external events.
  * Moving average filter.

@@Triggering Subsystem
Summary
\ \ 
Description
The triggering subsystem is used to start and stop analog
\input sampling. This is a new generalized triggering system.
Please refer to <link Trigger Configuration> and <link Trigger Start Delay>
Registers for further details.



The <link Analog Input General Configuration> Register bit
nSGATE is used to enable triggering subsystem use. The nSGATE
bit is required in order to support classic modes without
special configuration.



Further, the triggering subsystem must be enabled in order
for it to function.



There are three start triggering sequences:
  1. Start trigger source --\> Analog Input Sampling Begins
  2. Start trigger source --\> Trigger Delay --\> Analog
     \Input Sampling Begins
  3. Start trigger source --\> Start Trigger Synchronization
     source --\> Trigger Delay -- \> Analog Input Sampling Begins.

Analog input sampling is stopped upon a valid End/Stop
Trigger Source event.



What is the purpose of the triggering subsystem? It allows
precise control as to when analog input sampling can occur.
It is possible to synchronize sampling to 60Hz line source or
whatever is chosen. It is possible to configure the
%CARD_NAME% to trigger on an event and accumulate N-samples
and then stop sampling.



* Synchronization of Analog Input Frame Timer to Trigger Start (SAIFTTS) *
The diagrams below illustrate how sample timing is affected
by the SAIFTTS bit found in the Analog Input General
Configuration Register.



<image SAIFTTS=1>



<image SAIFTTS=0>
See Also
<link Trigger Configuration>

@@Analog Input Calibration
<title Calibration>

Summary
\ \ 
Description
Assumption: Using default legacy Straight-Binary data
encoding (data format).



Perform the following procedure to adjust ADC input. We
recommend averaging ADC values over at least 256 samples in
order to provide the most accurate calibration possible,
reference the Voltage Input Conversion section under the <link ADC Data, ADC Data Register>
\description. Full scale or gain calibration relies on the
use of an external precision voltage source (or one can use a
DAC output for this purpose as well).
  1. Select the desired input mode by configuring J8 for
     differential or single-ended inputs.
  2. Select the desired input range by configuring J9 for
     unipolar or bipolar inputs.
  3. Calibration of potentiometer PGA_OFF (R3), if present.
     If R3 is not present, then skip to step #4 below.
     1. Short J7 pin 36 to J7 pin 37. In the case of
        differential inputs (J8 not stuffed), also short J7 pin 35 to
        J7 pin 37.
     2. Using a voltmeter connected to the two test points
        VPGA and AGND, adjust R3 to obtain zero volts (+/- 1 LSB).
  4. Set the desired gain by writing to the <link ADC Configuration, ADC Configuration Register>
     (base_address + 11) to the desired ADC input gain.
  5. Set the <link ADC Channel, ADC Channel Register>
     (base_address + 2) to zero so that we are observing input
     channel zero.
  6. Offset Adjustment.
     1. In the case of single-ended inputs (jumper J8
        installed), short J7 pin 36 to J7 pin 37; effectively
        connecting the single-ended input to analog ground. In the
        case of differential inputs (jumper J8 not installed), short
        J7 pin 35 and pin 36 to J7 pin 37; effectively connecting the
        differential input to analog ground.
     2. While performing ADC conversions and reading the ADC
        value, adjust potentiometer ADC_OFFSET (R4) until the nearest
        zero value can be achieved, typically within one ADC step or
        LSB.
  7. Remove all jumpers from the I/O connector at J7.
  8. Gain Adjustment.
     1. In the case of single-ended inputs (jumper J8
        installed), connect J7 pin 36 to the full scale voltage
        source. In the case of differential inputs (jumper J8 not
        installed), connect J7 pin 35 to J7 pin 37 and J7 pin 36 to
        the full scale voltage source. Adjust the DAC output for ADC
        full-scale input minus two LSB. Measure this value using a
        calibrated voltmeter to the accuracy you require.
     2. While performing ADC conversions and reading the ADC
        value, adjust potentiometer ADC_GAIN (R5) until full scale
        minus two LSB is achieved. This can be achieved through
        averaging ADC values. Please reference ADC Conversion
        Register for software example on how to average data.
  9. Remove all jumpers from the I/O connector at J7.
  10. Repeat steps 5 through 8 until the ADC input is
      calibration to within the accuracy you need or +/- 2 LSB.

@@Analog Input Connectivity
<title Connectivity>

\ \ 

@@Analog Outputs
\ \ 

@@Analog Output Calibration
<title Calibration>

\ \ 
Summary
\ \ 
Description
\ \ 

Hardware configuration:
  1. Select the desired output range by adjusting jumper
     settings at J5.
  2. Install jumper M2 as required for the application (this
     jumper selects 16-bit versus 12-bit resolution).

Calibration of DAC Channel-A:
  1. Write 65535 (0xFFFF) to Register <link DAC Channel-A>.
  2. Adjust potentiometer DA1_G (R2) until the desired full
     scale is reached.

Calibration of DAC Channel-B:
  1. Write 65535 (0xFFFF) to Register <link DAC Channel-B>.
  2. Adjust potentiometer DA2_G (R1) until the desired full
     scale is reached.

@@Analog Output Connectivity
<title Connectivity>

\ \ 
Summary
\ \ 
Description
Each DAC channel is a single-ended type output. We suggest
wiring the return path back to one of the AGND pins at
connector J7.

@@Moving Average Filter
Summary
\ \ 
Description
Installing jumper M3 enables the 16-sample moving average
filter for all channels. The filter can be reset (or cleared)
by writing to the Channel Register. The moving average filter
is enabled for all channels and operates completely
transparent to ADC acquisition modes. The ADC values read out
will be the current sample plus the last fifteen samples
summed together and divided by sixteen (average of sixteen
ADC samples). It is important to recognize that after the
filter is reset or at the beginning of data sampling that it
may require at least 16-data samples per channel be taken
until the data becomes current. In other words, there is an
inherent 16-sample delay in the ADC data that is read out of
the ADC Data Register. 

@@Analog Input Sample Event
Summary
Analog Input Sample Event is a signal that causes either an
analog input sample or analog input burst, depending on how
the %CARD_NAME% is set up.

@@Frame
Summary
A Frame is a generalized term. This is the record that is
deposited per frame time into the FIFO memory. Currently, a
frame is the equivalent to an ADC-Burst in terms of the
amount of samples stored in the FIFO.

@@CPU Readout Methods
\ \ 

@@DMA Read
Summary
Analog input data is read from the FIFO memory via Direct
Memory Access (DMA).


Description
\ \ 

We strongly encourage you to use the REP INSW instruction (or
Insw() function in Linux) as it performs better than DMA and
is substantially simpler to set up and use. Note that DMA
performs I/O to memory transfers a byte at a time (DMA 1 and
DMA 3 are byte wide transfers) while REP INSW performs I/O to
memory transfers a word at a time. If you are designing a
real-time system, you will have better timing control over
your system by using REP INSW instruction over DMA. Since
processor generated I/O cycles are faster than DMA generated
cycles (typically 350ns versus 800ns), data transfer can take
place faster than DMA. Note that 8-bit bus transactions
(including DMA) are typically at least twice as long as
16-bit bus transactions; this alone is reason enough to avoid
DMA.



When DMA is enabled, the 1 mega-sample FIFO is used.



In DMA mode, receiving a terminal count from the CPU will
generate an interrupt, if the interrupt is enabled. If you
are in DAS1602 mode (jumper M0 is installed), receiving a
terminal count will set the Conversion Disable bit to false,
thus disabling any additional ADC sampling. Writing 0x00 to
the <link Conversion Disable, Conversion Disable Register>
will allow ADC sampling to continue.



In order to use DMA, you must set up the computer’s DMA
controller and page registers before enabling DMA on the
STX104 board.



We consider DMA a deprecated function and in the future
should be avoided; it just no longer makes any sense to use,
but we still continue to support it as a part of legacy
functionality.

@@CPU Burst Read
<title Burst Read>

Summary
Reading multiple samples one after the other reading out
blocks or frames (i.e. ADC-burst) of data in a short interval
of time. This is typically done using the REP INSW or Insw()
type functions. Refer to the <link ADC Data, ADC Data Register>
for an example.


@@Interrupt Summary
<title Interrupt Summary>

Summary
\ \ 
Description
\ \ 
* CLASSIC INTERRUPT SOURCE SELECTION (When Interrupt Configuration Register Bit nINT_FF='0') *
<table>
AIE or EIS   FIE   DMA   M1   Interrupt Function
===========  ====  ====  ===  --------------------------------------------------------------------------------------
0            X     1     0    No interrupt generated.<p />Poll INT to determine when a
                               DMA terminal count is received from the DMA controller to
                               indicate completion of the DMA transfer.
1            X     0     0    Interrupt generated when an ADC conversion has completed.
                               Write to the Clear Interrupt Register to clear the
                               interrupt. In DAS1602 compatibility mode (jumper M0
                               installed), an interrupt is generated for each sample when
                               in ADC-burst mode.
1            X     1     0    Interrupt generated when a DMA terminal count is received
                               from the DMA controller to indicate completion of the DMA
                               transfer.
0            0     0     1    No interrupt generated.<p />Poll INT to determine when an
                               ADC conversion has completed.<p />Poll INT_FF to determine
                               when 512 additional samples have been queued to the FIFO.
                               The number of blocks is now configurable, refer to the <link Interrupt Configuration>
                               Register.<p />
0            X     1     1    No interrupt generated.<p />Poll INT to determine when a
                               DMA terminal count is received from the DMA controller to
                               indicate completion of the DMA transfer.<p />Poll INT_FF to
                               determine when 512 additional samples have been queued to
                               the FIFO. The number of blocks is now configurable, refer
                               to the <link Interrupt Configuration> Register.<p />
1            X     1     1    Interrupt generated when a DMA terminal count is received
                               from the DMA controller to indicate completion of the DMA
                               transfer.
0            1     0     1    Interrupt generated when 512 additional samples are
                               deposited in the FIFO. Write to the Clear Interrupt
                               Register to clear the interrupt. The number of blocks
                               required to generate an interrupt is now configurable,
                               refer to the <link Interrupt Configuration> Register.<p /><p />Poll
                               INT to determine when deglitched DIN0 rising-edge has
                               occurred. By connecting CT_OUT0 or CT_OUT2 to DIN0 you can
                               create a polled timing function. Any external input can
                               produce a polled rising-edge. If GCTRL bit is set then this
                               can be used to detect the beginning of pacer clock gating
                               (i.e. start of one or more samples). Writing to the Clear
                               Interrupt Register will also clear the INT bit.<p />
1            0     0     1    Interrupt generated when an ADC conversion has completed.
                               Write to the Clear Interrupt Register to clear the
                               interrupt. In DAS1602 compatibility mode (jumper M0
                               installed), an interrupt is generated for each ADC-burst
                               completion when in ADC-burst mode.<p />Poll INT_FF to
                               determine when 512 additional samples have been queued to
                               the FIFO. The number of blocks is now configurable, refer
                               to the <link Interrupt Configuration> Register.<p />
1            1     0     1    Interrupt generated when 512 samples deposited in the FIFO.
                               Write to the Clear Interrupt Register to clear the
                               interrupt. The number of blocks required to generate an
                               interrupt is now configurable, refer to the <link Interrupt Configuration>
                               Register.<p />Interrupt generated when deglitched DIN0
                               rising-edge has occurred. By connecting CT_OUT0 or CT_OUT2
                               to DIN0 you can create an interrupt timing function. Any
                               external input can produce an interrupt. If GCTRL bit is
                               set, this can be used to detect the beginning of pacer
                               clock gating (i.e. start of a group of samples). Writing to
                               the Clear Interrupt Register will also clear the INT bit.<p />
</table>



* ADDITIONAL INTERRUPT CONFIGURATIONS AND SOURCES *

Please reference the following registers listed for detailed
information. In summary, additional IRQ selection, IRQ
sources along with programmable interrupt threshold count is
possible.



<link Interrupt Source Select, Interrupt Source Select Register>

<link Interrupt Configuration, Interrupt Configuration Register>

<link Interrupt Threshold, Interrupt Threshold Register>

@@FIFO Configuration
<title FIFO Configuration (Index=228\, RB='1')>

Summary
FIFO Configuration Register
Description
Enabling the High Speed CPU FIFO Buffer can reduce bus wait
states generated due to waiting for %CARD_NAME% main memory
data availability. In many cases, bus wait states (due to
IOCHRDY) are eliminated. We found that overall throughput
through the ISA bus was improved by approximately 15%.



By default the CPU FIFO Buffer is disabled in order to
maintain classic timing characteristics which might be
critical to a customer completed application.
Register Layout
<b>Index=0xE4, Byte 0. RB='1'.</b>
<table>
D7         D6   D5   D4   D3   D2   D1   D0
=========  ===  ===  ===  ===  ===  ===  ===
HSFIFOEN   X    X    X    X    X    X    X
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  ---------------------------------------------------
X          \-          \-        Don't Care
HSFIFOEN   rw          0         High Speed pre-queue FIFO Buffer Enable<p />0 =
                                  Disabled, utilize main memory only (default)<p />1
                                  = Enabled, use high speed CPU buffer
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Single-Ended
Summary
Single-ended analog inputs.
Description
\ \ 

A single-ended input channel consists of one input. The
\output is the difference between the input and AGND
(common).



<image STX104_Single-Ended_Analog_Input>
* Jumper Setup *
J8 jumper must be installed for single-ended mode of
operation. This also configures the %CARD_NAME% card for
sixteen analog input channels.

* Amplifier Bias Currents *
The primary path of amplifier bias currents is the AGND (or
common) and since the source is tied to AGND amplifier bias
currents flow through the sensor to AGND. Amplifier bias
currents are typically on the order of tens of nano-amps.



* Source Resistance *
Source resistance Rsource along with cable and input
parasitic capacitances must be taken into considered to
determine minimum settling time. More details can be found <link Analog Input Burst Timer, here>.

* Input Ranges *
The input ranges for single-ended inputs.
<table>
SINGLE-ENDED INPUT   RESOLUTION   UNIPOLAR/BIPOLAR   ACFG.ADBU   ACFG.G1   ACFG.G0
 RANGE<p />( CHn)                  (J9)                                     
===================  ===========  -----------------  ==========  ========  ========
\+/- 10 V            305 uV       J9 not installed   0           0         0
\+/- 5 V             153 uV       J9 not installed   0           0         1
\+/- 2.50 V          76 uV        J9 not installed   0           1         0
\+/- 1.25 V          38 uV        J9 not installed   0           1         1
0 to +10 V           153 uV       J9 installed       1           0         0
0 to +5 V            76 uV        J9 installed       1           0         1
0 to +2.5 V          38 uV        J9 installed       1           1         0
0 to +1.25 V         19 uV        J9 installed       1           1         1
</table>
\NOTE: <link ADC Configuration, Analog Configuration Register (ACFG)>



* Advantages *
  * More analog input channels available
  * Less wiring and lower cost

<b>Disadvantages</b>
  * Since all inputs are referred to AGND (i.e. common) the
    possibility exists for ground loops or voltage drops along
    common connections which will add to noise or measurement
    errors.

@@Differential
Summary
Full differential analog inputs.
Description
\ \ 

A differential analog input channel consists of two inputs,
high side (positive) and low side (negative). The output
measured is the difference between the two inputs, thus
rejecting signals that are common to both inputs. In many
situations this offers additional noise immunity to the
signal of interest. The image below illustrates how to
interface a sensor to a differential input channel.



<image STX104_Differential_Analog_Input>
* Jumper Setup *
J8 jumper must be removed for differential mode of operation.
This also configures the %CARD_NAME% card for eight analog
\input channels.

* Optional Rbias *
All analog inputs require a small amount of bias current, on
the order of tens of nano-amps. If the sensor or signal
source is not referenced to the %CARD_NAME% AGND or system
power supply then a resistor must be tied from one of the
differential leads to AGND. The resistor value range is
typically 100K ohms down to 100 ohms, depending on the
application and the actual input bias current required. In
most cases a 10K ohm resistor will do and will add less than
\+/-50uV of common-mode due to the bias current. Actually,
the R<sub>bias</sub> value could be as low as zero ohms, but
using zero ohms you are reverting to single-ended behavior.

* Source Resistance *
Source resistance Rsource along with cable and input
parasitic capacitances must be taken into considered to
determine minimum settling time. More details can be found <link Analog Input Burst Timer, here>.

* Input Ranges *
The input ranges for each half of the differential input
along with the full differential input range.
<table>
DIFFERENTIAL         RESOLUTION   UNIPOLAR/BIPOLAR<p />(J9)   ACFG.ADBU   ACFG.G1   ACFG.G0   CHn HIGH<p />RANGE   CHn LOW<p />RANGE
 \INPUT RANGE<p />(                                                                                                 
 (CHn High) -                                                                                                       
 (CHn Low) )                                                                                                        
===================  ===========  --------------------------  ==========  ========  ========  ===================  ==================
\+/- 10 V            305 uV       J9 not                      0           0         0         \+/- 10 V            \+/- 10 V
                                   installed                                                                        
\+/- 5 V             153 uV       J9 not                      0           0         1         \+/- 5 V             \+/- 5 V
                                   installed                                                                        
\+/- 2.50 V          76 uV        J9 not                      0           1         0         \+/- 2.5 V           \+/- 2.5 V
                                   installed                                                                        
\+/- 1.25 V          38 uV        J9 not                      0           1         1         \+/- 1.25 V          \+/- 1.25 V
                                   installed                                                                        
\+/- 10 V            153 uV       J9 installed                1           0         0         0 - 10 V             0 - 10 V
\+/- 5 V             76 uV        J9 installed                1           0         1         0 - 5 V              0 - 5 V
\+/- 2.50 V          38 uV        J9 installed                1           1         0         0 - 2.5 V            0 - 2.5 V
\+/- 1.25 V          19 uV        J9 installed                1           1         1         0 - 1.25 V           0 - 1.25 V
</table>
\NOTE: <link ADC Configuration, Analog Configuration Register (ACFG)>



* Example Applications *
To measure the output of a bridge network as shown in the
diagram below. When the bridge is balanced, the common mode
voltage at both the positive and negative inputs of the
differential input are the same. Thus, the %CARD_NAME% will
report zero volts output (0x8000 in straight binary). Note
that the voltage driving the bridge will be ratiometric at
the outputs and thus nulled at the output.



<image STX104_Differential_Analog_Input_Bridge_Example>





If the negative side of the source driving the bridge is tied
to the system supply that supplies power to the %CARD_NAME%,
then the R<sub>bias</sub> is not required because input bias
currents have a complete DC path. If you are not sure whether
your signal source is referenced to the %CARD_NAME% AGND,
power down the system, and using an ohmmeter measure the
resistance between %CARD_NAME% AGND and the common side of
your signal source, you will want the resistance to be less
than 10K ohms.

* Advantages *
  * Common mode rejection
  * Signals can be extracted even though there is a common
    mode voltage
  * typically improves noise immunity
  * Can perform ratiometric measurements

<b>Disadvantages</b>
  * More wiring
  * Fewer channels available

@@Connector Summary
Summary
%CARD_NAME%
Description
\ \ 
* ISOLATED DIGITAL INPUTS CONNECTOR J1 *
<image 980061_J1_50pin_image_3inch>
<table>
Name         Notes
===========  ========================================================
a[23..0]     Positive digital input, opto-isolator LED anode<p />Max
              voltage: +10 VDC (with respect to cathode)<p />Nominal
              voltage: +5VDC (with respect to cathode)<p />2.2 Kohm
              series resistor used
k[23..0]     Negative digital input, opto-isolator LED cathode
no connect   nothing connected to these pins
</table>

* ISOLATED DIGITAL INPUTS CONNECTOR J2 *
<image 980061_J2_50pin_image_3inch>
<table>
Name         Notes
===========  =============================================================
a[39..24]    Positive digital input, opto-isolator LED anode<p />Absolute
              max voltage: +40 VDC (with respect to cathode)<p />Nominal
              voltage: +35VDC (with respect to cathode)<p />12 Kohm
              series resistor used
k[39..24]    Negative digital input, opto-isolator LED cathode
a[47..40]    Positive digital input, opto-isolator LED anode<p />Absolute
              max voltage: +10 VDC (with respect to cathode)<p />Nominal
              voltage: +5VDC (with respect to cathode)<p />2.2 Kohm
              series resistor used
k[47..40]    Negative digital input, opto-isolator LED cathode
no connect   nothing connected to these pins
</table>









<table>
Jumper   Function
=======  ----------------------------------------------
0*       Bipolar Analog Inputs ( +/- values accepted )
1        Unipolar Analog Inputs ( + values only )
</table>
\* Factory Default

\Note: 1 = Jumper installed, 0 = Jumper not installed.

* DIFFERENTIAL OR SINGLE-ENDED ANALOG INPUT (J8) *
<image Jumper_2pin>
<table>
Jumper   Function
=======  ---------------------------------
0*       Differential Inputs, 8-channels
1        Single-Ended Inputs, 16-channels
</table>
\* Factory Default

\Note: 1 = Jumper installed, 0 = Jumper not installed.

* DAC RANGE SETTINGS (J5) *
<image STX104_DAC_Jumper_8pin>
<table>
DA1_UB   DA1_R   DAC-1 RANGE
=======  ======  -----------------
0        0       0 to +5 Volts *
0        1       0 to +10 Volts
1        0       \-5 to +5 Volts
1        1       \-10 to 10 Volts
</table>
\* Factory Default

\Note: 1 = Jumper installed, 0 = Jumper not installed.

<table>
DA2_UB   DA2_R   DAC-2 RANGE
=======  ======  -----------------
0        0       0 to +5 Volts *
0        1       0 to +10 Volts
1        0       \-5 to +5 Volts
1        1       \-10 to 10 Volts
</table>
\* Factory Default

\Note: 1 = Jumper installed, 0 = Jumper not installed.

@@Revision Information
Summary
By scanning and manipulating the STX104 registers one can
determine the firmware revision that is installed.
Description
Revision Releases
<table>
Date                Revision ROM   Board ID Register
                     Label          Value
------------------  -------------  ------------------
July 16, 2004       071604         Does not exist
February 14, 2008   080214H        0x1008
April 4, 2008       080407H        0x1008
January 15, 2009    090115H        0x1009
</table>

<c>Note:</c>

<c>1. Revision 080214H has been replaced by 080407H including
boards in the field effectively eliminating the 080214H
revision entirely. Revision 080407H corrects for several
minor issues that were discovered in revision 080214H which
does not warrant a change to the board ID.</c>

<c>2. Revision 090115H added mapping the 8254 registers
through the index register set to improve accessibility by
driver software.</c>
Example
\ \ 
<code lang="c++">

/* STX104 Revision Information */
\#define STX104_REVISION_071604                   0
\#define STX104_REVISION_080214              0x1008
\#define STX104_REVISION_080407              0x1008
\#define STX104_REVISION_090115              0x1009

/*****************************************************************
/                                               REVISION DETECTION
\*/
static unsigned int STX104_Revision_Detected( int board )
{
    unsigned int value;

    value = 0x55AA;
    STX104_Set_Bank( board, 1 );
    STX104_Write_Indexed_Data_Word( board, STX104_SCRATCH_PAD, value );
    value = STX104_Read_Indexed_Data_Word( board, STX104_SCRATCH_PAD );

    if ( value == 0x55AA ) value = STX104_Read_Indexed_Data_Word( board, STX104_BOARD_ID );
    else  value = 0;

    return( value );
}

</code>

@@Specifications
Summary
* STX104 Detailed Technical Specifications *

<include M:\\Company\\Documentation\\Source_Files\\stx104(-nd)_feature_summary.html>



<include M:\\Company\\Documentation\\Source_Files\\stx104(-nd)_specs_analog_inputs.html>



  * unorder list test
    * muck
  * second item in list
  * third item in list



<image Double Greater with dots copy><b> <color SyntaxHighlight_SymbolName>Analog
\Inputs</b></color>
  * <b>Resolution:</b> 16&#45;bits (1/65536 of full scale).
    No missing codes guaranteed
  * <b>Number of Channels:</b> 8 differential or 16
    single&#45;ended Inputs.
  * <b>Maximum Sampling Rate:</b> 200,000 Samples Per Second
  * <b>Input Type:</b> True differential or single&#45;ended,
    jumper selectable.
  * <b>Input Ranges:</b> Unipolar or Bipolar, jumper
    selectable.
    * <b>Bipolar:</b> ±10V, ±5V, ±2.5V, ±1.25V.
    * <b>Unipolar:</b> 0 to 10V, 0 to 5V, 0 to 2.5V, 0 to
      1.25V.
  * <b>Input Sensitivity:</b> 19 microvolts
  * <b>Noise Characteristics:</b> Gaussian behavior with
    maximum peak&#45;to&#45;peak internal noise of less than
    1.5&#45;LSB RMS over all input ranges and operating
    temperatures (1.2&#45;LSB RMS typical). Jumper selectable
    16&#45;point moving average filter drops noise to less than
    1&#45;LSB RMS over all input ranges and operating
    temperatures (0.6&#45;LSB RMS typical).
  * <b>DC Drift or Zero Drift:</b> ±2ppm/oC, ±1.5ppm/oC
    typical
  * <b>Input Bias Current:</b> 50nA maximum
  * <b>Absolute Maximum Input Voltage:</b> ±35V
  * <b>Common Mode Voltage Range:</b> ±10V
  * <b>Common Mode Rejection Ratio:</b> 70dB at 60Hz
  * <b>Integral Linearity Error:</b> ±1.5 LSB (±3 LSB on
    1.25V range)
  * <b>Differential Linearity:</b> ±1 LSB
  * <b>Accuracy:</b> 0.003% of reading, ±1 LSB
  * <b>Gain Drift:</b> ±7ppm/°C
  * <b>Trigger Sources:</b> Programmable internal 32&#45;bit
    counter/timer, external source (DI0/TRIG) or software polled.
    External input will accept GPS PPS output.
  * <b>Trigger Modes:</b> Gated pacer, software polled. (Gate
    must be disabled by software after trigger event)
  * <b>Data Transfer:</b> From 1 mega&#45;sample FIFO via
    interrupt, DMA or software
\NOTE: Least Significant Bit (LSB).





<image Double Greater with dots copy><color SyntaxHighlight_SymbolName><b>
Analog Outputs ( Without Analog Outputs, see STX104&#45;ND )</b></color>
  * <b>Resolution:</b> 16 bits
  * <b>Number of Channels:</b> 2
  * <b>Output Ranges:</b> ±10V, ±5V, 0&#45;5V, 0&#45;10V.
    Maximum current to 5 milliamps per channel. Each channel
    independently configurable by jumpers.
  * <b>Offset Error:</b> less than 8 LSB
  * <b>Gain Error:</b> Adjustable to 0 LSB by potentiometer
  * <b>Differential non&#45;linearity:</b> ±1 LSB max
  * <b>Settle Time:</b> 10 microseconds
  * <b>Integral non&#45;linearity:</b> ±1 LSB max
  * <b>Monotonicity Guaranteed</b>



<image Double Greater with dots copy><color SyntaxHighlight_SymbolName><b>
Digital Input/Outputs</b></color>
  * <b>Number of Inputs:</b> 4 TTL compatible
  * <b>Input Voltage:</b> Logic 0: 0.0V min, 0.8V max; Logic
    1: 2.0V min, 5.5V max
  * <b>Input Current:</b> ± 1uA max
  * <b>Number of Outputs:</b> 4 TTL compatible
  * <b>Output Voltage:</b> Logic 0: 0.0V min, 0.4V max; Logic
    1: 2.4V min, 3.3V max.
  * <b>Output Current:</b> ±12mA per line max



<image Double Greater with dots copy><color SyntaxHighlight_SymbolName><b>
Counter/Timers</b></color>
  * <b>Analog Input Pacer Timer:</b> 32&#45;bit Analog Input
    Frame Timer or legacy 32&#45;bit down counter (2 82C54
    counters cascaded)
  * <b>Clock Source Jumper selectable:</b> 40MHz (25nS) or
    legacy 1 MHz or 10 MHz on&#45;board clock source jumper
    select for 8254.
  * <b>General Purpose:</b> 16&#45;bit down counter: (1 82C54
    counter)
  * <b>Interrupt/DMA Trigger:</b> End of analog input
    conversion



<image Double Greater with dots copy><color SyntaxHighlight_SymbolName><b>
General</b></color>
  * <b>Operating temperature range:</b> &#45;40 to +85°C
  * <b>Storage temperature range:</b> &#45;55 to +125°C
  * <b>Factory Calibration:</b> Full NIST Traceable
  * <b>Humidity:</b> 0 to 95% non&#45;condensing
  * <b>Power Supply:</b> 5VDC ± 5% at less than 350mA
  * <b>Interface:</b> PC/104 8&#45; or 16&#45;bit data paths

@@CPU Readout notes
DMA



Burst Read



Single Sample



Block read



\----

multiple board







bus / cpu characterization

\- fill FIFO and read out using n-blocks. repeat,
incrementing n each time.



Block Characterization

\1. block_count=1

\2. fill fifo with 1 million samples and stop

\3. start time stamp

\4. readout samples block_count at a time using rep-string

\5. stop time stamp

\6. compute time interval and store

\7. increment block_count and repeat above until
block_count=2048.



Continuous readout

\1. using the computed Block_Characterisztion use the optimum
block size along with total time interval for readout to
determine block size that can be used.



max_block = Total_Bandwidth_per_second / ( ( Number_Boards *
Samples_per_sec ) * ( optimum_block_count ) )



if max_block \< optimum_block_count then block_to_read =
optimum_block_count

else block_to_read = max_block.





\-



Assembly: Probably best to use short ribbons to a side PCB or
possibly a direct connect. Only problem with direct connect
is that there could end up being some mechanical stress.



In order to achieve direct connect one would need a way for
the boards to mechanically float somehow. Seems like similar
problem with PC boards installed into motherboard, just not
mechanically robust.



OK, the boards can be screwed together and then use
connectors on the connecting board that can tolerate a 0.1
inch variation (rouhly) in insertion and still maintain
connection. The value of this is quick assembly

@@Single Read
Summary
Reading an individual sample using either an 8- or 16-bit
read cycle. Refer to the the <link ADC Data, ADC Data Register>
for examples.

@@Intra-Sample
Summary
Intra-sample refers to time between analog input samples
within an ADC-burst operation.


See Also
<link Analog Input Burst Timer>

@@Analog Input Sample Timing
<title Analog Input Sample Timing>

Summary
\ \ 
Description
The example below illustrates various methods of setting up
analog input sample timing. There are two primary parameters
needed to setup timing: time between frames, and time between
samples (i.e. ADC-burst timing).



One must call the STX104_AI_Time_Settling_Minimum() function
to determine the minimum timing possible between samples or
the intra-sample timing or minimum ADC-burst timing.



The functions within the example code below will compute and
configure the proper analog input timing registers based on
firmware revision level. If only 8254 timers are used, then
resolution is fixed to 1uSec. In the case of using the <link Analog Input Frame Timer>
and the <link Analog Input Burst Timer>, resolution is
improved to 25 nanoseconds.



When using the triggering subystem, to synchronize analog
\input sampling to the trigger-start event, set the SAIFTTS
bit in the <link Analog Input General Configuration>
Register.



\-



Method for configuring the <link Analog Input Frame Timer>
and the <link Analog Input Burst Timer> registers.



a) Our assumption is that ADC-burst mode will always be
enabled, and is acceptable for all situations.



b) First calculate the time between samples (i.e.
intra-sample time) in the the ADC-burst mode. The timing can
be as short as 5uSec or longer. The timing is based on
multiplexer settling time.



If you have a sensor with a source resistance of 10Kohms and
a cable with a total capacitance of 100pF, then the minimum
time between samples will be approximately 11 * 10Kohms *
100pF = 11,000 nSec. In other words, the minimum settling
time is eleven RC time constants.



ai_time_intra_sample_ns = AIBT_Register_Value * ( 25 nSec ) +
( 5000 nSec ).



AIBT_Register_Value = ( ai_time_intra_sample_ns / ( 25 nSec )
) - 200



c) The minimum frame time will be:



minimum_ai_time_frame_ns = ( last_channel - first_channel + 1
) * ai_time_intra_sample_ns.



d) The frame time can now be computed:



ai_time_frame_ns = ( AIFT_Register_Value + 1 ) * ( 25 nSec )



AIFT_Register_Value = ai_time_frame_ns * ( 25 nSec ) - 1



The above example is a summary of the example source code
below.
Example
\ \ 
<code lang="c++">
\#define STX104_INTRA_SAMPLE_TIMING           5000  /* nanoseconds */
\#define STX104_TIME_RESOLUTION               25    /* nanoseconds */


\#define STX104_REVISION_080214   0x1008
\#define STX104_REVISION_080407   0x1008
\#define STX104_REVISION_090115   0x1009


/*##################################################################################
\*                                                      ANALOG INPUT TIMING FUNCTIONS
\*/

/*****************************************************************
/                               ANALOG INPUT MINIMUM SETTLING TIME
\*/
static unsigned long STX104_AI_Time_Settling_Minimum( float ai_capacitance_pf, float ai_resistance_ohms )
{
    unsigned long settle_time_ns;

    //settle_time = ai_resistance_ohms * ai_capacitance_pf * pow10(-12) * 16 * ln(2) * pow10(9)
    settle_time_ns = (unsigned long) ( ai_resistance_ohms * ai_capacitance_pf * pow10(-3) * 16 * log(2) );

    return( settle_time_ns );
}
/*****************************************************************
/                                         ANALOG INPUT 8254 TIMING
\*/
static void STX104_AI_Timing_8254_Set( int board, long time_interval_ns )
{
    \long high_count;
    \long low_count;
    unsigned int octet;

    STX104_Set_Bank( board, 0 );

    /* assumes 10MHz clock (i.e. no 1MHz jumper) */
    low_count  = 10L; /* 1 microsecond intervals */

    high_count = time_interval_ns / 1000;
    while ( high_count \> 65536L )
    {
        high_count = high_count \>\> 1;
        low_count  = low_count \<\< 1;
    }
    while ( high_count \< 2L )
    {
        high_count = high_count \<\< 1;
        low_count  = low_count \>\> 1;
    }
    /* set counter/timer 2  */
    outportb( stx104_base_address[board] + STX104_CT_CONFIGURATION, 0xB4 );
    octet = ((unsigned int) high_count) &amp; 0x00FF;
    outp( stx104_base_address[board] + STX104_CT2_DATA, octet );
    octet = ((unsigned int) high_count) \>\> 8;
    outp( stx104_base_address[board] + STX104_CT2_DATA, octet );
    /* set counter/timer 1  */
    outportb( stx104_base_address[board] + STX104_CT_CONFIGURATION, 0x74 );
    octet = ((unsigned int) low_count) &amp; 0x00FF;
    outp( stx104_base_address[board] + STX104_CT1_DATA, octet );
    octet = ((unsigned int) low_count) \>\> 8;
    outp( stx104_base_address[board] + STX104_CT1_DATA, octet );
}

/*****************************************************************
/                                      ANALOG INPUT GENERAL TIMING
\*/
static void STX104_AI_Timing_Set( int board, unsigned long ai_time_frame_ns, unsigned long ai_time_intra_sample_ns )
{
    unsigned int adc_burst_channel_count;

    switch ( stx104_revision[board] )
    {
       case STX104_REVISION_080214:  /* same as version 080407 */
       case STX104_REVISION_090115:
            STX104_Set_Bank( board, 1 );
            STX104_Write_Indexed_Data_Byte( board, STX104_BURST_FUNCTION_ENABLE_INDEXED, 0x40 );
            STX104_Write_Indexed_Data_Byte( board, STX104_BURST_MODE_ENABLE_INDEXED,     0x40 );
            STX104_Write_Indexed_Data_Byte( board, STX104_CONVERSION_DISABLE_INDEXED,    0x00 );
            adc_burst_channel_count = (unsigned char)( 0x0F &amp; ( stx104_ai_channel_last[board] - stx104_ai_channel_first[board] ) );
            adc_burst_channel_count = adc_burst_channel_count \<\< 4;
            outp( stx104_base_address[board] + STX104_PACER_CLOCK_CONTROL, adc_burst_channel_count );
            /* the following registers require the number of 25nSec intervals to achieve the selected timing */
            STX104_Write_Indexed_Data_Dword( board, STX104_ANALOG_INPUT_FRAME_TIMER, ( ai_time_frame_ns/STX104_TIME_RESOLUTION ) );
            STX104_Write_Indexed_Data_Dword( board, STX104_ANALOG_INPUT_BURST_TIMER, ( (ai_time_intra_sample_ns - STX104_INTRA_SAMPLE_TIMING) / STX104_TIME_RESOLUTION ) );
            break;
        default:
            if ( ai_time_intra_sample_ns \> STX104_INTRA_SAMPLE_TIMING /*nS*/ )
            { /* cannot use adc-burst mode */
                STX104_AI_Timing_8254_Set( board, ai_time_intra_sample_ns );
                outp( stx104_base_address[board] + STX104_BURST_FUNCTION,         0x00 );
                outp( stx104_base_address[board] + STX104_BURST_MODE_ENABLE,      0x00 );
                outp( stx104_base_address[board] + STX104_CONVERSION_DISABLE,     0x00 );
            }
            else
            { /* utilize adc-burst mode */
                STX104_AI_Timing_8254_Set( board, ai_time_frame_ns );
                outp( stx104_base_address[board] + STX104_BURST_FUNCTION,         0x40 );
                outp( stx104_base_address[board] + STX104_BURST_MODE_ENABLE,      0x40 );
                outp( stx104_base_address[board] + STX104_CONVERSION_DISABLE,     0x00 );
                adc_burst_channel_count = (unsigned char)( 0x0F &amp; ( stx104_ai_channel_last[board] - stx104_ai_channel_first[board] ) );
                adc_burst_channel_count = adc_burst_channel_count \<\< 4;
                outp( stx104_base_address[board] + STX104_PACER_CLOCK_CONTROL, adc_burst_channel_count );
           }
    }
}
</code>

@@Multi-card
\ \ 
Summary
\ \ 

@@Errata
Summary
Addresses known board related issues and includes methods to
work around the issues.
Description
\ \ 

none



\--- end

@@TODO-Don't publish
  1. Add analog input configuration drawings and comments.
  2. Create a learning chapter. Engineering student training
     chapter. Offer discount to universities that buy product.
     1. behavior of multiplexed inputs
     2. detailed ADC description
     3. Experiments that emphasize things that the STX104 can
        do that other similar product cannot do.
  3. Application notes that emphasize things that the STX104
     can do that other similar product cannot do.
  4. Trigger section needs more explaination. It is not clear
     how the trigger modes work exactly.
  5. AIGC register needs more explaination for the bit
     settings.
  6. Need more discussion on triggering and analog input
     sampling configurations. Illustrations showing all of the
     timing combinations would be great.
  7. Discuss engineering/debug versus production version
     software.
  8. General configuration register Mode jumper settings
     needs more description or links.
  9. when the mode of the adc_control register is changed it
     goes to 0xFF rather than zero...why?
  10. WISHLIST: Analog Inputs with individual enables and
      individual route-to-fifo selects. Reason: to further offer
      more flexible timing (i.e. 100KSPS over 5 channels and
      collect only on three channels. With AIFT we get 0.05%, but
      if we sample all five channels and save only three, timing
      will be exact at 20KSPS/Channel.
  11. DONE: Bug in miscellaneous register bit definitions.
  12. Interrupt threshold register description is not clear.
  13. Analog Inputs-\>Timing: Need to add one additional
      section of code to show how to make it all work.





Firmware wishlist
  1. A way to see the interrupt threshold register
  2. DONE: 8254 mapped to index space
  3. DAC buffers: FIFO and CBUF
  4. A way to trigger one or more boards together at the same
     time. It would be useful if it could be done via software.
     Have a register that observes a particular I/O address along
     with data. if there is a match, then this is a trigger.
  5. Have one of the DOUTs or CT_OUTx function as a trigger
     \output from one card that is routed to all of the DINs. This
     one is basically done.
  6. Bring out the channel enables.
  7. Quadrature encoder or counter inputs. PWM outputs.
  8. Triggering. Start could be defined by watching a
     particular ADC channel. Register required is 20 bits
     (CHx,Value).
  9. DSP functionality. At a minimum oversampling. There
     could be a register that sets oversampling and then one can
     decide where to readout.
  10. Be able to stuff DINs into fifo frame.
  11. somehow resync clocks for long term stability
  12. Triggering: pre- and post- trigger data stores
  13. Interrupt settings: level, rising-edge or falling-edge.
      Pulse or persistent.

@@Power Supply
Description
\ \ 

<b>PC/104 Connector</b>

Minimum input Power Requirements at the PC/104 Connector: +5V
at 250mA typical (300mA maximum).



<b>Power Available at J7</b>

J7.1: +5V at 200mA (+5V at 450mA at the PC/104 connector).

J7.15: -5V at 25mA



The +5V at J7 pin 1 is tied directly to the PC/104 +5V supply
line.

The -5V at J7 pin 15 is derived from the on-board DC-DC
converter and on-board regulator.



Recommend that the -5V be returned via one of the AGND pins
at J7.

Recommend that the +5V be returned via the DGND for larger
currents. If +5V is going to drive a small analog load
(\<50mA) then it is OK to return via AGND pins at J7.

@@Mechanicals
Summary
\ \ 
Description
The table below lists the locations of key mechanicals of the
STX104 board.
<table>
\LOCATION                   X<p />(milli-inches   Y<p />(milli-inches
                             or mils)              or mils)
--------------------------  ====================  ====================
Lower Left Mounting Hole    200                   200
Lower Right Mounting Hole   3350                  200
Upper Left Mounting Hole    350                   3575
Upper Right Mounting Hole   3250                  3575
J7 pin 1                    3300                  3200
</table>
<image STX104_Mechanical_RevH_22AUG2009b>

@@Ordering Information
\ \ 

<b>STX104 with Analog Outputs:</b>



Link: <extlink https://www.apexembeddedsystems.com/shop/pc/viewPrd.asp?idproduct=26&amp;idcategory=>STX104
16-bit Analog I/O Module with 1M sample FIFO and dual 16-bit
DACs.</extlink>



SKU: STX104-1MFIFO-DAQ



\--



<b>STX104 without Analog Outputs:</b>



Link: <extlink https://www.apexembeddedsystems.com/shop/pc/viewPrd.asp?idproduct=18&amp;idcategory=>STX104-ND
16-bit PC/104 Analog I/O Module with 1M sample FIFO without
dual 16-bit DAC</extlink>



SKU: STX104-1MFIFO-DAQ-NODAC



\----------------------------------------------------------------------



<b>For the latest drivers and technical support, please
contact us at</b>



<extlink mailto:customer.service@apexembeddedsystems.com>customer.service@apexembeddedsystems.com</extlink>



\--



<b>Product documentation can be found on our website at</b>



<extlink http://www.apexembeddedsystems.com/documentation.asp>http://www.apexembeddedsystems.com/documentation.asp</extlink>





@@SPI Configuration (Offset=80, RB='0')
Summary
SPI Configuration Register
Description
\ \ 

The SPI Module is always a master device.



Signal Routing Illustrations.

  1. <link Connector Summary, External Connector J7> digital
     \input ---\> <link Digital Input Configuration> (polarity and
     filter) ---\> SPI Module Serial Digital Input (mapping and
     polarity)

  2. SPI Module Serial Digital Output (polarity) ---\> <link Digital Output Configuration>
     (routing and polarity) ---\> <link Connector Summary, External Connector J7>
     digital output

  3. SPI Module Serial Clock Output (polarity and phase) ---\>
     <link Digital Output Configuration> (routing and polarity)
     \---\> <link Connector Summary, External Connector J7>
     digital output

  4. SPI Module Serial Chip Select Output (polarity) ---\> <link Digital Output Configuration>
     (routing and polarity) ---\> <link Connector Summary, External Connector J7>
     digital output

The clock and data relationships are illustrated at <extlink http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus>http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</extlink>.
Register Layout
\ \ 

<b>Index=0x50, Byte 0, Word 0. RB='1'.</b>
<table>
D7          D6   D5     D4     D3        D2        D1         D0
==========  ===  =====  =====  ========  ========  =========  =========
SDIO_WRAP   X    CSB1   CSB0   SDO_POL   SDI_POL   SCLK_PHA   SCLK_POL
</table>

<b>Index=0x51, Byte 1, Word 0. RB='1'.</b>
<table>
D15   D14   D13        D12        D11    D10    D9     D8
====  ====  =========  =========  =====  =====  =====  =====
X     X     SDI_MAP1   SDI_MAP0   ECD3   ECD2   ECD1   ECD0
</table>
Bit Definitions
<table>
NAME           DIRECTION   DEFAULT   \DESCRIPTION
=============  ==========  ========  ----------------------------------------------------------
X              \-          \-        Don't care
SDI_MAP[1:0]   rw          00        SPI Interface Serial Data Input Mapping. This mapping
                                      occurs after the digital input configuration.<p />00 =
                                      DIN0 (High Voltage or High Gain Buffer Board)<p />01 =
                                      DIN1<p />10 = DIN2<p />11 = DIN3
ECD[3:0]       rw          0000      SPI Interface End Cycle Delay. This is the delay or
                                      recovery time from the last byte transmitted to the next
                                      byte to be transmitted.<p />delay_between_words_ns = 25nS
                                      \* 4 + ECD * Half_Clock_Interval_ns;
SDIO_WRAP      rw          0         SPI Interface Serial Data Wrap. The purpose of the
                                      SDIO_WRAP is to wrap the serial data out back into the
                                      serial data input. This can be useful in testing software
                                      as all data transmitted is reflected back to the
                                      receiver. The transmitted data will be delivered to any
                                      defined output. Any external SDI input is ignored.<p />0
                                      = Normal<p />1 = Serial Data Out (SDO) is tied to Serial
                                      Data Input (SDI)
CSB[1:0]       rw          00        SPI interface Chip Select Behavior.<p />00 = Software
                                      Controlled Chip Select (default)<p />01 = Chip Select
                                      becomes active at the TX buffer commit and remains active
                                      until the transmit FIFO becomes empty. This is a way to
                                      transmit mulitple bytes with chip select remaining active
                                      until all bytes transmitted.<p />10 = Chip select becomes
                                      active at the TX buffer commit and will toggle every
                                      8-bits (data byte) until buffer empty. Goes inactive when
                                      buffer is empty.<p />11 = Chip select becomes active at
                                      the TX buffer commit and will toggle every 16-bits (two
                                      data byte) until buffer empty. Goes inactive when buffer
                                      is empty, even if an odd number of bytes transmitted.
SDO_POL        rw          0         SPI Interface Serial Data Output Polarity.<p />0 =
                                      non-inverted<p />1 = inverted
SDI_POL        rw          0         SPI Interface Serial Data Input Polarity.<p />0 =
                                      non-inverted<p />1 = inverted
SCLK_PHA       rw          0         SPI Interface Clock Phase.<p />0 =<p />1 =
SCLK_POL       rw          0         SPI Interface Clock Polarity.<p />0 = non-inverted<p />1
                                      = inverted
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI Half Clock Interval (Offset=82, RB='1')
Summary
Serial Interface Half Clock Interval Timer Register
Description
This register sets the time interval of SPI half clock
intervals.





SPI_Half_Clock_Interval_ns = 25 nS * ( 4 + SCHI )



The range is 100nS (SCHI=0) to 102,475nS (SCHI=4095).





Overall SPI clock frequency can be calculated



SPI_Clock_Frequency = 1 / ( 2 * SPI_Half_Clock_Interval ).



SCHI = ( 1 - 200 nS * SPI_Clock_Frequency ) / ( 50 nS *
SPI_Clock_Frequency )


Register Layout
\ \ 

<b>Index=0x52, Byte 0, Word 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
SHCI7   SHCI6   SHCI5   SHCI4   SHCI3   SHCI2   SHCI1   SHCI0
</table>

<b>Index=0x53, Byte 1, Word 0. RB='1'.</b>
<table>
D15   D14   D13   D12   D11      D10      D9      D8
====  ====  ====  ====  =======  =======  ======  ======
X     X     X     X     SHCI11   SHCI10   SHCI9   SHCI8
</table>
Bit Definitions
<table>
NAME         DIRECTION   DEFAULT   \DESCRIPTION
===========  ==========  ========  ----------------------------
X            \-          \-        Don't Care
SHCI[11:0]   rw          0x000     Serial Interface Half-Clock
                                    Interval
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI Transmit FIFO Data (Offset=84, RB='1')
Summary
SPI Transmit FIFO Data
Description
If SPI_Status.SPI_TX_FULL=0, then space is available in the
transmit FIFO buffer to accept more data to be transmitted.



If SPI_Status.SPI_TX_EMPTY=1, then the FIFO transmit buffer
is completely empty.



If SPI_Status.SPI_RX_FULL='1', then no more data will be
transmitted.
Register Layout
<b>Index=0x54, Byte 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
SFTX7   SFTX6   SFRX5   SFTX4   SFTX3   SFTX2   SFTX1   SFTX0
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ------------------------------------
SFTX[7:0]   r           \-        Serial Interface Transmit FIFO Data
                                   buffer
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI Receive FIFO Data (Offset=84, RB='1')
Summary
SPI Receive FIFO Data
Description
If SPI_Status.SPI_RX_EMPTY=0, then data is available to be
read out at this port; otherwise the buffer is empty.



If SPI_Status.SPI_RX_FULL=1, then the data FIFO is full and
no more data will be transmitted/received.



If SPI_Status.SPI_RX_FULL='1', then no more data will be
transmitted.
Register Layout
<b>Index=0x54, Byte 0. RB='1'.</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
SFRX7   SFRX6   SFRX5   SFRX4   SFRX3   SFRX2   SFRX1   SFRX0
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  -----------------------------------
SFRX[7:0]   r           \-        Serial Interface Receive FIFO Data
                                   buffer
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI Status (Offset=85, RB='1')
Summary
SPI Interface Status Register
Description
Provides the status of the transmit and receive FIFO buffers.
It also shows the value of SDI (for debugging) and the state
of the chip select or commit depending on its use.
Register Layout
\ \ 

<b>Index=0x55, RB='1'.</b>
<table>
D7            D6             D5   D4        D3            D2             D1   D0
============  =============  ===  ========  ============  =============  ===  ===========
SPI_RX_FULL   SPI_RX_EMPTY   X    SPI_SDI   SPI_TX_FULL   SPI_TX_EMPTY   X    SCS_COMMIT
</table>
Bit Definitions
<table>
NAME           DIRECTION   DEFAULT   \DESCRIPTION
=============  ==========  ========  -----------------------------------------------------
SPI_SDI        r           SDI       Serial Interface Serial Data Input. This bit can be
                                      monitored to observe a conversion complete or data
                                      ready signaling from an external SPI device.
X              \-          \-        Don't Care
SPI_RX_FULL    r           0         Serial Interface Receive FIFO Full Flag<p />0 = FIFO
                                      not Full<p />1 = FIFO full
SPI_RX_EMPTY   r           1         Serial Interface Receive FIFO Empty Flag<p />0 =
                                      FIFO not empty<p />1 = FIFO empty
SPI_TX_FULL    r           0         Serial Interface Transmit FIFO Full Flag<p />0 =
                                      FIFO not Full<p />1 = FIFO full
SPI_TX_EMPTY   r           1         Serial Interface Transmit FIFO Empty Flag<p />0 =
                                      FIFO not empty<p />1 = FIFO empty
SCS_COMMIT     r           0         Software Settable Chip Select or Buffer Commit
                                      status<p />0 = inactive<p />1 = active
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>


@@Analog Input Polarity (Index=33, RB='1')
Summary
Analog Input Polarity Register
Description
This register is used to control the analog input polarity
for each of the given analog input channels. The
"aicfg.AI_ENCODE" is the <link Analog Input General Configuration>
Register AI_ENCODE bit. The "aicfg.AI_ENCODE_BEHAVIOR[1:0]"
is the <link Analog Input General Configuration> Register
AI_ENCODE_BEHAVIOR[1:0] bits. The "aipol(x)" is the polarity
bit for a given analog input channel as defined within the
bit pattern for the Analog Input Polarity Register.

<table>
aicfg.AI_ENCODE   aicfg.AI_ENCODE_BEHAVIOR[1:0]   aipol(x)   Resulting Analog Input Bit Encoding at
                                                              Channel x<p />(shown most negative to most
                                                              positive word encoding)
================  ==============================  =========  -------------------------------------------------
0                 X0                              X          Straight Binary: 0x0000 - 0xFFFF (default
                                                              legacy mode)
0                 X1                              0          Straight Binary: 0x0000 - 0xFFFF
0                 X1                              1          Bitwise inverted or one's complement
                                                              Straight Binary: 0xFFFF - 0x0000
1                 00                              X          Two's Complement: 0x8000 to 0xFFFF, then
                                                              0x0000 to 0x7FFFF
1                 01                              0          Twos Complement: 0x8001 to 0xFFFF, then
                                                              0x0000 to 0x7FFFF (0x8000 re-assigned to
                                                              0x8001)
1                 01                              1          \-1 * Twos Complement: 0X7FFF to 0x0000,
                                                              then 0xFFFF to 0x8001 (0x8000 re-assigned to
                                                              0x8001)
1                 1X                              0          Absolute value( Two's Complement ): 0x0000
                                                              to 0x7FFFF (0x8000 re-assigned to 0x8001,
                                                              and 0x8001 to 0xFFFF multiplied by -1)
1                 1X                              1          \-1 * Absolute value( Two's Complement ): 0x8001
                                                              to 0xFFFFF (0x8000 re-assigned to 0x8001,
                                                              and 0x0001 to 0x7FFF multiplied by -1)
</table>
Register Layout
<b>Index=0x22, Byte 0. Index=0x22, Word 0. RB='1'.</b>
<table>
D7       D6       D5       D4       D3       D2       D1       D0
=======  =======  =======  =======  =======  =======  =======  =======
AIPOL7   AIPOL6   AIPOL5   AIPOL4   AIPOL3   AIPOL2   AIPOL1   AIPOL0
</table>

<b>Index=0x23, Byte 1. Index=0x22, Word 0. RB='1'.</b>
<table>
D15       D14       D13       D12       D11       D10       D9       D8
========  ========  ========  ========  ========  ========  =======  =======
AIPOL15   AIPOL14   AIPOL13   AIPOL12   AIPOL11   AIPOL10   AIPOL9   AIPOL8
</table>
Bit Definitions
\ \ 
<table>
NAME          DIRECTION   DEFAULT   \DESCRIPTION
============  ==========  ========  -------------------------------------------------------
AIPOL[15:0]   rw          0x0000    Polarity setting for each analog input channel. This
                                     allows for the bit patterns to be inverted or
                                     multiplied by -1. For each bit:<p />0 = normal<p />1 =
                                     polarity inverted (straight binary encoding) or
                                     multiply by -1 (twos complement). Please refer to the
                                     \description section for further details.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@Input Encoding (data formats)
\ \ 
