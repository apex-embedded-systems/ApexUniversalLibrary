

@@Register Set
\ \ 



@@SPI Configuration
<title SPI Configuration (Offset=10\, Bank=6)>

Summary
SPI Configuration Register
Description
The SPI Module is always a master device.

The clock and data relationships are illustrated at <extlink http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus>http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</extlink>.

* SPI Mode *
<table>
SPI MODE   Clock Polarity<p />SCLK_POL   Clock Phase<p />SCLK_PHA
=========  ============================  =========================
0          0                             0
1          0                             1
2          1                             0
3          1                             1
</table>

\NOTE: Writing to the configuration register will restart the
SPI state machine and FIFOs. This allows software a very
simple mechanism to terminate any hardware data transaction
that might be in progress and restart in a known state. In
general, this is rarely required. If on the other hand, the
FIFO size is grown to some larger depth, then having this
feature becomes essential. The restart time is 4 main clock
times (~80nS).




Register Layout
\ \ 

<b>Offset = 0xA, Bank = 6. Read/Write.</b>
<table>
D7          D6     D5     D4     D3        D2        D1         D0
==========  =====  =====  =====  ========  ========  =========  =========
SDIO_WRAP   CSB2   CSB1   CSB0   SDO_POL   SDI_POL   SCLK_PHA   SCLK_POL
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  ------------------------------------------------------------
SDIO_WRAP   rw          0         SPI Interface Serial Data Wrap. The purpose of the
                                   SDIO_WRAP is to wrap the serial data out back into the
                                   serial data input. This can be useful in testing software
                                   as all data transmitted is reflected back to the receiver.
                                   The transmitted data will be delivered to any defined
                                   \output. Any external SDI input is ignored. The chip select
                                   will be inactive to prevent bogus external writes.<p />0 =
                                   Normal<p />1 = Serial Data Out (SDO) is tied to Serial Data
                                   \Input (SDI)<p /><p />Setting SDIO_WRAP and filling the
                                   FIFO with data until full will provide a count which can be
                                   used to indicate the number of bytes that the FIFO can
                                   accept.
CSB[2:0]    rw          000       SPI interface Chip Select Behavior.<p />000 = Software
                                   Controlled Chip Select (default). Data transacted
                                   immediately upon arrival into transmit FIFO.<p />001 = Chip
                                   Select becomes active at the TX buffer commit and remains
                                   active until the transmit FIFO becomes empty. This is a way
                                   to transmit mulitple bytes with chip select remaining
                                   active until all bytes transmitted. The assumption here is
                                   that the number of bytes to exchange is no more than
                                   SPI_FIFO_SIZE, or so long as the TX FIFO does not become
                                   empty. In order for the chip select to properly <i>wrap</i>
                                   around the data the software is required to wait until the
                                   FIFO becomes empty. When the commit register is written,
                                   the exchange of SPI data begins; in other words, there is
                                   no time constraint for the software to write the data to
                                   the FIFO in preparation for the SPI data exchange.<p />010
                                   = Chip select becomes active at the TX buffer commit and
                                   will toggle every 8-bits (data byte) until buffer empty.
                                   Goes inactive when buffer is empty. Must restart/commit any
                                   time the transmit buffer has become empty.<p />011 = Chip
                                   select becomes active at the TX buffer commit and will
                                   toggle every 16-bits (two data byte) until buffer empty.
                                   Goes inactive when buffer is empty, even if an odd number
                                   of bytes transmitted. The assumption here is that the
                                   number of bytes to exchange is no more than SPI_FIFO_SIZE.
                                   In order for the chip select to properly <i>wrap</i> around
                                   the data the software is required to wait until the FIFO
                                   has at least two available byte locations to write. When
                                   the commit register is written, the exchange of SPI data
                                   begins; in other words, there is no time constraint for the
                                   software to write the data to the FIFO in preparation for
                                   the SPI data exchange. When the software writes data to the
                                   FIFO it must ensure that 2-bytes are written in close time
                                   proximity so that the chip select operates correctly. The
                                   number of 16-bit words that can be written to the FIFO
                                   prior to commit is SPI_FIFO_SIZE / 2.
SDO_POL     rw          0         SPI Interface Serial Data Output Polarity.<p />0 =
                                   non-inverted<p />1 = inverted
SDI_POL     rw          0         SPI Interface Serial Data Input Polarity.<p />0 =
                                   non-inverted<p />1 = inverted
SCLK_PHA    rw          0         SPI Interface Clock Phase.<p />0 = data captured on the
                                   low-to-high transition of the SPI clock, data is propagated
                                   on high-to-low clock transition.<p />1 = data captured on
                                   high-to-low transition of the SPI clock, data is propagated
                                   on the low-to-high clock transition.
SCLK_POL    rw          0         SPI Interface Clock Polarity.<p />0 = non-inverted<p />1 =
                                   inverted
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI Half Clock Interval
<title SPI Half Clock Interval (Offset=12\, Bank=6)>

Summary
Serial Interface Half Clock Interval Timer Register
Description
This register sets the time interval of SPI half clock
intervals and subsequently used to generate the serial clock
and end of cycle delay (i.e. recovery time).

<code lang="c++">
\#define CLOCK_FREQ_MHZ        50
\#define CLOCK_INTERVAL_NS     20

double         spi_half_clock_interval_sec;
double         spi_clock_fequency_hz;
double         scratch;
uint16_t       shci;                          /* spi half clock interval */

spi_half_clock_interval_sec = ( ((double) CLOCK_INTERVAL_NS) * 1.0e-9 ) * ( (double) ( 4 + schi ) )

/* The range of half clock interval is 80nS (SHCI=0) to 9,900nS (SHCI=4095)                        */

/* Overall SPI clock frequency can be calculated                                                   */

spi_clock_frequency_hz = 1 / ( 2 * spi_half_clock_interval_sec ).
spi_clock_frequency_hz = 1.0 / ( 2.0 * ( ((double) CLOCK_INTERVAL_NS) * 1.0e-9 ) * ( 4.0 + spi_half_clock_interval_sec );

/* In other words, serial clock is adjustable from 50.5 KHz to  6.25 MHz.                          */

/* typical shci calculation given desired SPI clock frequency.
scratch = ( 1.0 - ( 8.0 *  ( ((double) CLOCK_INTERVAL_NS) * 1.0e-9 ) * spi_clock_frequency_hz ) ) /
                  (  2.0 * ( ((double) CLOCK_INTERVAL_NS) * 1.0e-9 ) * spi_clock_frequency_hz );

shci = (uint16_t) scratch;


</code>
Register Layout
\ \ 

<b>Offset = 0xC, Bank = 6. Read/Write. SHCI Low Byte (LSB).</b>
<table>
D7      D6      D5      D4      D3      D2      D1      D0
======  ======  ======  ======  ======  ======  ======  ======
SHCI7   SHCI6   SHCI5   SHCI4   SHCI3   SHCI2   SHCI1   SHCI0
</table>

<b>Offset = 0xD, Bank = 6. Read/Write. SHCI High Byte (MSB).</b>
<table>
D15   D14   D13   D12   D11      D10      D9      D8
====  ====  ====  ====  =======  =======  ======  ======
X     X     X     X     SHCI11   SHCI10   SHCI9   SHCI8
</table>
Bit Definitions
<table>
NAME         DIRECTION   DEFAULT   \DESCRIPTION
===========  ==========  ========  ---------------------------
X            \-          \-        Don't Care
SHCI[11:0]   rw          0x000     Serial Half-Clock Interval
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>



<link SPI_Calculate_Half_Clock_Interval_Sec@uint16_t, SPI_Calculate_Half_Clock_Interval_Sec Function>



<link SPI_Calculate_Clock@double@double *@double *@uint16_t *, SPI_Calculate_Clock Function>

@@SPI Data
<title SPI Data (Offset=8\, Bank=7)>

Summary
SPI Transmit and Receive data FIFOs.
Description
\ \ 
Register Layout
<b>Offset = 0x8, Bank = 7. Read/Write.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
SD7   SD6   SD5   SD4   SD3   SD2   SD1   SD0
</table>
Bit Definitions
<table>
NAME      DIRECTION   DEFAULT   \DESCRIPTION
========  ==========  ========  --------------------------------------
SD[7:0]   rw          \-        Serial data transmit and receive data
                                 buffers (FIFOs).
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI Transmit FIFO Status
<title SPI Transmit FIFO Status (Offset=9\, Bank=7)>

Summary
SPI interface transmit FIFO status
Description
\ \ 

Provides the status of the transmit FIFO.
Register Layout
\ \ 

<b>Offset = 0x9, Bank = 7. Read only.</b>
<table>
D7            D6             D5   D4           D3           D2           D1           D0
============  =============  ===  ===========  ===========  ===========  ===========  ===========
SPI_TX_FULL   SPI_TX_EMPTY   X    SPI_TX_BC4   SPI_TX_BC3   SPI_TX_BC2   SPI_TX_BC1   SPI_TX_BC0
</table>
Bit Definitions
<table>
NAME             DIRECTION   DEFAULT   \DESCRIPTION
===============  ==========  ========  -----------------------------------------------------------------
X                \-          \-        Don't Care
SPI_TX_FULL      r           0         Serial Interface Transmit FIFO Full Flag<p />0 =
                                        FIFO not Full<p />1 = FIFO full
SPI_TX_EMPTY     r           1         Serial Interface Transmit FIFO Empty Flag<p />0 =
                                        FIFO not empty<p />1 = FIFO empty
SPI_TX_BC[4:0]   r           00000     Serial Interface Transmit FIFO byte count that
                                        remains within the FIFO.<p />available_bytes_that_can_be_written
                                        = SPI_FIFO_SIZE - SPI_TX_BA<p />This provides and
                                        fast and easy way to determine the maximum quantity
                                        of bytes that can be written without having to
                                        constantly check FIFO empty and full flags.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI ID LSB
<title SPI ID LSB (Offset=8\, Bank=6)>

Summary
Hardware ID Least Significant Byte (LSB)
Description
\ \ 

Read both the LSB and MSB register to obtain hardware
identification. This is a 16-bit value which represents the
board and the FPGA firmware revision. Its purpose is to
assist software driver/libraries to determine how to interact
with the board.
Register Layout
<b>Offset = 0xE, Bank = don't care.</b>
<table>
D7    D6    D5    D4    D3    D2    D1    D0
====  ====  ====  ====  ====  ====  ====  ====
id7   id6   id5   id4   id3   id2   id1   id0
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  --------------
id[15..0]   r           \-        The board ID.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI ID MSB
<title SPI ID LSB (Offset=9\, Bank=6)>

Summary
Hardware ID Most Significant Byte (MSB)
Description
\ \ 

Read both the LSB and MSB register to obtain hardware
identification. This is a 16-bit value which represents the
board and the FPGA firmware revision. Its purpose is to
assist software driver/libraries to determine how to interact
with the board.
Register Layout
<b>Offset = 0xF, Bank = don't care.</b>
<table>
D7     D6     D5     D4     D3     D2     D1    D0
=====  =====  =====  =====  =====  =====  ====  ====
id15   id14   id13   id12   id11   id10   id9   id8
</table>
Bit Definitions
<table>
NAME        DIRECTION   DEFAULT   \DESCRIPTION
==========  ==========  ========  --------------
id[15..0]   r           \-        The board ID.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>

@@SPI End Cycle Delay
<title SPI End Cycle Delay (Offset=11\, Bank=6)>

Summary
SPI End Cycle Delay Register
Description
The time delay between bytes of data sent out the SPI port.
It is the time after the last bit is written.

<code lang="c++">
\#define CLOCK_PERIOD_SEC   20.0e-9


int SPI_End_Cycle_Delay_Calculate( double    spi_half_clock_interval_sec, /* calculated half-clock interval     */
                                   double    delay_request_sec,           /* requested end-delay interval       */
                                   double *  delay_actual_sec,            /*  computed actual delay             */
                                   double *  error,                       /* error between actual and desired   */
                                   uint8_t * ecd                          /* computed count                     */
                                )
{
    double        delay_between_words_sec;
    double        scratch;
    int            ecd_temp;

    /* delay_sec = CLOCK_PERIOD_SEC * 4 + ECD * spi_half_clock_interval_sec  */
    scratch = ( delay_request_sec - 4.0 * CLOCK_PERIOD_SEC ) / spi_half_clock_interval_sec;
    ecd_temp = (int) scratch;

    if ( ( ecd_temp \> 255 ) || ( ecd_temp \< 0 ) ) return -EC_SPI_ECD_OUT_OF_RANGE;

    if ( NULL != error            ) *error            = ( scratch - delay_request_sec ) / delay_request_sec;
    if ( NULL != delay_actual_sec ) *delay_actual_sec = CLOCK_PERIOD_SEC * 4.0 + ((double) ecd_temp) * spi_half_clock_interval_sec;
    if ( NULL != ecd              ) *ecd              = (uint8_t) ecd_temp;
    return SUCCESS;
}
</code>
Register Layout
\ \ 

<b>Offset = 0xA, Bank = 6. Read/Write.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
ECD7   ECD6   ECD5   ECD4   ECD3   ECD2   ECD1   ECD0
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  --------------------------------------------------------
ECD[7:0]   rw          0000      SPI Interface End Cycle Delay. This is the delay or
                                  recovery time from the last byte transmitted to the
                                  next byte to be transmitted.<p />delay_between_words_ns
                                  = 20nS * 4 + ECD * Half_Clock_Interval_ns;<p />Note:
                                  20nS is the main clock interval.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>



<link SPI_Calculate_End_Cycle_Delay@double@double@double *@double *@uint8_t *, SPI_Calculate_End_Cycle_Delay Function>

@@SPI End Cycle Delay
<title SPI End Cycle Delay (Offset=11\, Bank=6)>

Summary
SPI End Cycle Delay Register
Description
The time delay between bytes of data sent out the SPI port.
It is the time after the last bit is written.

<code lang="c++">
\#define CLOCK_PERIOD_SEC   20.0e-9


int SPI_End_Cycle_Delay_Calculate( double    spi_half_clock_interval_sec, /* calculated half-clock interval     */
                                   double    delay_request_sec,           /* requested end-delay interval       */
                                   double *  delay_actual_sec,            /*  computed actual delay             */
                                   double *  error,                       /* error between actual and desired   */
                                   uint8_t * ecd                          /* computed count                     */
                                )
{
    double        delay_between_words_sec;
    double        scratch;
    int            ecd_temp;

    /* delay_sec = CLOCK_PERIOD_SEC * 4 + ECD * spi_half_clock_interval_sec  */
    scratch = ( delay_request_sec - 4.0 * CLOCK_PERIOD_SEC ) / spi_half_clock_interval_sec;
    ecd_temp = (int) scratch;

    if ( ( ecd_temp \> 255 ) || ( ecd_temp \< 0 ) ) return -EC_SPI_ECD_OUT_OF_RANGE;

    if ( NULL != error            ) *error            = ( scratch - delay_request_sec ) / delay_request_sec;
    if ( NULL != delay_actual_sec ) *delay_actual_sec = CLOCK_PERIOD_SEC * 4.0 + ((double) ecd_temp) * spi_half_clock_interval_sec;
    if ( NULL != ecd              ) *ecd              = (uint8_t) ecd_temp;
    return SUCCESS;
}
</code>
Register Layout
\ \ 

<b>Offset = 0xA, Bank = 6. Read/Write.</b>
<table>
D7     D6     D5     D4     D3     D2     D1     D0
=====  =====  =====  =====  =====  =====  =====  =====
ECD7   ECD6   ECD5   ECD4   ECD3   ECD2   ECD1   ECD0
</table>
Bit Definitions
<table>
NAME       DIRECTION   DEFAULT   \DESCRIPTION
=========  ==========  ========  --------------------------------------------------------
ECD[7:0]   rw          0000      SPI Interface End Cycle Delay. This is the delay or
                                  recovery time from the last byte transmitted to the
                                  next byte to be transmitted.<p />delay_between_words_ns
                                  = 20nS * 4 + ECD * Half_Clock_Interval_ns;<p />Note:
                                  20nS is the main clock interval.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>



<link SPI_Calculate_End_Cycle_Delay@double@double@double *@double *@uint8_t *, SPI_Calculate_End_Cycle_Delay Function>


@@SPI Receive FIFO Status
<title SPI Receive FIFO Status (Offset=10\, Bank=7)>

Summary
SPI interface receive FIFO status
Description
\ \ 

Provides the status of the receive FIFO.
Register Layout
\ \ 

<b>Offset = 0xA, Bank = 7. Read only.</b>
<table>
D7            D6             D5   D4           D3           D2           D1           D0
============  =============  ===  ===========  ===========  ===========  ===========  ===========
SPI_RX_FULL   SPI_RX_EMPTY   X    SPI_RX_BA4   SPI_RX_BA3   SPI_RX_BA2   SPI_RX_BA1   SPI_RX_BA0
</table>
Bit Definitions
<table>
NAME             DIRECTION   DEFAULT   \DESCRIPTION
===============  ==========  ========  --------------------------------------------------
X                \-          \-        Don't Care
SPI_RX_FULL      r           0         Serial Interface Receive FIFO Full Flag<p />0 =
                                        FIFO not Full<p />1 = FIFO full
SPI_RX_EMPTY     r           1         Serial Interface Receive FIFO Empty Flag<p />0 =
                                        FIFO not empty<p />1 = FIFO empty
SPI_RX_BA[4:0]   r           00000     Serial Interface Receive FIFO bytes available
                                        within the FIFO that can be read out. This
                                        provides and fast and easy way to determine the
                                        quantity to read-out without having to constantly
                                        check FIFO empty and full flags.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>


@@SPI Receive FIFO Status
<title SPI Receive FIFO Status (Offset=10\, Bank=7)>

Summary
SPI interface receive FIFO status
Description
\ \ 

Provides the status of the receive FIFO.
Register Layout
\ \ 

<b>Offset = 0xA, Bank = 7. Read only.</b>
<table>
D7            D6             D5   D4           D3           D2           D1           D0
============  =============  ===  ===========  ===========  ===========  ===========  ===========
SPI_RX_FULL   SPI_RX_EMPTY   X    SPI_RX_BA4   SPI_RX_BA3   SPI_RX_BA2   SPI_RX_BA1   SPI_RX_BA0
</table>
Bit Definitions
<table>
NAME             DIRECTION   DEFAULT   \DESCRIPTION
===============  ==========  ========  --------------------------------------------------
X                \-          \-        Don't Care
SPI_RX_FULL      r           0         Serial Interface Receive FIFO Full Flag<p />0 =
                                        FIFO not Full<p />1 = FIFO full
SPI_RX_EMPTY     r           1         Serial Interface Receive FIFO Empty Flag<p />0 =
                                        FIFO not empty<p />1 = FIFO empty
SPI_RX_BA[4:0]   r           00000     Serial Interface Receive FIFO bytes available
                                        within the FIFO that can be read out. This
                                        provides and fast and easy way to determine the
                                        quantity to read-out without having to constantly
                                        check FIFO empty and full flags.
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>





@@SPI Commit or Chip Select
<title SPI Commit or Chip Select (Offset=11\, Bank=7)>

Summary
SPI Software Buffer Commit or Chip Select.
Description
The function of this bit depends on <link SPI_Configuration>.CSB[1:0]
bits found in the <link SPI Configuration> register. See
table below for details.

<table>
SPI_CFG.CSB[2:0]   SPI Chip Select Behavior                  Data Flow               Data Flow      Data Flow   Data Flow
                                                              Status<p />SCS_STATUS   Begin          End         Comment
=================  ----------------------------------------  ----------------------  -------------  ----------  --------------
000                Completely software controlled. The       SPI chip                Data           Any time    FIFO data
                    chip select is set or cleared by the      select:<p />0           transferred    that the    stuffing
                    SCS_COMMIT bit. As a result, in           = inactive<p />1        any time       transmit    has no time
                    general, the chip select is very          = active                there is       FIFO        restrictions.
                    loosely 'wrapped' around the data,                                data in the    becomes     
                    however the chip select timing will                               transmit       empty.      
                    not be accurate and will not provide                              FIFO.                      
                    consistent timing. This is most                                                              
                    useful, if you need to keep the chip                                                         
                    select active for multiple buffer                                                            
                    lengths and chip select timing is not                                                        
                    critical (i.e. FRAM memory read/write                                                        
                    transactions fall into this                                                                  
                    category).<p />                                                                              
001                Automatic. Remains active once the        Commit                  Writing any    Any time    So long as
                    transmit buffer is committed and will     status:<p />0           value to       that the    the FIFO is
                    remain active until the buffer            =                       SPI Commit     transmit    not empty
                    becomes empty. It is tightly              inactive/done.<p />1    Register       FIFO        and you are
                    'wrapped' around the SPI data and         = buffer                begins         becomes     stuffing
                    clock at the beginning of data            transmit in             transmission   empty.      data the
                    transmission and upon transmit FIFO       progress.               of any data                chip select
                    empty.<p /><p />This mode can be used                             in the                     will remain
                    to transmit odd size data that must                               FIFO. This                 active.
                    be 'wrapped' with the chip select.                                is the                     
                    \Examples of these include certain                                buffer                     
                    A/D converters and so on. The idea                                commit                     
                    here is to write the bytes to the                                 command.                   
                    transmit FIFO, commit the data and                                                           
                    wait for the FIFO to become empty or                                                         
                    test the commit status. Then send                                                            
                    another packet in the same way. The                                                          
                    only restriction is that the packet                                                          
                    \size is limited to SPI_FIFO_SIZE.<p />                                                      
010                Automatic. Remains active for 8           Commit                  Writing any    Any time    Begins a
                    clocks or one byte. It is tightly         status:<p />0           value to       that the    time of
                    'wrapped' around the SPI data and         =                       SPI Commit     transmit    buffer
                    clock. In other words, the chips          inactive/done.<p />1    Register       FIFO        commit,
                    select is active for exactly one byte     = buffer                begins         becomes     ends when
                    transmission and then goes inactive.      transmit in             transmission   empty.      buffer is
                    For example, if 3 bytes are               progress.               of any data                empty.
                    committed, then the chip select will                              in the                     
                    transition three times, once around                               FIFO. This                 
                    each byte exchanged.                                              is the                     
                                                                                      buffer                     
                                                                                      commit                     
                                                                                      command.                   
011                Automatic. Remains active for 16          Commit                  Writing any    Any time    Begins a
                    clocks or two bytes, or one byte if       status:<p />0           value to       that the    time of
                    the buffer becomes empty. It is           =                       SPI Commit     transmit    buffer
                    tightly 'wrapped' around the SPI data     inactive/done.<p />1    Register       FIFO        commit,
                    and clock.<p />It is important to         = buffer                begins         becomes     ends when
                    avoid writing odd numbers of bytes as     transmit in             transmission   empty.      buffer is
                    it is possible to end up with a           progress.               of any data                empty.
                    condition that the last byte to be                                in the                     
                    exchange and it the last byte                                     FIFO. This                 
                    remaining in the FIFO, then that byte                             is the                     
                    will be individually tightly wrapped                              buffer                     
                    by the chip select. This can be                                   commit                     
                    totally avoided, by simply computing                              command.                   
                    the number of 16-bit words that can                                                          
                    be safely written to the transmit                                                            
                    FIFO each time.<p />                                                                         
</table>

This register sets or clears the serial interface chip
select, if the chip select is under software control or <link SPI_Configuration>.SCSB[1:0]="00"
(Refer to <link SPI Configuration>).
Register Layout
\ \ 

<b>Offset = 0xB, Bank = 7. Write only.</b>
<table>
D7   D6   D5   D4   D3   D2   D1   D0
===  ===  ===  ===  ===  ===  ===  ===========
X    X    X    X    X    X    X    SCS_COMMIT
</table>

<b>Offset = 0xB, Bank = 7. Read only.</b>
<table>
D7   D6   D5   D4   D3   D2   D1   D0
===  ===  ===  ===  ===  ===  ===  ===========
X    X    X    X    X    X    X    SCS_STATUS
</table>
Bit Definitions
<table>
NAME         DIRECTION   DEFAULT   \DESCRIPTION
===========  ==========  ========  ---------------------------------------------------------------
X            \-          \-        Don't Care
SCS_COMMIT   w           0         Software Settable Chip Select or Buffer Commit Strobe
                                    bit.<p />0 = inactive<p />1 = active
SCS_STATUS   r           0         SPI chip select when SPI_Configuration.CSB[2:0]="000":<p />0
                                    = inactive chip select<p />1 = active chip select<p /><p />SPI
                                    chip select when SPI_Configuration.CSB[2:0] !="000":<p />0
                                    = inactive/done.<p />1 = buffer transmit in progress,
                                    can except more data under certain conditions.<p />
</table>
Example
\ \ 
See Also
<link Summary, Register Summary>


