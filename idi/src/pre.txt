# 1 "idi.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "idi.c"
# 65 "idi.c"
typedef int BOOL;


enum { FALSE = 0, TRUE = 1 };
# 108 "idi.c"
enum
{
 ID_DIN = 0x8012,
 ID_SPI = 0x8013,
 ID_DOUT = 0x8021,
 ID_IAI = 0x8030
};






enum
{
 ID_IDI48 = 0,
 ID_IDO48 = 1,
 ID_IAI16 = 2,
 ID_ARM32 = 3,
 ID_BOARD_UNKNOWN = 99
};
# 195 "idi.c"
typedef enum
{
 SUCCESS = 0, EC_BUFFER_TOO_LARGE = 1, EC_DIRECTION = 2, EC_PARAMETER = 3, EC_NOT_FOUND = 4, EC_PARAMETER_MISSING = 5, EC_SYNTAX = 6, EC_HEX_DUMP_COUNT = 7, EC_INIT_FILE = 8, EC_BANK = 9, EC_APP_TERMINATE = 10, EC_NOT_IMPLEMENTED = 11, EC_CHANNEL = 12, EC_MISSING_DATA = 13, EC_BUSY = 16, EC_INTERRUPT_UNAVAILABLE = 21, EC_INTR_ERROR = 22, EC_SPI_ECD_OUT_OF_RANGE = 40, EC_SPI_HALF_CLOCK_OUT_OF_RANGE = 41, EC_SPI_CSB_OUT_OF_RANGE = 42, EC_SPI_NOT_FOUND = 43, EC_SPI_BUFFER_SIZE_ODD = 44, EC_SPI_BUFFER_SIZE = 45, EC_SPI_OBJECT_SIZE = 46, EC_SPI_BUFFER_MISMATCH = 47, EC_FRAM_ADDRESS_RANGE = 48, EC_TEST_FAIL = 50, EC_BOARD = 51, EC_BOARD_TYPE = 52, EC_REGISTER_ADDRESS_EXCEEDED = 53, EC_EXTRA_IGNORED = 54,
} EC_ENUM;

struct ec_human_readable
{
 EC_ENUM error_code;
 const char * message;
};
# 268 "idi.c"
enum { IDI_BANK_ENUM_QTY = 10 };

enum { IDO_BANK_ENUM_QTY = 10 };

typedef enum
{
 IDI_BANK_0 = 0x00, IDI_BANK_1 = 0x40, IDI_BANK_2 = 0x80, IDI_BANK_3 = 0xC0, IDI_BANK_4 = 0x20, IDI_BANK_5 = 0x60, IDI_BANK_6 = 0xA0, IDI_BANK_7 = 0xE0, IDI_BANK_NONE = 0xFE, IDI_BANK_UNDEFINED = 0xFF,
} IDI_BANK_ENUM;

typedef enum
{
 IDO_BANK_0 = 0x00, IDO_BANK_1 = 0x40, IDO_BANK_2 = 0x80, IDO_BANK_3 = 0xC0, IDO_BANK_4 = 0x20, IDO_BANK_5 = 0x60, IDO_BANK_6 = 0xA0, IDO_BANK_7 = 0xE0, IDO_BANK_NONE = 0xFE, IDO_BANK_UNDEFINED = 0xFF,
} IDO_BANK_ENUM;

typedef enum
{
 BANK_0 = 0x00, BANK_1 = 0x40, BANK_2 = 0x80, BANK_3 = 0xC0, BANK_4 = 0x20, BANK_5 = 0x60, BANK_6 = 0xA0, BANK_7 = 0xE0, BANK_NONE = 0xFE, BANK_UNDEFINED = 0xFF,
} BANK_ENUM;
# 294 "idi.c"
struct idi_bank_info
{
 int symbol;
 const char * name;
};

struct ido_bank_info
{
 IDI_BANK_ENUM symbol;
 const char * name;
};

struct bank_info
{
 BANK_ENUM symbol;
 const char * name;
};



typedef enum
{
 REG_DIR_NONE = 0x00,
 REG_DIR_READ = 0x01,
 REG_DIR_WRITE = 0x02,
 REG_DIR_READ_WRITE = 0x03
} REG_DIR_ENUM;
# 516 "idi.c"
typedef enum
{
 IDI_DI_GROUP0 = ( ( (0 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DI_GROUP1 = ( ( (1 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DI_GROUP2 = ( ( (2 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DI_GROUP3 = ( ( (3 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DI_GROUP4 = ( ( (4 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DI_GROUP5 = ( ( (5 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BY_GROUP = ( ( (6 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_PEND_GROUP0 = ( ( (7 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_PEND_GROUP1 = ( ( (8 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_PEND_GROUP2 = ( ( (9 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_PEND_GROUP3 = ( ( (10 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_PEND_GROUP4 = ( ( (11 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_PEND_GROUP5 = ( ( (12 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_CLEAR_GROUP0 = ( ( (13 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_CLEAR_GROUP1 = ( ( (14 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_CLEAR_GROUP2 = ( ( (15 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_CLEAR_GROUP3 = ( ( (16 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_CLEAR_GROUP4 = ( ( (17 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_CLEAR_GROUP5 = ( ( (18 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_BANK = ( ( (19 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ID_LSB = ( ( (20 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ID_MSB = ( ( (21 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ZERO0 = ( ( (22 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ZERO1 = ( ( (23 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ZERO2 = ( ( (24 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ZERO3 = ( ( (25 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ZERO4 = ( ( (26 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_ZERO5 = ( ( (27 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DATECODE0 = ( ( (28 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DATECODE1 = ( ( (29 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DATECODE2 = ( ( (30 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_DATECODE3 = ( ( (31 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_EDGE_GROUP0 = ( ( (32 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_EDGE_GROUP1 = ( ( (33 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_EDGE_GROUP2 = ( ( (34 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_EDGE_GROUP3 = ( ( (35 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_EDGE_GROUP4 = ( ( (36 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_EDGE_GROUP5 = ( ( (37 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BIT_GROUP0 = ( ( (38 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BIT_GROUP1 = ( ( (39 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BIT_GROUP2 = ( ( (40 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BIT_GROUP3 = ( ( (41 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BIT_GROUP4 = ( ( (42 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_INTR_BIT_GROUP5 = ( ( (43 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_ID_LSB = ( ( (44 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_ID_MSB = ( ( (45 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_CONFIG = ( ( (46 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_ECD = ( ( (47 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_HCI_LSB = ( ( (48 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_HCI_MSB = ( ( (49 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_DATA = ( ( (50 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_TX_STATUS = ( ( (51 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_RX_STATUS = ( ( (52 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_SPI_COMMIT = ( ( (53 & 0xFF) << 8 ) | (0 & 0xFF) ), IDI_UNDEFINED = ( ( (54 & 0xFF) << 8 ) | (0 & 0xFF) ),
} IDI_REG_ENUM;


typedef enum
{
 IDO_DO_GROUP0 = ( ( (0 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_DO_GROUP1 = ( ( (1 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_DO_GROUP2 = ( ( (2 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_DO_GROUP3 = ( ( (3 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_DO_GROUP4 = ( ( (4 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_DO_GROUP5 = ( ( (5 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_BANK = ( ( (6 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_ID_LSB = ( ( (7 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_ID_MSB = ( ( (8 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_ID_LSB = ( ( (9 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_ID_MSB = ( ( (10 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_CONFIG = ( ( (11 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_ECD = ( ( (12 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_HCI_LSB = ( ( (13 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_HCI_MSB = ( ( (14 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_DATA = ( ( (15 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_TX_STATUS = ( ( (16 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_RX_STATUS = ( ( (17 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_SPI_COMMIT = ( ( (18 & 0xFF) << 8 ) | (0 & 0xFF) ), IDO_UNDEFINED = ( ( (19 & 0xFF) << 8 ) | (0 & 0xFF) ),
} IDO_REG_ENUM;


struct idi_reg_definition
{
 IDI_REG_ENUM symbol;
 REG_DIR_ENUM direction;
 IDI_BANK_ENUM bank;
 uint16_t physical_offset;
 char * symbol_name;
 char * acronym;
};


struct ido_reg_definition
{
 IDO_REG_ENUM symbol;
 REG_DIR_ENUM direction;
 IDO_BANK_ENUM bank;
 uint16_t physical_offset;
 char * symbol_name;
 char * acronym;
};



struct reg_definition
{
 int symbol;
 REG_DIR_ENUM direction;
 int bank;
 uint16_t physical_offset;
 char * symbol_name;
 char * acronym;
};


typedef enum
{
 CSB_SOFTWARE = 0,
 CSB_BUFFER = 1,
 CSB_uint8_t = 2,
 CSB_uint16_t = 3
} SPI_CSB_ENUM;


enum { SPI_FIFO_SIZE = 16 - 1 };


struct spi_cfg
{
 BOOL sdio_wrap;
 BOOL sdo_polarity;
 BOOL sdi_polarity;
 BOOL sclk_phase;
 BOOL sclk_polarity;
 SPI_CSB_ENUM chip_select_behavior;
 uint8_t end_cycle_delay;
 uint16_t half_clock_interval;

 double clock_hz;
 double end_delay_ns;
};

struct spi_status
{
 BOOL tx_status;
 BOOL full;
 BOOL empty;
 int fifo_size;
 int fifo_count;
};
# 612 "idi.c"
struct din_cfg
{
 struct
 {
  BOOL falling_edge;
  BOOL interrupt_enable;
 } chan[( 8 * 6 )];
};

struct dout_cfg
{
 struct
 {
  BOOL value;
 } chan[( 8 * 6 )];
};
# 641 "idi.c"
struct spi_dataset
{
 uint16_t id;
 struct spi_cfg cfg;


 uint8_t fram_block[256];




 uint8_t tx_buffer[256];
 uint8_t rx_buffer[256];
};


struct idi_dataset
{


 BOOL quit_application;
 uint16_t base_address;
 IDI_BANK_ENUM bank_previous;

 BOOL io_simulate;
 BOOL io_report;
 const char * svn_revision_string;
 struct spi_dataset spi;


 char message[256];



 unsigned int irq_number;



 BOOL irq_please_install_handler_request;
 BOOL irq_handler_active;
 size_t irq_quantity;
 size_t volatile irq_count;
 size_t irq_count_previous;





 uint8_t volatile isr_pending_list[6];



 struct din_cfg din_cfg;

 struct
 {
  BOOL used;
  int address;
  IDI_REG_ENUM location;
  uint8_t value;
 } reg_init[16];

};


struct ido_dataset
{


 BOOL quit_application;
 uint16_t base_address;
 IDI_BANK_ENUM bank_previous;

 BOOL io_simulate;
 BOOL io_report;
 const char * svn_revision_string;
 struct spi_dataset spi;


 char message[256];


 unsigned int irq_number;



 BOOL irq_please_install_handler_request;
 BOOL irq_handler_active;
 size_t irq_quantity;
 size_t volatile irq_count;
 size_t irq_count_previous;





 uint8_t volatile isr_pending_list[6];



 struct dout_cfg dout_cfg;

 struct
 {
  BOOL used;
  int address;
  IDO_REG_ENUM location;
  uint8_t value;
 } reg_init[16];

};
# 760 "idi.c"
struct board_dataset
{


 BOOL quit_application;
 uint16_t base_address;
 int bank_previous;
 BOOL io_simulate;
 BOOL io_report;
 const char * svn_revision_string;
 struct spi_dataset spi;
};
# 780 "idi.c"
static const char svn_revision_string[] = { "$Date: 2015-08-03 13:35:01 -0500 (Mon, 03 Aug 2015) $" };


const struct ec_human_readable ec_human_readable[] =
{
  { 0, "" }, { 1, "buffer too large" }, { 2, "direction" }, { 3, "parameter" }, { 4, "not found" }, { 5, "missing parameter" }, { 6, "syntax error" }, { 7, "hex dump count" }, { 8, "write init file failed" }, { 9, "bank not found" }, { 10, "terminated by user" }, { 11, "function not implemented" }, { 12, "channel range" }, { 13, "missing data" }, { 16, "interrupt busy" }, { 21, "interrupt not available" }, { 22, "interrupt error" }, { 40, "SPI ECD range" }, { 41, "SPI half clock range" }, { 42, "SPI CSB range" }, { 43, "SPI not found" }, { 44, "buffer size odd" }, { 45, "buffer size out of range" }, { 46, "spi tx/rx object size" }, { 47, "spi buffer mismatch" }, { 48, "fram address range" }, { 50, "test fail" }, { 51, "board invalid" }, { 52, "board type invalid" }, { 53, "register address exceeded" }, { 54, "extra ignored" },
  { 0, NULL }
};



static const struct idi_bank_info idi_bank_info[] =
{
  { IDI_BANK_0, "IDI_BANK_0" }, { IDI_BANK_1, "IDI_BANK_1" }, { IDI_BANK_2, "IDI_BANK_2" }, { IDI_BANK_3, "IDI_BANK_3" }, { IDI_BANK_4, "IDI_BANK_4" }, { IDI_BANK_5, "IDI_BANK_5" }, { IDI_BANK_6, "IDI_BANK_6" }, { IDI_BANK_7, "IDI_BANK_7" }, { IDI_BANK_NONE, "IDI_BANK_NONE" }, { IDI_BANK_UNDEFINED, "IDI_BANK_UNDEFINED" },
  { BANK_UNDEFINED, NULL }
};

static const struct ido_bank_info ido_bank_info[] =
{
  { IDO_BANK_0, "IDO_BANK_0" }, { IDO_BANK_1, "IDO_BANK_1" }, { IDO_BANK_2, "IDO_BANK_2" }, { IDO_BANK_3, "IDO_BANK_3" }, { IDO_BANK_4, "IDO_BANK_4" }, { IDO_BANK_5, "IDO_BANK_5" }, { IDO_BANK_6, "IDO_BANK_6" }, { IDO_BANK_7, "IDO_BANK_7" }, { IDO_BANK_NONE, "IDO_BANK_NONE" }, { IDO_BANK_UNDEFINED, "IDO_BANK_UNDEFINED" },
  { BANK_UNDEFINED, NULL }
};



static const struct idi_reg_definition idi_reg_definition[] =
{
  { ( ( (0 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 0, "IDI_DI_GROUP0", "dig0" }, { ( ( (1 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 1, "IDI_DI_GROUP1", "dig1" }, { ( ( (2 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 2, "IDI_DI_GROUP2", "dig2" }, { ( ( (3 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 3, "IDI_DI_GROUP3", "dig3" }, { ( ( (4 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 4, "IDI_DI_GROUP4", "dig4" }, { ( ( (5 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 5, "IDI_DI_GROUP5", "dig5" }, { ( ( (6 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 6, "IDI_INTR_BY_GROUP", "isbg" }, { ( ( (7 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_3, 8, "IDI_PEND_GROUP0", "p0" }, { ( ( (8 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_3, 9, "IDI_PEND_GROUP1", "p1" }, { ( ( (9 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_3, 10, "IDI_PEND_GROUP2", "p2" }, { ( ( (10 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_3, 11, "IDI_PEND_GROUP3", "p3" }, { ( ( (11 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_3, 12, "IDI_PEND_GROUP4", "p4" }, { ( ( (12 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_3, 13, "IDI_PEND_GROUP5", "p5" }, { ( ( (13 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_WRITE, IDI_BANK_3, 8, "IDI_CLEAR_GROUP0", "c0" }, { ( ( (14 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_WRITE, IDI_BANK_3, 9, "IDI_CLEAR_GROUP1", "c1" }, { ( ( (15 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_WRITE, IDI_BANK_3, 10, "IDI_CLEAR_GROUP2", "c2" }, { ( ( (16 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_WRITE, IDI_BANK_3, 11, "IDI_CLEAR_GROUP3", "c3" }, { ( ( (17 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_WRITE, IDI_BANK_3, 12, "IDI_CLEAR_GROUP4", "c4" }, { ( ( (18 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_WRITE, IDI_BANK_3, 13, "IDI_CLEAR_GROUP5", "c5" }, { ( ( (19 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_NONE, 7, "IDI_BANK", "bank" }, { ( ( (20 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 14, "IDI_ID_LSB", "idlsb" }, { ( ( (21 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_NONE, 15, "IDI_ID_MSB", "idmsb" }, { ( ( (22 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 8, "IDI_ZERO0", "zb0" }, { ( ( (23 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 9, "IDI_ZERO1", "zb1" }, { ( ( (24 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 10, "IDI_ZERO2", "zb2" }, { ( ( (25 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 11, "IDI_ZERO3", "zb3" }, { ( ( (26 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 12, "IDI_ZERO4", "zb4" }, { ( ( (27 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 13, "IDI_ZERO5", "zb5" }, { ( ( (28 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 8, "IDI_DATECODE0", "dc0" }, { ( ( (29 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 9, "IDI_DATECODE1", "dc1" }, { ( ( (30 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 10, "IDI_DATECODE2", "dc2" }, { ( ( (31 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_0, 11, "IDI_DATECODE3", "dc3" }, { ( ( (32 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_1, 8, "IDI_EDGE_GROUP0", "ep0" }, { ( ( (33 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_1, 9, "IDI_EDGE_GROUP1", "ep1" }, { ( ( (34 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_1, 10, "IDI_EDGE_GROUP2", "ep2" }, { ( ( (35 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_1, 11, "IDI_EDGE_GROUP3", "ep3" }, { ( ( (36 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_1, 12, "IDI_EDGE_GROUP4", "ep4" }, { ( ( (37 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_1, 13, "IDI_EDGE_GROUP5", "ep5" }, { ( ( (38 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_2, 8, "IDI_INTR_BIT_GROUP0", "ibe0" }, { ( ( (39 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_2, 9, "IDI_INTR_BIT_GROUP1", "ibe1" }, { ( ( (40 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_2, 10, "IDI_INTR_BIT_GROUP2", "ibe2" }, { ( ( (41 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_2, 11, "IDI_INTR_BIT_GROUP3", "ibe3" }, { ( ( (42 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_2, 12, "IDI_INTR_BIT_GROUP4", "ibe4" }, { ( ( (43 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_2, 13, "IDI_INTR_BIT_GROUP5", "ibe5" }, { ( ( (44 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_6, 8, "IDI_SPI_ID_LSB", "sidlsb" }, { ( ( (45 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_6, 9, "IDI_SPI_ID_MSB", "sidmsb" }, { ( ( (46 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_6, 10, "IDI_SPI_CONFIG", "scfg" }, { ( ( (47 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_6, 11, "IDI_SPI_ECD", "secd" }, { ( ( (48 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_6, 12, "IDI_SPI_HCI_LSB", "shclsb" }, { ( ( (49 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_6, 13, "IDI_SPI_HCI_MSB", "shcmsb" }, { ( ( (50 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_7, 8, "IDI_SPI_DATA", "sdata" }, { ( ( (51 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_7, 9, "IDI_SPI_TX_STATUS", "stxf" }, { ( ( (52 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDI_BANK_7, 10, "IDI_SPI_RX_STATUS", "srxf" }, { ( ( (53 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDI_BANK_7, 11, "IDI_SPI_COMMIT", "scmt" }, { ( ( (54 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_NONE, IDI_BANK_UNDEFINED, 0, "IDI_UNDEFINED", "" },
};

static const struct ido_reg_definition ido_reg_definition[] =
{
  { ( ( (0 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 0, "IDO_DO_GROUP0", "dog0" }, { ( ( (1 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 1, "IDO_DO_GROUP1", "dog1" }, { ( ( (2 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 2, "IDO_DO_GROUP2", "dog2" }, { ( ( (3 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 3, "IDO_DO_GROUP3", "dog3" }, { ( ( (4 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 4, "IDO_DO_GROUP4", "dog4" }, { ( ( (5 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 5, "IDO_DO_GROUP5", "dog5" }, { ( ( (6 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_NONE, 7, "IDO_BANK", "bank" }, { ( ( (7 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDO_BANK_NONE, 14, "IDO_ID_LSB", "idlsb" }, { ( ( (8 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDO_BANK_NONE, 15, "IDO_ID_MSB", "idmsb" }, { ( ( (9 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDO_BANK_6, 8, "IDO_SPI_ID_LSB", "sidlsb" }, { ( ( (10 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDO_BANK_6, 9, "IDO_SPI_ID_MSB", "sidmsb" }, { ( ( (11 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_6, 10, "IDO_SPI_CONFIG", "scfg" }, { ( ( (12 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_6, 11, "IDO_SPI_ECD", "secd" }, { ( ( (13 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_6, 12, "IDO_SPI_HCI_LSB", "shclsb" }, { ( ( (14 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_6, 13, "IDO_SPI_HCI_MSB", "shcmsb" }, { ( ( (15 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_7, 8, "IDO_SPI_DATA", "sdata" }, { ( ( (16 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDO_BANK_7, 9, "IDO_SPI_TX_STATUS", "stxf" }, { ( ( (17 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ, IDO_BANK_7, 10, "IDO_SPI_RX_STATUS", "srxf" }, { ( ( (18 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_READ_WRITE, IDO_BANK_7, 11, "IDO_SPI_COMMIT", "scmt" }, { ( ( (19 & 0xFF) << 8 ) | (0 & 0xFF) ), REG_DIR_NONE, IDO_BANK_UNDEFINED, 0, "IDO_UNDEFINED", "" },
};




struct idi_dataset idi_ds;

struct ido_dataset ido_ds;
# 831 "idi.c"
struct board_definition
{
 const void * bank_info;
 const void * definition;
 const void * dataset;
 const int bank_register_symbol;
};

static struct board_definition board_definition[] =
{
 { (const void *) idi_bank_info, (const void *) idi_reg_definition, (const void *) &idi_ds, IDI_BANK },
 { (const void *) ido_bank_info, (const void *) ido_reg_definition, (const void *) &ido_ds, IDO_BANK },
 { NULL, NULL, NULL, IDO_BANK_NONE }
};


static int global_board_id = ID_IDI48;
static BOOL global_loop_command = 0;
static int global_loop_count = 0;
static int global_loop_count_counter = 0;
static int global_loop_delay_ms = 0;
static BOOL global_irq_please_install_handler_request = 0;
# 869 "idi.c"
static const char * IDI_Bank_Symbol_To_Name( struct idi_bank_info * info, IDI_BANK_ENUM bank )
{
 int index;

 switch( bank )
 {
  case IDI_BANK_0: index = 0; break;
  case IDI_BANK_1: index = 1; break;
  case IDI_BANK_2: index = 2; break;
  case IDI_BANK_3: index = 3; break;
  case IDI_BANK_4: index = 4; break;
  case IDI_BANK_5: index = 5; break;
  case IDI_BANK_6: index = 6; break;
  case IDI_BANK_7: index = 7; break;
  case IDI_BANK_NONE: index = 8; break;
  case IDI_BANK_UNDEFINED: index = 9; break;
 }
 return info[index].name;
}

static const char * IDO_Bank_Symbol_To_Name( struct ido_bank_info * info, IDO_BANK_ENUM bank )
{
 int index;

 switch( bank )
 {
  case IDO_BANK_0: index = 0; break;
  case IDO_BANK_1: index = 1; break;
  case IDO_BANK_2: index = 2; break;
  case IDO_BANK_3: index = 3; break;
  case IDO_BANK_4: index = 4; break;
  case IDO_BANK_5: index = 5; break;
  case IDO_BANK_6: index = 6; break;
  case IDO_BANK_7: index = 7; break;
  case IDO_BANK_NONE: index = 8; break;
  case IDO_BANK_UNDEFINED: index = 9; break;
 }
 return info[index].name;
}


static const char * Bank_Symbol_To_Name( int board_id, int bank )
{
 switch ( board_id )
 {
  case ID_IDI48: return IDI_Bank_Symbol_To_Name( ((struct idi_bank_info *) board_definition[board_id].bank_info), (IDI_BANK_ENUM) bank );
  case ID_IDO48: return IDO_Bank_Symbol_To_Name( ((struct ido_bank_info *) board_definition[board_id].bank_info), (IDO_BANK_ENUM) bank );
 }
 return NULL;
}
# 930 "idi.c"
static int IDI_Bank_Name_To_Symbol( int board_id, const char * name, IDI_BANK_ENUM * bank )
{
 int index;
 const struct bank_info * info = board_definition[board_id].bank_info;
 index = 0;
 while ( NULL != info[index].name )
 {
  if ( 0 == strcasecmp( info[index].name, name ) )
  {
   *bank = info[index].symbol;
   return SUCCESS;
  }
  index++;
 }
 return -EC_BANK;
}

static int IDO_Bank_Name_To_Symbol( int board_id, const char * name, IDO_BANK_ENUM * bank )
{
 int index;
 const struct bank_info * info = board_definition[board_id].bank_info;
 index = 0;
 while ( NULL != info[index].name )
 {
  if ( 0 == strcasecmp( info[index].name, name ) )
  {
   *bank = info[index].symbol;
   return SUCCESS;
  }
  index++;
 }
 return -EC_BANK;
}

static int Bank_Name_To_Symbol( int board_id, const char * name, int * bank )
{
 switch ( board_id )
 {
  case ID_IDI48: return IDI_Bank_Name_To_Symbol( board_id, name, (IDI_BANK_ENUM *) bank );
  case ID_IDO48: return IDO_Bank_Name_To_Symbol( board_id, name, (IDO_BANK_ENUM *) bank );
 }
 return -EC_BOARD;
}






static int IDI_Register_Report_CSV( const struct idi_reg_definition * table, FILE * out )
{
 int index = 0;

 fprintf( out, "\"acronym\",\"symbol\",\"bank\",\"direction\",\"physical_offset\"\n" );
 do
 {
  fprintf( out, "\"%s\",", table[index].acronym );
  fprintf( out, "\"%s\",", table[index].symbol_name );

  switch( table[index].bank )
  {
  case IDI_BANK_0: fprintf( out, "IDI_BANK_0" ); break;
  case IDI_BANK_1: fprintf( out, "IDI_BANK_1" ); break;
  case IDI_BANK_2: fprintf( out, "IDI_BANK_2" ); break;
  case IDI_BANK_3: fprintf( out, "IDI_BANK_3" ); break;
  case IDI_BANK_4: fprintf( out, "IDI_BANK_4" ); break;
  case IDI_BANK_5: fprintf( out, "IDI_BANK_5" ); break;
  case IDI_BANK_6: fprintf( out, "IDI_BANK_6" ); break;
  case IDI_BANK_7: fprintf( out, "IDI_BANK_7" ); break;
  case IDI_BANK_NONE: fprintf( out, "IDI_BANK_NONE" ); break;
  case IDI_BANK_UNDEFINED: fprintf( out, "IDI_BANK_UNDEFINED" ); break;
  }
  fprintf( out, "," );

  switch( table[index].direction )
  {
   case REG_DIR_NONE: fprintf( out, "REG_DIR_NONE" ); break;
   case REG_DIR_READ: fprintf( out, "REG_DIR_READ" ); break;
   case REG_DIR_WRITE: fprintf( out, "REG_DIR_WRITE" ); break;
   case REG_DIR_READ_WRITE: fprintf( out, "REG_DIR_READ_WRITE" ); break;
  }
  fprintf( out, "," );

  fprintf( out, "\"%d\"", table[index].physical_offset );
  fprintf( out, "\n\r" );
  index++;
 } while ( table[index].direction != REG_DIR_NONE );

 return SUCCESS;
}





static int IDO_Register_Report_CSV( const struct ido_reg_definition * table, FILE * out )
{
 int index = 0;

 fprintf( out, "\"acronym\",\"symbol\",\"bank\",\"direction\",\"physical_offset\"\n" );
 do
 {
  fprintf( out, "\"%s\",", table[index].acronym );
  fprintf( out, "\"%s\",", table[index].symbol_name );

  switch( table[index].bank )
  {
  case IDO_BANK_0: fprintf( out, "IDO_BANK_0" ); break;
  case IDO_BANK_1: fprintf( out, "IDO_BANK_1" ); break;
  case IDO_BANK_2: fprintf( out, "IDO_BANK_2" ); break;
  case IDO_BANK_3: fprintf( out, "IDO_BANK_3" ); break;
  case IDO_BANK_4: fprintf( out, "IDO_BANK_4" ); break;
  case IDO_BANK_5: fprintf( out, "IDO_BANK_5" ); break;
  case IDO_BANK_6: fprintf( out, "IDO_BANK_6" ); break;
  case IDO_BANK_7: fprintf( out, "IDO_BANK_7" ); break;
  case IDO_BANK_NONE: fprintf( out, "IDO_BANK_NONE" ); break;
  case IDO_BANK_UNDEFINED: fprintf( out, "IDO_BANK_UNDEFINED" ); break;
  }
  fprintf( out, "," );

  switch( table[index].direction )
  {
   case REG_DIR_NONE: fprintf( out, "REG_DIR_NONE" ); break;
   case REG_DIR_READ: fprintf( out, "REG_DIR_READ" ); break;
   case REG_DIR_WRITE: fprintf( out, "REG_DIR_WRITE" ); break;
   case REG_DIR_READ_WRITE: fprintf( out, "REG_DIR_READ_WRITE" ); break;
  }
  fprintf( out, "," );

  fprintf( out, "\"%d\"", table[index].physical_offset );
  fprintf( out, "\n\r" );
  index++;
 } while ( table[index].direction != REG_DIR_NONE );

 return SUCCESS;
}
# 1076 "idi.c"
int Register_Report_CSV( int board_id, FILE * out )
{
 switch ( board_id )
 {
  case ID_IDI48: return IDI_Register_Report_CSV( ((const struct idi_reg_definition *) board_definition[board_id].definition), out );
  case ID_IDO48: return IDO_Register_Report_CSV( ((const struct ido_reg_definition *) board_definition[board_id].definition), out );
 }
 return -EC_BOARD;
}




static int Register_Acronym_To_Row( int board_id, const char * acronym, int * row )
{
 int index;
 const struct reg_definition * definition = (const struct reg_definition *) board_definition[board_id].definition;

 index = 0;
 while ( definition[index].direction != REG_DIR_NONE )
 {
  if ( 0 == strcasecmp( definition[index].acronym, acronym ) )
  {
   *row = index;
   return SUCCESS;
  }
  index++;
 }
 return -EC_NOT_FOUND;
}
# 1121 "idi.c"
BOOL String_To_Bool( const char * str )
{
 switch( str[0] )
 {
 case '0':
 case 'f':
 case 'F':
  return 0;
 case '1':
 case 't':
 case 'T':
  return 1;
 }
 return 0;
}
# 1149 "idi.c"
enum { HEX_DUMP_BYTES_PER_LINE = 16 };

int Hex_Dump_Line( uint16_t address, size_t count, uint8_t * buffer, FILE * out )
{
 size_t index;
 char str_temp[8];
 char str_ascii[20];
 char str_hex_list[64];


 if ( count > HEX_DUMP_BYTES_PER_LINE ) return -EC_HEX_DUMP_COUNT;

 sprintf( str_hex_list, "%04X: ", ((int) address) );
 strcpy( str_ascii, "" );
 for ( index = 0; index < count; index++ )
 {
  sprintf( str_temp, "%02X", buffer[index] );
  strcat( str_hex_list, str_temp );

  if ( 0x07 == ( index & 0x07 ) ) strcat( str_hex_list, "  " );

  strcat( str_hex_list, " " );

  if ( ( buffer[index] < ' ' ) || ( buffer[index] > '~' ) )
  {
   strcat( str_ascii, "." );
  }
  else
  {
   sprintf( str_temp, "%c", buffer[index] );
   strcat( str_ascii, str_temp );
  }
 }

 index = strlen( str_hex_list );

 count = 60 - index;
 while ( count > 0 )
 {
  strcat( str_hex_list, " " );
  count--;
 }

 fprintf( out, "%s%s\n", str_hex_list, str_ascii );
 return SUCCESS;
}
# 1206 "idi.c"
static const char ec_unknown[] = "unknown error code";

const char * EC_Code_To_Human_Readable( EC_ENUM error_code )
{
 int index;

 if ( error_code < 0 ) error_code = -error_code;

 index = 0;
 while( NULL != ec_human_readable[index].message )
 {
  if ( ((EC_ENUM) error_code) == ec_human_readable[index].error_code )
  {
   return ec_human_readable[index].message;
  }
  index++;
 }
 return ec_unknown;
}
# 1237 "idi.c"
BOOL Character_Get( int * character )
{
 int char_temp;
 BOOL result = 0;
# 1252 "idi.c"
 char_temp = '\0';
 result = 0;

 if ( NULL != character ) *character = char_temp;
 return result;
}
# 1312 "idi.c"
static int IO_Write_U8_Port( struct board_dataset * dataset, int address, uint8_t value )
{
 if ( NULL == dataset )
 {



   printf( "IO_Write_U8_Port: address = 0x%04X, value = 0x%02X\n", address, value );

 }
 else
 {
  if ( !dataset->io_simulate )
  {



  }
  if ( ( dataset->io_report ) || ( dataset->io_simulate ) )
  {
  printf( "IO_Write_U8_Port: address = 0x%04X, value = 0x%02X\n", address, value );
  }
 }
 return SUCCESS;
}



static int IO_Read_U8_Port( struct board_dataset * dataset, int address, uint8_t * value )
{
 if ( NULL == dataset )
 {



  printf( "IO_Read_U8_Port: address = 0x%04X, value=unknown\n", address );

 }
 else
 {
  if ( !dataset->io_simulate )
  {



  }
  if ( ( dataset->io_report ) || ( dataset->io_simulate ) )
  {
  printf( "IO_Read_U8_Port: address = 0x%04X, ", address );



  printf( "value = unknown\n" );

  }
 }
 return SUCCESS;
}
# 1384 "idi.c"
int IO_Write_U8( int board_id, int location, uint8_t value )
{
 int index;
 int offset;
 int channel;
 int address;
 int bank;

 struct reg_definition * definition = ( struct reg_definition * ) board_definition[board_id].definition;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;


 index = ( ( location >> 8 ) & 0xFF );

 if ( !( REG_DIR_WRITE == ( definition[index].direction & REG_DIR_WRITE ) ) )
 {
  printf( "IO_Write_U8: %s, error in direction\n", definition[index].symbol_name );
  return -EC_DIRECTION;
 }

    bank = definition[index].bank;
 if ( ( BANK_NONE != bank ) && ( bank != dataset->bank_previous ) )
 {
  address = dataset->base_address + definition[( ( board_definition[board_id].bank_register_symbol >> 8 ) & 0xFF )].physical_offset;
  dataset->bank_previous = bank;
  IO_Write_U8_Port( dataset, address, (uint8_t) bank );
  if ( ( dataset->io_report ) || ( dataset->io_simulate ) )
  {
  printf( "IO_Write_U8 bank write: %s, address = 0x%04X, bank = %s (0x%02X)\n", definition[index].symbol_name,
                        address,
                        Bank_Symbol_To_Name( board_id, bank ),
                        bank
     );
  }
 }
 channel = ( location & 0xFF );
 offset = definition[index].physical_offset;
 address = dataset->base_address + offset + channel;
 IO_Write_U8_Port( dataset, address, value );
 return SUCCESS;
}
# 1437 "idi.c"
int IO_Read_U8( int board_id, int location, uint8_t * value )
{
 int index;
 int offset;
 int channel;
 int address;
 int bank;

 struct reg_definition * definition = ( struct reg_definition * ) board_definition[board_id].definition;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 index = ( ( location >> 8 ) & 0xFF );

 if ( !( REG_DIR_READ == ( definition[index].direction & REG_DIR_READ ) ) )
 {
  printf( "IO_Read_U8: %s, error in direction\n", definition[index].symbol_name );
  return -EC_DIRECTION;
 }

 bank = definition[index].bank;
 if ( ( BANK_NONE != bank ) && ( bank != dataset->bank_previous ) )
 {
  address = dataset->base_address + definition[( ( board_definition[board_id].bank_register_symbol >> 8 ) & 0xFF )].physical_offset;
  dataset->bank_previous = bank;
  IO_Write_U8_Port( dataset, address, (uint8_t) bank );
  if ( ( dataset->io_report ) || ( dataset->io_simulate ) )
  {
  printf( "IO_Read_U8 bank write: %s, address = 0x%04X, bank = %s (0x%02X)\n", definition[index].symbol_name,
                       address,
                       Bank_Symbol_To_Name( board_id, bank ),
                       bank
     );
  }
 }
 channel = ( location & 0xFF );
 offset = definition[index].physical_offset;
 address = dataset->base_address + offset + channel;
 IO_Read_U8_Port( dataset, address, value );
 return SUCCESS;
}
# 1492 "idi.c"
void IO_Write_U16_Address_Increment( int board_id, int location, uint16_t value )
{

 IO_Write_U8( board_id, (int)(((int) location) + 0 ), (uint8_t)( value & 0xFF ) );
 IO_Write_U8( board_id, (int)(((int) location) + 1 ), (uint8_t)( ( value >> 8 ) & 0xFF ) );
}
# 1513 "idi.c"
void IO_Read_U16_Address_Increment( int board_id, int location, uint16_t * value )
{

 uint8_t lsb, msb;
 IO_Read_U8( board_id, (int)(((int) location) + 0 ), &lsb );
 IO_Read_U8( board_id, (int)(((int) location) + 1 ), &msb );
 *value = ( ((uint16_t) msb) << 8 ) | ( ((uint16_t) lsb) & 0xFF );
}
# 1536 "idi.c"
void IO_Write_U16_Address_Fixed( int board_id, int location, uint16_t value )
{

 IO_Write_U8( board_id, (int)(((int) location) + 0), (uint8_t)( value & 0xFF ) );
 IO_Write_U8( board_id, (int)(((int) location) + 0), (uint8_t)( ( value >> 8 ) & 0xFF ) );
}
# 1557 "idi.c"
void IO_Read_U16_Address_Fixed( int board_id, int location, uint16_t * value )
{

 uint8_t lsb, msb;
 IO_Read_U8( board_id, (int)(((int) location) + 0), &lsb );
 IO_Read_U8( board_id, (int)(((int) location) + 0), &msb );
 *value = ( ((uint16_t) msb) << 8 ) | ( ((uint16_t) lsb) & 0xFF );
}
# 2827 "idi.c"
int IDI_DIN_ID_Get( int board_id, uint16_t * id )
{
 uint8_t lsb, msb;

 IO_Read_U8( board_id, IDI_ID_LSB, &lsb );
 IO_Read_U8( board_id, IDI_ID_MSB, &msb );
 *id = ( ((uint16_t) msb) << 8 ) | ((uint16_t) lsb);



 return SUCCESS;
}
# 2847 "idi.c"
BOOL IDI_DIN_IsNotPresent( int board_id )
{
 uint16_t id;
 IDI_DIN_ID_Get( board_id, &id );
 if (ID_DIN == id ) return 0;
 return 1;
}
# 2864 "idi.c"
int IDI_DIN_Channel_Get( int board_id, size_t channel, BOOL * value )
{
 size_t group;
 size_t bit;
 uint8_t reg_value;

 group = channel >> 3;
 bit = channel - group * 8;

 IO_Read_U8( board_id, IDI_DI_GROUP0 + group , &reg_value );

 if ( 0 != ( reg_value & ( 0x01 << bit ) ) ) *value = 1;
 else *value = 0;

 return SUCCESS;
}
# 2890 "idi.c"
int IDI_DIN_Group_Get( int board_id, size_t group, uint8_t * value )
{
 IO_Read_U8( board_id, IDI_DI_GROUP0 + group , value );
 return SUCCESS;
}
# 2904 "idi.c"
int IDI_DIN_Pending_Clear( int board_id, size_t channel )
{
 size_t group;
 size_t bit;
 uint8_t reg_value;

 group = channel >> 3;
 bit = channel - group * 8;

 if ( group >= 6 ) return -EC_CHANNEL;

 reg_value = (uint8_t)( 0x01 << bit );
 IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group , reg_value );
 return SUCCESS;
}
# 2936 "idi.c"
static int SPI_ID_Get_Helper( int board_id, int id_lsb, int id_msb, uint16_t * id )
{
 uint8_t lsb, msb;
 IO_Read_U8( board_id, id_lsb, &lsb );
 IO_Read_U8( board_id, id_msb, &msb );
 *id = ( ((uint16_t) msb) << 8 ) | ((uint16_t) lsb);



 return SUCCESS;
}

int SPI_ID_Get( int board_id, uint16_t * id )
{
 switch ( board_id )
 {
  case ID_IDI48: return SPI_ID_Get_Helper( board_id, IDI_SPI_ID_LSB, IDI_SPI_ID_MSB, id );
  case ID_IDO48: return SPI_ID_Get_Helper( board_id, IDO_SPI_ID_LSB, IDO_SPI_ID_MSB, id );
 }
 return -EC_BOARD;
}
# 2966 "idi.c"
int SPI_IsNotPresent( int board_id )
{
 int error_code;
 uint16_t id;
 error_code = SPI_ID_Get( board_id, &id );
 if ( error_code < 0 ) return error_code;
 if (ID_SPI == id ) return 0;
 return 1;
}
# 2990 "idi.c"
int SPI_Calculate_Half_Clock( double half_clock_request_sec,
         double * half_clock_actual_sec,
         double * error,
         uint16_t * hci
       )
{
 double scratch;
 int hci_temp;


 scratch = ( half_clock_request_sec / 20.0e-9 ) - 4.0;
 hci_temp = (int) scratch;

 if ( ( hci_temp > 4095 ) || ( hci_temp < 0 ) ) return -EC_SPI_HALF_CLOCK_OUT_OF_RANGE;


 scratch = 20.0e-9 * ( 4.0 + ((double) hci_temp) );
 if ( NULL != error ) *error = ( scratch - half_clock_request_sec ) / half_clock_request_sec;
 if ( NULL != half_clock_actual_sec ) *half_clock_actual_sec = scratch;
 if ( NULL != hci ) *hci = (uint16_t) hci_temp;
 return SUCCESS;
}
# 3027 "idi.c"
int SPI_Calculate_Clock( double clock_request_hz,
       double * clock_actual_hz,
       double * error,
       uint16_t * hci
      )
{
 int error_code;
 double half_clock_request_sec;
 double half_clock_actual_sec;
 double error_internal;
 double scratch;
 uint16_t hci_internal;

 half_clock_request_sec = 1.0 / ( 2.0 * clock_request_hz );

 error_code = SPI_Calculate_Half_Clock( half_clock_request_sec,
             &half_clock_actual_sec,
             &error_internal,
             &hci_internal
            );
 if ( error_code ) return error_code;


 scratch = 1.0 / ( 2.0 * half_clock_actual_sec );
 if ( NULL != error ) *error = ( scratch - clock_request_hz ) / clock_request_hz;
 if ( NULL != clock_actual_hz ) *clock_actual_hz = scratch;
 if ( NULL != hci ) *hci = (uint16_t) hci_internal;
 return SUCCESS;
}
# 3064 "idi.c"
double SPI_Calculate_Half_Clock_Interval_Sec( uint16_t half_clock_interval )
{
 double half_clock_interval_sec;
 half_clock_interval_sec = 20.0e-9 * ( 4.0 + ((double) half_clock_interval ) );
 return half_clock_interval_sec;
}
# 3084 "idi.c"
int SPI_Calculate_End_Cycle_Delay( double spi_half_clock_interval_sec,
              double delay_request_sec,
              double * delay_actual_sec,
              double * error,
              uint8_t * ecd
        )
{

 double scratch;
 int ecd_temp;


 scratch = ( delay_request_sec - 4.0 * 20.0e-9 ) / spi_half_clock_interval_sec;
 ecd_temp = (int) scratch;

 if ( ( ecd_temp > 255 ) || ( ecd_temp < 0 ) ) return -EC_SPI_ECD_OUT_OF_RANGE;


 scratch = 20.0e-9 * 4.0 + ((double) ecd_temp) * spi_half_clock_interval_sec;
 if ( NULL != error ) *error = ( scratch - delay_request_sec ) / delay_request_sec;
 if ( NULL != delay_actual_sec ) *delay_actual_sec = scratch;
 if ( NULL != ecd ) *ecd = (uint8_t) ecd_temp;
 return SUCCESS;
}
# 3117 "idi.c"
int SPI_Configuration_Chip_Select_Behavior_Get( int board_id, SPI_CSB_ENUM * chip_select_behavior )
{
 uint8_t scratch;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_CONFIG, &scratch ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_CONFIG, &scratch ); break;
 }

 *chip_select_behavior = (SPI_CSB_ENUM) ( scratch >> 4 ) & 0x07;
 return SUCCESS;
}
# 3141 "idi.c"
int SPI_Configuration_Chip_Select_Behavior_Set( int board_id, SPI_CSB_ENUM chip_select_behavior )
{
 uint8_t scratch;
 int spi_config_symbol;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 switch ( board_id )
 {
  case ID_IDI48: spi_config_symbol = (int) IDI_SPI_CONFIG; break;
  case ID_IDO48: spi_config_symbol = (int) IDO_SPI_CONFIG; break;
 }

 IO_Read_U8( board_id, spi_config_symbol, &scratch );

 scratch &= ~0x70;
 scratch |= (uint8_t) ( ( chip_select_behavior & 0x07 ) << 4 );

 IO_Write_U8( board_id, spi_config_symbol, scratch );
 return SUCCESS;
}
# 3171 "idi.c"
int SPI_Configuration_Set( int board_id, struct spi_cfg * cfg )
{
 int error_code;
 double scratch;
 double hci_sec;
 uint8_t config;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 config = (uint8_t) ( ( cfg->chip_select_behavior & 0x07 ) << 4 );
 if ( cfg->sclk_polarity ) config |= 0x01;
 if ( cfg->sclk_phase ) config |= 0x02;
 if ( cfg->sdi_polarity ) config |= 0x04;
 if ( cfg->sdo_polarity ) config |= 0x08;
 if ( cfg->sdio_wrap ) config |= 0x80;

 switch ( board_id )
 {
  case ID_IDI48: IO_Write_U8( board_id, IDI_SPI_CONFIG, config ); break;
  case ID_IDO48: IO_Write_U8( board_id, IDO_SPI_CONFIG, config ); break;
 }


 if ( cfg->clock_hz > 0 )
 {

  error_code = SPI_Calculate_Clock( cfg->clock_hz, NULL, NULL, &(cfg->half_clock_interval) );
  if ( error_code ) return error_code;
 }
 hci_sec = SPI_Calculate_Half_Clock_Interval_Sec( cfg->half_clock_interval );

 if ( cfg->end_delay_ns > 0 )
 {
  scratch = cfg->end_delay_ns * 1.0e-9;
  error_code = SPI_Calculate_End_Cycle_Delay( hci_sec,
                                           scratch,
                                           NULL,
                                           NULL,
                                           &(cfg->end_cycle_delay)
                                          );
  if ( error_code ) return error_code;
 }

 switch ( board_id )
 {
  case ID_IDI48: IO_Write_U8( board_id, IDI_SPI_HCI_LSB, (uint8_t)( cfg->half_clock_interval & 0xFF ) ); break;
  case ID_IDO48: IO_Write_U8( board_id, IDO_SPI_HCI_LSB, (uint8_t)( cfg->half_clock_interval & 0xFF ) ); break;
 }



 switch ( board_id )
 {
  case ID_IDI48: IO_Write_U8( board_id, IDI_SPI_HCI_MSB, (uint8_t)( cfg->half_clock_interval >> 8 ) ); break;
  case ID_IDO48: IO_Write_U8( board_id, IDO_SPI_HCI_MSB, (uint8_t)( cfg->half_clock_interval >> 8 ) ); break;
 }


 switch ( board_id )
 {
  case ID_IDI48: IO_Write_U8( board_id, IDI_SPI_ECD, cfg->end_cycle_delay ); break;
  case ID_IDO48: IO_Write_U8( board_id, IDO_SPI_ECD, cfg->end_cycle_delay ); break;
 }


 if ( cfg != &(dataset->spi.cfg) )
 {
  memcpy( &(dataset->spi.cfg), &cfg, sizeof( struct spi_cfg ) );
 }
 return SUCCESS;
}
# 3252 "idi.c"
int SPI_Configuration_Get( int board_id, struct spi_cfg * cfg )
{
 uint8_t scratch;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_CONFIG, &scratch ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_CONFIG, &scratch ); break;
 }


 cfg->chip_select_behavior = (SPI_CSB_ENUM) ( scratch >> 4 ) & 0x07;
    cfg->sclk_polarity = ( scratch & 0x01 ) ? 1 : 0;
    cfg->sclk_phase = ( scratch & 0x02 ) ? 1 : 0;
 cfg->sdi_polarity = ( scratch & 0x04 ) ? 1 : 0;
 cfg->sdo_polarity = ( scratch & 0x08 ) ? 1 : 0;
 cfg->sdio_wrap = ( scratch & 0x80 ) ? 1 : 0;

 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_HCI_LSB, &scratch ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_HCI_LSB, &scratch ); break;
 }

 cfg->half_clock_interval = (uint16_t) scratch;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_HCI_MSB, &scratch ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_HCI_MSB, &scratch ); break;
 }

 cfg->half_clock_interval |= ( (uint16_t) scratch) << 8;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_ECD, &(cfg->end_cycle_delay) ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_ECD, &(cfg->end_cycle_delay) ); break;
 }


 cfg->clock_hz = 1.0 / ( 2.0 * 20.0e-9 * ( 4.0 + ((double) cfg->half_clock_interval) ) );
 cfg->end_delay_ns = 1.0e9 * 20.0e-9 * 4.0 + 0.5 * ((double) cfg->end_cycle_delay) / cfg->clock_hz;

 if ( cfg != &(dataset->spi.cfg) )
 {
  memcpy( &(dataset->spi.cfg), &cfg, sizeof( struct spi_cfg ) );
 }
 return SUCCESS;
}
# 3313 "idi.c"
int SPI_Report_Configuration_Text( struct spi_cfg * cfg, FILE * out )
{
 fprintf( out, "################################### SPI Configuration:\n" );
 fprintf( out, "sdio_wrap             = %s\n", cfg->sdio_wrap ? "true" : "false" );
 fprintf( out, "sdo_polarity          = %s\n", cfg->sdo_polarity ? "true" : "false" );
 fprintf( out, "sdi_polarity          = %s\n", cfg->sdi_polarity ? "true" : "false" );
 fprintf( out, "sclk_phase            = %s\n", cfg->sclk_phase ? "true" : "false" );
 fprintf( out, "sclk_polarity         = %s\n", cfg->sclk_polarity ? "true" : "false" );
 fprintf( out, "chip_select_behavior  = " );

 switch( cfg->chip_select_behavior )
 {
  case CSB_SOFTWARE: fprintf( out, "CSB_SOFTWARE" ); break;
  case CSB_BUFFER: fprintf( out, "CSB_BUFFER" ); break;
  case CSB_uint8_t: fprintf( out, "CSB_uint8_t" ); break;
  case CSB_uint16_t: fprintf( out, "CSB_uint16_t" ); break;
  default: fprintf( out, "undefined" ); break;
 }
 fprintf( out, "\n" );

 fprintf( out, "end_cycle_delay       = 0x%02X  (%d)\n", cfg->end_cycle_delay, cfg->end_cycle_delay );
 fprintf( out, "half_clock_interval   = 0x%04X  (%d)\n", cfg->half_clock_interval, cfg->half_clock_interval );

 fprintf( out, "clock_hz              = %f Hz\n", cfg->clock_hz );
 fprintf( out, "end_delay_ns          = %f ns\n", cfg->end_delay_ns );
 fprintf( out, "\n" );
 return SUCCESS;
}
# 3351 "idi.c"
int SPI_Report_Status_Text( struct spi_status * status, FILE * out )
{
 fprintf( out, "################################### SPI " );
 if ( status->tx_status ) fprintf( out, "TX" );
 else fprintf( out, "RX" );

 fprintf( out, " Status:\n" );

 fprintf( out, "full       = %s\n", status->full ? "true" : "false" );
 fprintf( out, "empty      = %s\n", status->empty ? "true" : "false" );
 fprintf( out, "fifo size  = %d\n", status->fifo_size );
 fprintf( out, "fifo count = %d\n", status->fifo_count );

 return SUCCESS;
}
# 3375 "idi.c"
int SPI_Configuration_Initialize( struct spi_cfg * cfg )
{
 cfg->sdio_wrap = 0;
 cfg->sdo_polarity = 0;
 cfg->sdi_polarity = 0;






 cfg->sclk_phase = 0;
 cfg->sclk_polarity = 0;

 cfg->chip_select_behavior = 0;
 cfg->end_cycle_delay = 0;
 cfg->half_clock_interval = 0;

 cfg->clock_hz = 0.0;
 cfg->end_delay_ns = 0.0;

 return SUCCESS;
}
# 3416 "idi.c"
int SPI_Status_Write( int board_id, struct spi_status * status )
{
 uint8_t reg_value;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_TX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_TX_STATUS, &reg_value ); break;
 }

 status->fifo_count = (int)( reg_value & 0x1F );
 status->full = (BOOL)( reg_value & 0x80 );
 status->fifo_size = (int) SPI_FIFO_SIZE;
 status->empty = (BOOL)( reg_value & 0x40 );
 status->tx_status = 1;
 return SUCCESS;
}
# 3452 "idi.c"
void SPI_Status_Write_FIFO_Status( int board_id, BOOL * full, BOOL * empty, size_t * bytes_available )
{
 uint8_t reg_value;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_TX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_TX_STATUS, &reg_value ); break;
 }

 switch( reg_value & 0xC0 )
 {
  case 0x00: *full = 0; *empty = 0; break;
  case 0x40: *full = 0; *empty = 1; break;
  case 0x80: *full = 1; *empty = 0; break;
  case 0xC0: *full = 1; *empty = 1; break;
 }
 *bytes_available = (size_t) SPI_FIFO_SIZE - (size_t)( reg_value & 0x1F );
}
# 3478 "idi.c"
BOOL SPI_Status_Write_FIFO_Is_Full( int board_id )
{
 uint8_t reg_value;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_TX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_TX_STATUS, &reg_value ); break;
 }

 if ( reg_value & 0x80 ) return 1;
 return 0;
}
# 3506 "idi.c"
void SPI_Status_Read_FIFO_Status( int board_id, BOOL * empty, size_t * bytes_available )
{
 uint8_t reg_value;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_RX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_RX_STATUS, &reg_value ); break;
 }

 *bytes_available = (size_t)( reg_value & 0x1F );
 *empty = (BOOL)( reg_value & 0x40 );
}
# 3536 "idi.c"
int SPI_Status_Read( int board_id, struct spi_status * status )
{
 uint8_t reg_value;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_RX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_RX_STATUS, &reg_value ); break;
 }

 status->fifo_count = (int)( reg_value & 0x1F );
 status->full = (BOOL)( reg_value & 0x80 );
 status->fifo_size = (int) SPI_FIFO_SIZE;
 status->empty = (BOOL)( reg_value & 0x40 );
 status->tx_status = 0;
 return SUCCESS;
}
# 3563 "idi.c"
BOOL SPI_Status_Write_FIFO_Is_Not_Empty( int board_id )
{
 uint8_t reg_value;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_TX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_TX_STATUS, &reg_value ); break;
 }

 if ( reg_value & 0x40 ) return 0;
 return 1;
}
# 3583 "idi.c"
BOOL SPI_Status_Read_FIFO_Is_Not_Empty( int board_id )
{
 uint8_t reg_value;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_RX_STATUS, &reg_value ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_RX_STATUS, &reg_value ); break;
 }

 if ( reg_value & 0x40 ) return 0;
 return 1;
}
# 3606 "idi.c"
int SPI_Commit( int board_id, uint8_t chip_select )
{
 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;
 switch ( board_id )
 {
  case ID_IDI48: IO_Write_U8( board_id, IDI_SPI_COMMIT, chip_select ); break;
  case ID_IDO48: IO_Write_U8( board_id, IDO_SPI_COMMIT, chip_select ); break;
 }

 return SUCCESS;
}
# 3628 "idi.c"
int SPI_Commit_Get( int board_id, uint8_t * chip_select )
{
 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_COMMIT, chip_select ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_COMMIT, chip_select ); break;
 }

 return SUCCESS;
}







BOOL SPI_Commit_Is_Inactive( int board_id )
{
 uint8_t chip_select;
 switch ( board_id )
 {
  case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_COMMIT, &chip_select ); break;
  case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_COMMIT, &chip_select ); break;
 }

 if ( 0 == chip_select ) return 1;
 return 0;
}
# 3674 "idi.c"
int SPI_FIFO_Write( int board_id, const void * buffer, size_t size, size_t count, FILE * fd_log )
{
 int error_code;
 size_t bytes_available;
 BOOL empty;
 BOOL full;
 size_t index;
 size_t qty_objects;
 size_t qty_bytes;
 int reg_symbol;

 error_code = SUCCESS;

 if ( (size * count) > SPI_FIFO_SIZE ) return -EC_PARAMETER;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 SPI_Status_Write_FIFO_Status( board_id, &full, &empty, &bytes_available );

 qty_objects = bytes_available / size;
 if ( count < qty_objects ) qty_objects = count;

 qty_bytes = qty_objects * size;




 switch ( board_id )
 {
  case ID_IDI48: reg_symbol = (int) IDI_SPI_DATA; break;
  case ID_IDO48: reg_symbol = (int) IDO_SPI_DATA; break;
 }
 for ( index = 0; index < qty_bytes; index++ ) IO_Write_U8( board_id, reg_symbol, ((uint8_t *) buffer)[index] );

 if ( NULL != fd_log )
 {
  error_code = fwrite( buffer, size, qty_objects, fd_log );
 }

 if ( SUCCESS == error_code ) error_code = ( (int) qty_objects );
 return error_code;
}
# 3732 "idi.c"
int SPI_FIFO_Read( int board_id, const void * buffer, size_t size, size_t count, FILE * fd_log )
{
 int error_code;
 size_t bytes_available;
 BOOL empty;
 size_t index;
 size_t qty_objects;
 size_t qty_bytes;
 int reg_symbol;

 error_code = SUCCESS;

 if ( (size * count) > SPI_FIFO_SIZE ) return -EC_PARAMETER;

 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;

 SPI_Status_Read_FIFO_Status( board_id, &empty, &bytes_available );

 qty_objects = bytes_available / size;
 if ( count < qty_objects ) qty_objects = count;

 qty_bytes = qty_objects * size;

 switch ( board_id )
 {
  case ID_IDI48: reg_symbol = (int) IDI_SPI_DATA; break;
  case ID_IDO48: reg_symbol = (int) IDO_SPI_DATA; break;
 }
 for ( index = 0; index < qty_bytes; index++ ) IO_Read_U8( board_id, reg_symbol, &(((uint8_t *) buffer)[index]) );

 if ( NULL != fd_log )
 {
  error_code = fwrite( buffer, size, qty_objects, fd_log );
 }

 if ( SUCCESS == error_code ) error_code = ( (int) qty_objects );
 return error_code;
}





static void SPI_Data_Write_Read_Helper_Read( int board_id,
            size_t object_size,
            size_t object_total_count,
            BOOL active_rx,
            size_t * index_rx,
            const void * rx_buffer
             )
{
 BOOL rx_empty;
 int reg_symbol;
 size_t rx_bytes_available;
 size_t object_qty;
 size_t object_remaining;
 size_t index_object;
 size_t index;
 size_t index_byte;
 uint8_t bit_bucket;


 SPI_Status_Read_FIFO_Status( board_id, &rx_empty, &rx_bytes_available );
 if ( rx_bytes_available >= object_size )
 {
  object_qty = rx_bytes_available / object_size;
  object_remaining = object_total_count - *index_rx;
  if ( object_qty > object_remaining )
  {
   object_qty = object_total_count - *index_rx;
  }



  switch ( board_id )
  {
   case ID_IDI48: reg_symbol = (int) IDI_SPI_DATA; break;
   case ID_IDO48: reg_symbol = (int) IDO_SPI_DATA; break;
  }

  if ( active_rx )
  {
   for ( index_object = 0; index_object < object_qty; index_object++ )
   {
    index_byte = (*index_rx) * object_size;
    for ( index = 0; index < object_size; index++ )
    {
     IO_Read_U8( board_id, reg_symbol, &(((uint8_t *) rx_buffer)[index_byte + index]) );
    }
    *index_rx = *index_rx + 1;
   }
  }
  else
  {
   for ( index_object = 0; index_object < object_qty; index_object++ )
   {
    index_byte = (*index_rx) * object_size;
    for ( index = 0; index < object_size; index++ )
    {
     IO_Read_U8( board_id, reg_symbol, &bit_bucket );
    }
    *index_rx = *index_rx + 1;
   }
  }
 }
}






static void SPI_Data_Write_Read_Helper_Commit( int board_id,
            size_t object_size,
            SPI_CSB_ENUM csb,
            BOOL commit_ready,
            BOOL * commit_valid
            )
{



 (void) object_size;



 if ( 1 == commit_ready )
 {
  if ( 0 == *commit_valid )
  {
   if ( CSB_SOFTWARE != csb ) SPI_Commit( board_id, 0xFF );
  }



  *commit_valid = 1;
 }
 else
 {
  if ( CSB_BUFFER == csb )
  {
   if ( SPI_Commit_Is_Inactive( board_id ) )
   {



    *commit_valid = 0;
   }
  }
  else
  {



   *commit_valid = 0;
  }
 }
}




static void SPI_Data_Write_Read_Helper_Write( int board_id,
            size_t object_size,
            size_t object_total_count,
            SPI_CSB_ENUM csb,
            BOOL active_tx,
            BOOL commit_valid,
            BOOL * commit_ready,
            size_t * index_tx,
            const void * tx_buffer
             )
{
 BOOL tx_full;
 BOOL tx_empty;
 int reg_symbol;
 size_t tx_bytes_available;
 size_t object_qty;
 size_t object_remaining;
 size_t index_object;
 size_t index;
 size_t index_byte;
 const uint8_t tx_dummy_value = 0x00;

 if ( 0 == commit_valid )
 {
  if ( 0 == *commit_ready )
  {

   SPI_Status_Write_FIFO_Status( board_id, &tx_full, &tx_empty, &tx_bytes_available );
   if ( tx_bytes_available >= object_size )
   {
    object_qty = tx_bytes_available / object_size;
    object_remaining = object_total_count - *index_tx;
    if ( object_qty > object_remaining )
    {
     object_qty = object_total_count - *index_tx;
    }

    if ( CSB_BUFFER == csb )
    {
     if ( object_qty >= 1 ) object_qty = 1;
    }



    switch ( board_id )
    {
     case ID_IDI48: reg_symbol = (int) IDI_SPI_DATA; break;
     case ID_IDO48: reg_symbol = (int) IDO_SPI_DATA; break;
    }
    if ( active_tx )
    {



     for ( index_object = 0; index_object < object_qty; index_object++ )
     {



      index_byte = *index_tx * object_size;
      for ( index = 0; index < object_size; index++ )
      {



       IO_Write_U8( board_id, reg_symbol, ((uint8_t *) tx_buffer)[index_byte + index] );
      }
      *index_tx = *index_tx + 1;
     }



    }
    else
    {



     for ( index_object = 0; index_object < object_qty; index_object++ )
     {
      index_byte = *index_tx * object_size;
      for ( index = 0; index < object_size; index++ )
      {
       IO_Write_U8( board_id, reg_symbol, tx_dummy_value );
      }
      *index_tx = *index_tx + 1;
     }
    }
    *commit_ready = 1;



   }
   else
   {

   }
  }
  else
  {

  }
 }
 else
 {



  *commit_ready = 0;
 }
}
# 4029 "idi.c"
int SPI_Data_Write_Read( int board_id,
       size_t object_size,
       size_t tx_object_count,
       const void * tx_buffer,
       size_t rx_object_count,
       const void * rx_buffer
      )
{
 int error_code;
 SPI_CSB_ENUM csb;
 size_t rx_bytes_available;
 BOOL rx_empty;
 size_t tx_bytes_available;
 BOOL active_tx;
 BOOL active_rx;
 BOOL tx_empty;
 BOOL tx_full;
 size_t index_tx;
 size_t index_rx;





 BOOL commit_valid;
 BOOL commit_ready;
 uint8_t bit_bucket;

 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;



 if ( ( NULL == tx_buffer ) && ( NULL == rx_buffer ) ) return SUCCESS;
 if ( SPI_IsNotPresent( board_id ) ) return -EC_SPI_NOT_FOUND;


 if ( ( NULL != tx_buffer ) && ( NULL != rx_buffer ) )
 {
  if ( tx_object_count != rx_object_count ) return -EC_SPI_BUFFER_MISMATCH;
 }
 if ( NULL != tx_buffer )
 {
  active_tx = 1;
 }
 else
 {
  tx_object_count = rx_object_count;
  active_tx = 0;
 }
 if ( NULL != rx_buffer )
 {
  active_rx = 1;
 }
 else
 {
  rx_object_count = tx_object_count;
  active_rx = 0;
 }


 error_code = SPI_Configuration_Chip_Select_Behavior_Get( board_id, &csb );
 if ( error_code ) return error_code;

 if ( CSB_SOFTWARE == csb )
 {
  uint8_t chip_select;
  if ( 0 == SPI_Commit_Get( board_id, &chip_select ) )
  {



   SPI_Commit( board_id, 0xFF );
  }
 }

 if ( CSB_uint16_t == csb )
 {
  if ( object_size & 0x01 )
  {
   printf( "SPI_Data_Write_Read: Object Size is set to " );



   printf( "%lu", object_size );

   printf( ", and ought to be set to 2\n" );
   return -EC_SPI_BUFFER_SIZE_ODD;
  }
 }
# 4145 "idi.c"
 if ( CSB_BUFFER == csb )
 {


  if ( object_size > SPI_FIFO_SIZE ) return -EC_SPI_OBJECT_SIZE;
 }






 SPI_Status_Write_FIFO_Status( board_id, &tx_full, &tx_empty, &tx_bytes_available );
 if ( ( 0 == tx_empty ) && ( CSB_SOFTWARE != csb ) ) SPI_Commit( board_id, 0xFF );
 do
 {
  if ( ( dataset->quit_application ) || ( Character_Get( NULL ) ) )
  {
   printf( "SPI_Data_Write_Read initial empty tx\n" );
   return -EC_APP_TERMINATE;
  }
  SPI_Status_Write_FIFO_Status( board_id, &tx_full, &tx_empty, &tx_bytes_available );
 } while ( 0 == tx_empty );




 do
 {
  if ( ( dataset->quit_application ) || ( Character_Get( NULL ) ) )
  {
   printf( "SPI_Data_Write_Read initial empty rx\n" );
   return -EC_APP_TERMINATE;
  }
  SPI_Status_Read_FIFO_Status( board_id, &rx_empty, &rx_bytes_available );
  if ( 0 == rx_empty )
  {
   switch ( board_id )
   {
    case ID_IDI48: IO_Read_U8( board_id, IDI_SPI_DATA, &bit_bucket ); break;
    case ID_IDO48: IO_Read_U8( board_id, IDO_SPI_DATA, &bit_bucket ); break;
   }

  }
 } while ( 0 == rx_empty );



 index_tx = 0;
 index_rx = 0;
 commit_valid = 0;
 commit_ready = 0;
 while ( index_tx < tx_object_count )
 {
  if ( ( dataset->quit_application ) || ( Character_Get( NULL ) ) )
  {
   printf( "SPI_Data_Write_Read main loop\n" );
   return -EC_APP_TERMINATE;
  }




  SPI_Data_Write_Read_Helper_Read( board_id, object_size, tx_object_count, active_rx, &index_rx, rx_buffer );


  SPI_Data_Write_Read_Helper_Commit( board_id, object_size, csb, commit_ready, &commit_valid );




  SPI_Data_Write_Read_Helper_Write( board_id,
           object_size,
           tx_object_count,
           csb,
           active_tx,
           commit_valid,
           &commit_ready,
           &index_tx,
           tx_buffer
          );


  SPI_Data_Write_Read_Helper_Commit( board_id, object_size, csb, commit_ready, &commit_valid );
 }



 do
 {
  if ( ( dataset->quit_application ) || ( Character_Get( NULL ) ) )
  {
   printf( "SPI_Data_Write_Read status ending portion\n" );
   return -EC_APP_TERMINATE;
  }
  SPI_Data_Write_Read_Helper_Commit( board_id, object_size, csb, commit_ready, &commit_valid );
  SPI_Status_Write_FIFO_Status( board_id, &tx_full, &tx_empty, &tx_bytes_available );
 } while ( 0 == tx_empty );






 while ( index_rx != index_tx )
 {
  if ( ( dataset->quit_application ) || ( Character_Get( NULL ) ) )
  {
   printf( "SPI_Data_Write_Read status ending receive loop\n" );
   return -EC_APP_TERMINATE;
  }
  SPI_Data_Write_Read_Helper_Read( board_id, object_size, tx_object_count, active_rx, &index_rx, rx_buffer );
 }
 return SUCCESS;
}
# 4276 "idi.c"
int SPI_Data_Write( int board_id,
     const void * tx_buffer,
     size_t tx_object_size,
     size_t tx_object_count,
     FILE * fd_log
          )
{
 int error_code;
 error_code = SPI_Data_Write_Read( board_id,
          tx_object_size,
          tx_object_count,
          tx_buffer,
          0,
          NULL
         );
 if ( error_code ) return error_code;

 if ( NULL != fd_log )
 {
  error_code = fwrite( tx_buffer, tx_object_size, tx_object_count, fd_log );
 }
 return error_code;
}
# 4314 "idi.c"
int SPI_Data_Read( int board_id,
     const void * rx_buffer,
     size_t rx_object_size,
     size_t rx_object_count,
     FILE * fd_log
           )
{
 int error_code;
 error_code = SPI_Data_Write_Read( board_id,
          rx_object_size,
          0,
          NULL,
          rx_object_count,
          rx_buffer
         );
 if ( error_code ) return error_code;

 if ( NULL != fd_log )
 {
  error_code = fwrite( rx_buffer, rx_object_size, rx_object_count, fd_log );
 }
 return error_code;
}
# 4354 "idi.c"
enum { FRAM_DENSITY_BYTES = 8192 };
# 4364 "idi.c"
int FRAM__Write_Enable_Latch_Set( int board_id )
{
 uint8_t tx_buf[1] = { 0x06 };
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 return SPI_Data_Write_Read( board_id, 1, 1, tx_buf, 0, NULL );
}
# 4378 "idi.c"
int FRAM__Write_Disable( int board_id )
{
 uint8_t tx_buf[1] = { 0x04 };
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 return SPI_Data_Write_Read( board_id, 1, 1, tx_buf, 0, NULL );
}
# 4393 "idi.c"
int FRAM__Read_Status_Register( int board_id, uint8_t * status )
{
 int error_code;
 uint8_t tx_buf[2] = { 0x05, 0x00 };
 uint8_t rx_buf[2];

 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id, 2, 1, tx_buf, 1, rx_buf );
 if ( error_code ) return error_code;
 *status = rx_buf[1];
# 4416 "idi.c"
 return SUCCESS;
}
# 4427 "idi.c"
int FRAM__Write_Status_Register( int board_id, uint8_t status )
{
 int error_code;
 uint8_t tx_buf[2] = { 0x01, 0x00 };
 uint8_t rx_buf[2];

 FRAM__Write_Enable_Latch_Set( board_id );

 tx_buf[1] = status;
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id, 2, 1, tx_buf, 1, rx_buf );
 if ( error_code ) return error_code;

 return SUCCESS;
}
# 4453 "idi.c"
int FRAM__Memory_Read( int board_id, uint16_t address, size_t count, uint8_t * buffer )
{
 int error_code;

 uint8_t tx_buf[3] = { 0x03, 0x00, 0x00 };


 tx_buf[1] = (uint8_t)( address >> 8 );
 tx_buf[2] = (uint8_t)( address & 0xFF );





 error_code = SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_SOFTWARE );
 if ( error_code ) return error_code;

 SPI_Commit( board_id, 0xFF );

 error_code = SPI_Data_Write_Read( board_id, 3, sizeof( uint8_t ), tx_buf, 0, NULL );
 if ( error_code ) return error_code;

 error_code = SPI_Data_Write_Read( board_id, sizeof( uint8_t ), 0, NULL, count, buffer );
 if ( error_code ) return error_code;


 SPI_Commit( board_id, 0x00 );





 return SUCCESS;
}
# 4498 "idi.c"
int FRAM__Memory_Write( int board_id, uint16_t address, size_t count, uint8_t * buffer )
{
 int error_code;

 uint8_t tx_buf[3] = { 0x02, 0x00, 0x00 };

 tx_buf[1] = (uint8_t)( address >> 8 );
 tx_buf[2] = (uint8_t)( address & 0xFF );

 FRAM__Write_Enable_Latch_Set( board_id );





 error_code = SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_SOFTWARE );
 if ( error_code ) return error_code;

 SPI_Commit( board_id, 0xFF );

 error_code = SPI_Data_Write_Read( board_id, 3, sizeof( uint8_t ), tx_buf, 0, NULL );
 if ( error_code ) return error_code;

 error_code = SPI_Data_Write_Read( board_id, sizeof( uint8_t ), count, buffer, 0, NULL );
 if ( error_code ) return error_code;


 SPI_Commit( board_id, 0x00 );




 return SUCCESS;
}
# 4541 "idi.c"
int FRAM__Read_ID( int board_id, uint32_t * id )
{
 int error_code;
 uint8_t tx_buf[5] = { 0x9F, 0x00, 0x00, 0x00, 0x00 };
 uint8_t rx_buf[5];

 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id, 5, 1, tx_buf, 1, rx_buf );
 if ( error_code ) return error_code;

 {
  uint32_t id_scratch = 0;
  size_t index;

  for ( index = 1; index < 5; index++ )
  {
   id_scratch = ( id_scratch << 8 ) | ( (uint32_t) rx_buf[index] );
  }
  *id = id_scratch;
 }
# 4579 "idi.c"
 return SUCCESS;
}
# 4603 "idi.c"
int FRAM_Set( int board_id, size_t count, uint8_t * buffer )
{
 int error_code;
 size_t block_count;
 size_t block_remainder;
 uint16_t address;




 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;




 address = 0;

 if ( count > 1 )
 {
  block_count = ((size_t) FRAM_DENSITY_BYTES) / count;
  block_remainder = ((size_t) FRAM_DENSITY_BYTES) - ( block_count * count );
 }
 else
 {
  int index;
  const int block_size = 256;

  if ( NULL == buffer )
  {
   for ( index = 0; index < block_size; index++ ) dataset->spi.fram_block[index]= 0;
  }
  else
  {
   for ( index = 0; index < block_size; index++ ) dataset->spi.fram_block[index]= buffer[0];
  }
  block_count = ((size_t) FRAM_DENSITY_BYTES) / block_size;
  block_remainder = ((size_t) FRAM_DENSITY_BYTES) - ( block_count * block_size );
  buffer = dataset->spi.fram_block;
  count = block_size;
 }
# 4653 "idi.c"
 while ( block_count > 0 )
 {
  error_code = FRAM__Memory_Write( board_id, address, count, buffer );
  address += (uint16_t) count;
  block_count--;
# 4671 "idi.c"
 }

 if ( block_remainder > 0 )
 {
  error_code = FRAM__Memory_Write( board_id, address, block_remainder, buffer );
  if ( error_code ) return error_code;
 }
 return SUCCESS;
}






int FRAM_Report( int board_id, uint16_t address, size_t length, FILE * out )
{
 int error_code;
 const int block_size = HEX_DUMP_BYTES_PER_LINE;
 size_t block_count;
 size_t block_remainder;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 block_count = ((size_t) length) / block_size;
 block_remainder = ((size_t) length) - ( block_count * block_size );

 while ( block_count > 0 )
 {
  error_code = FRAM__Memory_Read( board_id, address, block_size, dataset->spi.fram_block );
  error_code = Hex_Dump_Line( address, block_size, dataset->spi.fram_block, out );
  address += block_size;
  block_count--;
 }

 if ( block_remainder > 0 )
 {
  error_code = FRAM__Memory_Read( board_id, address, block_remainder, dataset->spi.fram_block );
  error_code = Hex_Dump_Line( address, block_remainder, dataset->spi.fram_block, out );
  if ( error_code ) return error_code;
 }

 return SUCCESS;
}






int FRAM_Memory_To_File( int board_id, uint16_t address, size_t length, FILE * binary )
{
 int error_code;
 size_t block_count;
 size_t block_remainder;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 block_count = length / ((size_t) 256);
 block_remainder = length - ( block_count * ((size_t) 256) );

 while ( block_count > 0 )
 {
  error_code = FRAM__Memory_Read( board_id, address, ((size_t) 256), dataset->spi.fram_block );
  fwrite( dataset->spi.fram_block, 1, ((size_t) 256), binary );
  address += 256;
  block_count--;
 }

 if ( block_remainder > 0 )
 {
  error_code = FRAM__Memory_Read( board_id, address, block_remainder, dataset->spi.fram_block );
  fwrite( dataset->spi.fram_block, 1, block_remainder, binary );
  if ( error_code ) return error_code;
 }
 return SUCCESS;
}






int FRAM_File_To_Memory( int board_id, uint16_t address, size_t length, FILE * binary )
{
 int error_code;
 size_t count_read;
 size_t count_total;
 size_t count_actual;
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 count_total = 0;
 count_read = 256;
 if ( 0 == length )
 {
  do
  {
   count_actual = fread( dataset->spi.fram_block, 1, count_read, binary );
   error_code = FRAM__Memory_Write( board_id, address, count_read, dataset->spi.fram_block );
   if ( error_code ) return error_code;
   count_total += count_actual;
   if ( count_actual != count_read ) count_read = 0;
  } while ( count_read > 0 );
 }
 else
 {
  if ( length < count_read ) count_read = length;
  do
  {
   count_actual = fread( dataset->spi.fram_block, 1, count_read, binary );
   error_code = FRAM__Memory_Write( board_id, address, count_read, dataset->spi.fram_block );
   if ( error_code ) return error_code;
   count_total += count_actual;
   length -= count_actual;
   if ( count_actual != count_read ) count_read = 0;
   if ( length < count_read ) count_read = length;
  } while ( count_read > 0 );
 }
 return SUCCESS;
}
# 4801 "idi.c"
struct command_line
{
 struct command_line * link;
 int ( * cmd_fnc )( int argc, char * argv[] );
 char * name;
 char * help;
};

struct command_line_board
{
 struct command_line_board * link;
 int ( * cmd_fnc )( int board_id, int argc, char * argv[] );
 char * name;
 char * help;
};
# 4833 "idi.c"
static int CMD__SPI_ID( int board_id, int argc, char * argv[] )
{
 uint16_t id;
 (void) argc;
 (void) argv;

 SPI_ID_Get( board_id, &id );
 printf( "SPI ID: 0x%04X\n", id );
 return SUCCESS;
}






static int CMD__SPI_Config_Get( int board_id, int argc, char * argv[] )
{
 int error_code;
 struct spi_cfg cfg;
 (void) argc;
 (void) argv;

 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 error_code = SPI_Report_Configuration_Text( &cfg, stdout );
 if ( error_code ) return error_code;

 printf( "\n" );
 return SUCCESS;
}






static int CMD__SPI_Config_Clock_Hz( int board_id, int argc, char * argv[] )
{
 int error_code;
 double clock_request_hz;
 double clock_actual_hz;
 double error;
 uint16_t hci;
 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  printf( "SPI CLK: %f hz\n", cfg.clock_hz );
 }
 else
 {
  clock_request_hz = atof( argv[0] );
  error_code = SPI_Calculate_Clock( clock_request_hz, &clock_actual_hz, &error, &hci );
  if ( error_code ) return error_code;


  cfg.clock_hz = clock_actual_hz;
  error_code = SPI_Configuration_Set( board_id, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__SPI_Config_End_Cycle_Delay_Sec( int board_id, int argc, char * argv[] )
{
 int error_code;
 double request_sec;
 double actual_sec;
 double error;
 uint8_t ecd;
 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  printf( "SPI ECD: %g sec\n", ( cfg.end_delay_ns * 1.0e-9 ) );
 }
 else
 {
  request_sec = atof( argv[0] );
  error_code = SPI_Calculate_End_Cycle_Delay( SPI_Calculate_Half_Clock_Interval_Sec( cfg.half_clock_interval ),
             request_sec,
             &actual_sec,
             &error,
             &ecd
              );
  if ( error_code ) return error_code;
  cfg.end_delay_ns = actual_sec * 1.0e9;

  error_code = SPI_Configuration_Set( board_id, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}
# 4958 "idi.c"
static int CMD__SPI_Config_Mode( int board_id, int argc, char * argv[] )
{
 int error_code;
 int mode;
 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  if ( (0 == cfg.sclk_polarity ) && (0 == cfg.sclk_phase) ) mode = 0;
  else if ( (0 == cfg.sclk_polarity ) && (1 == cfg.sclk_phase) ) mode = 1;
  else if ( (1 == cfg.sclk_polarity ) && (0 == cfg.sclk_phase) ) mode = 2;
  else if ( (1 == cfg.sclk_polarity ) && (1 == cfg.sclk_phase) ) mode = 3;
  printf( "SPI MODE: %d\n", mode );
 }
 else
 {
  mode = (int) strtol( argv[0], NULL, 0 );
  switch ( mode )
  {
   case 0: cfg.sclk_polarity = 0; cfg.sclk_phase = 0; break;
   case 1: cfg.sclk_polarity = 0; cfg.sclk_phase = 1; break;
   case 2: cfg.sclk_polarity = 1; cfg.sclk_phase = 0; break;
   case 3: cfg.sclk_polarity = 1; cfg.sclk_phase = 1; break;
  }

  error_code = SPI_Configuration_Set( ID_IDI48, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__SPI_Config_SDI_Polarity( int board_id, int argc, char * argv[] )
{
 int error_code;

 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  printf( "SPI SDI POLARITY: %s\n", cfg.sdi_polarity ? "true" : "false" );
 }
 else
 {
  cfg.sdi_polarity = String_To_Bool( argv[0] );

  error_code = SPI_Configuration_Set( board_id, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__SPI_Config_SDO_Polarity( int board_id, int argc, char * argv[] )
{
 int error_code;

 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  printf( "SPI SDO POLARITY: %s\n", cfg.sdo_polarity ? "true" : "false" );
 }
 else
 {
  cfg.sdo_polarity = String_To_Bool( argv[0] );

  error_code = SPI_Configuration_Set( board_id, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__SPI_Config_SDIO_Wrap( int board_id, int argc, char * argv[] )
{
 int error_code;

 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  printf( "SPI wrap: %s\n", cfg.sdio_wrap ? "true" : "false" );
 }
 else
 {
  cfg.sdio_wrap = String_To_Bool( argv[0] );

  error_code = SPI_Configuration_Set( board_id, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__SPI_Config_Chip_Select_Behavior( int board_id, int argc, char * argv[] )
{
 int error_code;

 struct spi_cfg cfg;


 error_code = SPI_Configuration_Get( board_id, &cfg );
 if ( error_code ) return error_code;

 if ( argc < 1 )
 {
  printf( "SPI CSB: ");
  switch ( cfg.chip_select_behavior )
  {
   case CSB_SOFTWARE: printf( "software" ); break;
   case CSB_BUFFER: printf( "buffer" ); break;
   case CSB_uint8_t: printf( "uint8_t" ); break;
   case CSB_uint16_t: printf( "uint16_t" ); break;
   default: printf( "undefined" ); break;
  }
  printf( "\n" );
 }
 else
 {
  if ( 0 == strcasecmp( "software", argv[0] ) ) cfg.chip_select_behavior = 0;
  else if ( 0 == strcasecmp( "buffer", argv[0] ) ) cfg.chip_select_behavior = 1;
  else if ( 0 == strcasecmp( "uint8_t", argv[0] ) ) cfg.chip_select_behavior = 2;
  else if ( 0 == strcasecmp( "uint16_t", argv[0] ) ) cfg.chip_select_behavior = 3;
  else
  {
   cfg.chip_select_behavior = (SPI_CSB_ENUM) strtol( argv[0], NULL, 0 );
   switch ( cfg.chip_select_behavior )
   {
    case CSB_SOFTWARE:
    case CSB_BUFFER:
    case CSB_uint8_t:
    case CSB_uint16_t:
     break;
    default:
     error_code = -EC_SPI_CSB_OUT_OF_RANGE;
     break;
   }
  }
   if ( error_code ) return error_code;

  error_code = SPI_Configuration_Set( board_id, &cfg );
  if ( error_code ) return error_code;
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__SPI_Status( int board_id, int argc, char * argv[] )
{
 int error_code;
 int index;
 struct spi_status status;

 if ( argc < 1 )
 {
  error_code = SPI_Status_Read( board_id, &status );
  if ( error_code ) return error_code;
  SPI_Report_Status_Text( &status, stdout );
 }
 else
 {
  for ( index = 0; index < argc; index++ )
  {
   if ( 0 == strcasecmp( "rx", argv[index] ) )
   {
    error_code = SPI_Status_Read( board_id, &status );
    if ( error_code ) return error_code;
    SPI_Report_Status_Text( &status, stdout );
   }
   else if ( 0 == strcasecmp( "tx", argv[index] ) )
   {
    error_code = SPI_Status_Write( board_id, &status );
    if ( error_code ) return error_code;
    SPI_Report_Status_Text( &status, stdout );
   }
  }
 }
 return SUCCESS;
}






static int CMD__SPI_Data_Interpreter( int arg_start,
          int argc,
          char * argv[],
          size_t tx_size,
          size_t * tx_count,
          uint8_t * tx_buffer
         )
{
 size_t arg_qty;
 size_t count;
 int index_arg;
 int index_byte;
 uint8_t data_temp;
 char * endptr;
 char * sp;

 arg_qty = (size_t)( argc - arg_start );

 sp = NULL;
 index_arg = arg_start;
 index_byte = 0;
 count = arg_qty;
 while ( ( count != 0 ) && ( index_byte < tx_size ) )
 {
  data_temp = (uint8_t) strtol( argv[index_arg], &endptr, 0 );
  if ( endptr == argv[index_arg] )
  {
   sp = &(argv[index_arg][0]);
   while ( ( '\0' != *sp ) && ( index_byte < tx_size ) )
   {
    tx_buffer[index_byte] = (uint8_t)( *sp );
    sp++; index_byte++;
   }
   if ( '\0' == *sp ) sp = NULL;
  }
  else
  {
   tx_buffer[index_byte] = data_temp;
   index_byte++;
   sp = NULL;
  }
  count--; index_arg++;
 }

 if ( count > 0 )
 {



  printf( "Warning: ignored %lu arguments", count );

  if ( NULL != sp )
  {
   printf( ", and portion of string argument" );
  }
  printf( "\n" );
 }

 *tx_count = index_byte;
 return SUCCESS;
}
# 5257 "idi.c"
static int CMD__SPI_Data( int board_id, int argc, char * argv[] )
{
 int error_code;
 size_t index;
 size_t transfer_count;
 size_t lines;
 uint8_t * bp;

 struct board_dataset * dataset;
 dataset = ( struct board_dataset * ) board_definition[board_id].dataset;



 if ( argc < 1 ) return -EC_PARAMETER;

 CMD__SPI_Data_Interpreter( 0,
         argc,
         argv,
         256,
         &transfer_count,
         dataset->spi.tx_buffer
         );

 error_code = SPI_Data_Write_Read( board_id,
          sizeof( uint8_t ),
          transfer_count,
          dataset->spi.tx_buffer,
          transfer_count,
          dataset->spi.rx_buffer
         );
 if ( error_code ) return error_code;

 lines = transfer_count / HEX_DUMP_BYTES_PER_LINE;

 for ( index = 0; index <= lines; index++ )
 {
  bp = &(dataset->spi.rx_buffer[index * HEX_DUMP_BYTES_PER_LINE]);
  if ( transfer_count < HEX_DUMP_BYTES_PER_LINE )
  {
   Hex_Dump_Line( 0, transfer_count, bp, stdout );
  }
  else
  {
   Hex_Dump_Line( 0, HEX_DUMP_BYTES_PER_LINE, bp, stdout );
   transfer_count = transfer_count - HEX_DUMP_BYTES_PER_LINE;
  }
 }
 return SUCCESS;
}






static int CMD__SPI_FIFO( int board_id, int argc, char * argv[] )
{
 int error_code;
 int index;
 size_t count;
 SPI_CSB_ENUM csb;
 int read_count;

 uint8_t tx_buffer[SPI_FIFO_SIZE];
 uint8_t rx_buffer[SPI_FIFO_SIZE];

 struct board_dataset * dataset;
 dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 read_count = 0;
 if ( argc < 1 )
 {
  read_count = SPI_FIFO_SIZE;
 }
 else
 {
  if ( 0 == strcasecmp( "rx", argv[0] ) )
  {
   if ( argc > 1)
   {
    if ( 0 == strcasecmp( "all", argv[1] ) ) read_count = SPI_FIFO_SIZE;
    else read_count = (int) strtol( argv[1], NULL, 0 );
   }
  }
  else if ( 0 == strcasecmp( "tx", argv[0] ) )
  {
   CMD__SPI_Data_Interpreter( 1,
           argc,
           argv,
           SPI_FIFO_SIZE,
           &count,
           tx_buffer
           );

   error_code = SPI_FIFO_Write( board_id, (void *) tx_buffer, sizeof( uint8_t ), count, NULL );
   if ( error_code < 0 ) return error_code;

   printf( "OK, wrote %d objects or %d bytes\n", error_code, error_code * ((int) sizeof( uint8_t )) );
   return SUCCESS;
  }
  else if ( 0 == strcasecmp( "commit", argv[0] ) )
  {
   if ( argc > 1 )
   {
    if ( String_To_Bool( argv[1] ) ) SPI_Commit( board_id, 0xFF );
    else SPI_Commit( board_id, 0x00 );

    printf( "OK\n" );
    return SUCCESS;
   }
   else
   {
    uint8_t commit_status;
    SPI_Commit_Get( board_id, &commit_status );
    printf( "commit status = %s\n", ( 0 == commit_status ) ? "false" : "true" );
    return SUCCESS;
   }

  }
 }




 error_code = SPI_Configuration_Chip_Select_Behavior_Get( board_id, &csb );
 if ( error_code ) return error_code;

 if ( SPI_Status_Write_FIFO_Is_Not_Empty( board_id ) )
 {
  if ( CSB_SOFTWARE != csb ) SPI_Commit( board_id, 0xFF );
 }

 while ( SPI_Status_Write_FIFO_Is_Not_Empty( board_id ) )
 {
  if ( ( dataset->quit_application ) || ( Character_Get( NULL ) ) )
  {
   printf( "IDI_CMD__SPI_FIFO: waiting for tx empty\n" );
   return -EC_APP_TERMINATE;
  }
 }

 if ( read_count > 0 )
 {
  int lines;
  uint8_t * bp;

  if ( SPI_Status_Read_FIFO_Is_Not_Empty( board_id ) )
  {
   error_code = SPI_FIFO_Read( board_id, (void *) rx_buffer, sizeof( uint8_t ), read_count, NULL );
   if ( error_code < 0 ) return error_code;

   read_count = error_code * sizeof( uint8_t );
   lines = read_count / HEX_DUMP_BYTES_PER_LINE;

   for ( index = 0; index <= lines; index++ )
   {
    bp = &(rx_buffer[index * HEX_DUMP_BYTES_PER_LINE]);
    if ( read_count < HEX_DUMP_BYTES_PER_LINE )
    {
     Hex_Dump_Line( 0, read_count, bp, stdout );
    }
    else
    {
     Hex_Dump_Line( 0, HEX_DUMP_BYTES_PER_LINE, bp, stdout );
     read_count = read_count - HEX_DUMP_BYTES_PER_LINE;
    }
   }
  }
  else
  {
   printf( "FIFO Empty\n" );
  }
 }
 return SUCCESS;
}






static int CMD__SPI_Commit( int board_id, int argc, char * argv[] )
{
 int error_code;
 uint8_t chip_select;

 if ( argc < 1 )
 {
  uint8_t commit_status;
  SPI_Commit_Get( board_id, &commit_status );
  printf( "commit status = %s\n", ( 0 == commit_status ) ? "false" : "true" );
 }
 else if ( String_To_Bool( argv[0] ) ) chip_select = 0x01;
 else chip_select = 0x00;

 error_code = SPI_Commit( board_id, chip_select );
 if ( error_code ) return error_code;

 printf( "OK\n" );
 return SUCCESS;
}




static struct command_line_board cmd_spi[] =
{
 { NULL, CMD__SPI_ID, "id", "wishbone id: params: none" },
 { NULL, CMD__SPI_Config_Get, "cfg", "config dump: params: none" },
 { NULL, CMD__SPI_Config_Clock_Hz, "clk", "clk:         params: [<clock freq in hertz>]" },
 { NULL, CMD__SPI_Config_End_Cycle_Delay_Sec, "ecd", "end delay:   params: [<time in seconds>]" },
 { NULL, CMD__SPI_Config_Mode, "mode", "mode:        params: [<0/1/2/3>]" },
 { NULL, CMD__SPI_Config_SDI_Polarity, "sdi", "sdi pol:     params: [<true/1/false/0>]" },
 { NULL, CMD__SPI_Config_SDO_Polarity, "sdo", "sdo pol:     params: [<true/1/false/0>]" },
 { NULL, CMD__SPI_Config_SDIO_Wrap, "wrap", "sdo-->sdi:   params: [<true/1/false/0>]" },
 { NULL, CMD__SPI_Config_Chip_Select_Behavior, "csb", "chip select behavior: params: [0/1/2/3/software/buffer/uint8_t/uint16_t]" },
 { NULL, CMD__SPI_Status, "status", "status of both TX and RX buffers" },
 { NULL, CMD__SPI_Data, "data", "read/write:  params: <data list: bytes/characters/strings>" },
 { NULL, CMD__SPI_FIFO, "fifo", "fifo r/w:    params: <data list: bytes/characters/strings>" },
 { NULL, CMD__SPI_Commit, "commit", "causes spi transactions to start" },
 { NULL, NULL, NULL, NULL }
};






int Command_Line_SPI( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;

    error_code = -EC_SYNTAX;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 index = 0;
 while ( NULL != cmd_spi[index].cmd_fnc )
 {
  if ( 0 == strcasecmp( cmd_spi[index].name, argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_spi[index].cmd_fnc )( board_id, argc_new, argv_new );
   break;
  }
  index++;
 }
 return error_code;
}
# 5526 "idi.c"
enum
{ AS_ADS1259_CONFIG0 = 0,
 AS_ADS1259_CONFIG1 = 1,
 AS_ADS1259_CONFIG2 = 2,
 AS_ADS1259_OFC0 = 3,
 AS_ADS1259_OFC1 = 4,
 AS_ADS1259_OFC2 = 5,
 AS_ADS1259_FSC0 = 6,
 AS_ADS1259_FSC1 = 7,
 AS_ADS1259_FSC2 = 8,
 AS_ADS1259_REGISTER_QTY = 9
};



static char * as_register_name[] =
{
 "config0",
 "config1",
 "config2",
 "ofc0",
 "ofc1",
 "ofc2",
 "fsc0",
 "fsc1",
 "fsc2",
 NULL
};



struct bit_string_info
{
 size_t register_offset;
 size_t bit_offset;
 size_t bit_width;
 char * name;
};



static struct bit_string_info as_bit_string[] =
{
  { AS_ADS1259_CONFIG0, 0, 1, "spi" },
  { AS_ADS1259_CONFIG0, 2, 1, "rbias" },
  { AS_ADS1259_CONFIG0, 4, 2, "id" },
  { AS_ADS1259_CONFIG1, 0, 3, "delay" },
  { AS_ADS1259_CONFIG1, 3, 1, "extref" },
  { AS_ADS1259_CONFIG1, 4, 1, "sinc2" },
  { AS_ADS1259_CONFIG1, 6, 1, "chksum" },
  { AS_ADS1259_CONFIG1, 7, 1, "flag" },
  { AS_ADS1259_CONFIG2, 0, 3, "dr" },
  { AS_ADS1259_CONFIG2, 4, 1, "pulse" },
  { AS_ADS1259_CONFIG2, 5, 1, "syncout" },
  { AS_ADS1259_CONFIG2, 6, 1, "extclk" },
  { AS_ADS1259_CONFIG2, 7, 1, "drdy_b" },
  { AS_ADS1259_REGISTER_QTY, 0, 0, NULL }
};



int AS_Register_Name_To_Offset( char * name )
{
 size_t index;

 index = 0;
 while ( NULL != as_register_name[index] )
 {
  if ( 0 == strcasecmp( as_register_name[index], name ) )
  {
   return index;
  }
  index++;
 }
 return -EC_NOT_FOUND;
}



int Bit_String_Report( struct bit_string_info * table, size_t address, uint8_t value, FILE * out )
{
 size_t index;
 BOOL not_done;
 BOOL initial;
 uint8_t bit_string_value;

 initial = 1;
 not_done = 1;
 index = 0;
 while ( not_done )
 {
  if ( NULL == table[index].name )
  {
   not_done = 0;
  }
  else if ( address == table[index].register_offset )
  {
   size_t i;
   uint8_t mask = 0;
   for ( i = 0; i < table[index].bit_width; i++ ) mask = ( mask << 1 ) | 0x01;
   bit_string_value = value >> table[index].bit_offset;
   bit_string_value = bit_string_value & mask;
   if ( initial )
   {
    fprintf( out, ": " ); initial = 0;
   }
   fprintf( out, " %s=%d", table[index].name, (int) bit_string_value );
  }
  index++;
 }
 return SUCCESS;
}



int Bit_String_Index_By_Name( struct bit_string_info * table, char * name )
{
 int index;
 index = 0;
 while ( NULL != table[index].name )
 {
  if ( 0 == strcasecmp( table[index].name, name ) ) return index;
  index++;
 }
 return -EC_NOT_FOUND;
}



int AS_Opcode_Write( int board_id, uint8_t * tx_buf, size_t count )
{

 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 return SPI_Data_Write_Read( board_id,
        1,
        count,
        tx_buf,
        0,
        NULL
         );
}



static int CMD__AS_Wakeup( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x03 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Sleep( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x05 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Reset( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x07 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Start( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x09 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Stop( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x0B };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Rdatac( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x10 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Sdatac( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x11 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Rdata( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[4] = { 0x12, 0x00, 0x00, 0x00 };
 uint8_t rx_buf[4] = { 0x00, 0x00, 0x00, 0x00 };
 uint32_t adc_value;
 size_t index;
 int error_code;
 (void) argc;
 (void) argv;

 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id,
          1,
          4,
          tx_buf,
          4,
          rx_buf
               );
 if ( error_code < 0 ) return error_code;
 adc_value = 0;
 for ( index = 1; index < 4; index++ ) adc_value = (adc_value << 8 ) + ( (uint32_t) rx_buf[index] );
 printf( "0x%08X\n", adc_value );
 return SUCCESS;
}



static int AS_Calibration_Value_Write( int board_id, size_t address, uint32_t value )
{
 int error_code;
 size_t index;
 size_t object_count;
 size_t count = 3;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 for ( index = 0; index < count; index++ )
 {
  tx_buf[index + 2] = (uint8_t)( value & 0xFF );
  value = value >> 8;
 }
 tx_buf[0] = 0x40;

 address = 0x0F & address;
 tx_buf[0] = tx_buf[0] + ( (uint8_t) address );
 tx_buf[1] = tx_buf[1] + ( (uint8_t) count );

 object_count = count + 2;
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id,
          1,
          object_count,
          tx_buf,
          object_count,
          rx_buf
               );
 return error_code;
}



static int AS_Calibration_Value_Read( int board_id, size_t address, uint32_t * value )
{
 int error_code;
 uint32_t value_temp;
 size_t index;
 size_t object_count;
 size_t count = 3;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 tx_buf[0] = 0x20;

 address = 0x0F & address;
 tx_buf[0] = tx_buf[0] + ( (uint8_t) address );
 tx_buf[1] = tx_buf[1] + ( (uint8_t) count );

 object_count = count + 2;
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id,
          1,
          object_count,
          tx_buf,
          object_count,
          rx_buf
               );
 if ( error_code < 0 ) return error_code;
 value_temp = 0;
 object_count--;
 for ( index = 0; index < count; index++ ) value_temp = ( value_temp << 8 ) + ( (uint32_t) rx_buf[object_count - index] );
 *value = value_temp;
 return SUCCESS;
}



static int AS_Registers_Read( int board_id, size_t address, size_t count, uint8_t * tx_buf, uint8_t * rx_buf )
{
 size_t object_count;
 int error_code;


 if ( ( address + count ) > AS_ADS1259_REGISTER_QTY ) return -EC_REGISTER_ADDRESS_EXCEEDED;

 count = 0x0F & count;
 address = 0x0F & address;
 tx_buf[0] = 0x20;
 tx_buf[0] = tx_buf[0] + ( (uint8_t) address );
 tx_buf[1] = tx_buf[1] + ( (uint8_t) count );


 object_count = count + 2;
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id,
          1,
          object_count,
          tx_buf,
          object_count,
          rx_buf
               );
 return error_code;
}



static int AS_Registers_Write( int board_id, size_t address, size_t count, uint8_t * tx_buf, uint8_t * rx_buf )
{
 size_t object_count;
 int error_code;


 count = 0x0F & count;
 address = 0x0F & address;
 tx_buf[0] = 0x40;
 tx_buf[0] = tx_buf[0] + ( (uint8_t) address );
 tx_buf[1] = tx_buf[1] + ( (uint8_t) count );


 object_count = count + 2;
 SPI_Configuration_Chip_Select_Behavior_Set( board_id, CSB_BUFFER );
 error_code = SPI_Data_Write_Read( board_id,
          1,
          object_count,
          tx_buf,
          object_count,
          rx_buf
               );
 return error_code;
}



static int CMD__AS_RReg( int board_id, int argc, char * argv[] )
{
 size_t count;
 size_t index;
 size_t address;
 int error_code;
 BOOL dump_as_hex;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 if ( argc < 1 ) return -EC_SYNTAX;

 index = 0;
 if ( ( 'a' == argv[0][0] ) || ( 'A' == argv[0][0] ) )
 {
  count = AS_ADS1259_REGISTER_QTY;
  address = AS_ADS1259_CONFIG0;
  index = 1;
 }
 else
 {
  if ( argc < 2 ) return -EC_SYNTAX;

  count = (size_t) strtol( argv[1], NULL, 0 );
  error_code = AS_Register_Name_To_Offset( argv[0] );
  if ( error_code < 0 )
  {
   address = (size_t) strtol( argv[0], NULL, 0 );
  }
  else
  {
   address = (size_t) error_code;
  }
  index = 2;
 }

 dump_as_hex = 0;
 if ( argc > index )
 {
  if ( ( 'h' == argv[index][0] ) || ( 'H' == argv[index][0] ) )
  {
   dump_as_hex = 1;
  }
 }

 error_code = AS_Registers_Read( board_id, address, count, tx_buf, rx_buf );
 if ( error_code < 0 ) return error_code;

 if ( dump_as_hex )
 {
  Hex_Dump_Line( (uint16_t) address, count, &(rx_buf[2]), stdout );
 }
 else
 {
  for ( index = 0; index < count; index++ )
  {
   printf( "%s=0x%02X", as_register_name[address + index], rx_buf[index + 2] );
   Bit_String_Report( as_bit_string, address + index, rx_buf[index + 2], stdout );
   printf( "\n" );
  }
 }
 return SUCCESS;
}



static int CMD__AS_WReg( int board_id, int argc, char * argv[] )
{
 size_t count;
 size_t index;
 size_t address;
 int error_code;
 BOOL not_done;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 if ( argc < 2 ) return -EC_SYNTAX;

 index = 0;
 if ( ( argv[index][0] >= '0' ) || ( argv[index][0] <= '9' ) )
 {
  address = (size_t) strtol( argv[index], NULL, 0 );
 }
 else
 {
  error_code = AS_Register_Name_To_Offset( argv[index] );
  if ( error_code < 0 ) return -EC_NOT_FOUND;
  address = (size_t) error_code;
 }
 index++;

 count = 0;
 not_done = 1;
 do
 {
  tx_buf[count + 2] = (size_t) strtol( argv[index], NULL, 0 );
  count++;
  index++;

  if ( count >= AS_ADS1259_REGISTER_QTY )
  {
   not_done = 0;
   error_code = -EC_EXTRA_IGNORED;
  }
  if ( index >= argc ) not_done = 0;
 } while ( not_done );

 error_code = AS_Registers_Write( board_id, address, count, tx_buf, rx_buf );
 return error_code;
}



static int CMD__AS_Reg_Write_By_Name( int board_id, int argc, char * argv[] )
{
 size_t count;
 size_t index;
 size_t address;
 size_t value;
 int error_code;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 if ( argc < 2 ) return -EC_SYNTAX;

 index = 0;
 while ( ( argc - index ) > 1 )
 {
  if ( (argc - index) > 1 )
  {
   if ( ( argv[index][0] >= '0' ) || ( argv[index][0] <= '9' ) )
   {
    address = (size_t) strtol( argv[index], NULL, 0 );
   }
   else
   {
    error_code = AS_Register_Name_To_Offset( argv[index] );
    if ( error_code < 0 ) return -EC_NOT_FOUND;
    address = (size_t) error_code;
   }
   index++;

   if ( ( argc - index ) > 0 )
   {
    value = (size_t) strtol( argv[index], NULL, 0 );
    tx_buf[2] = (uint8_t) value;
    count = 1;
    error_code = AS_Registers_Write( board_id, address, count, tx_buf, rx_buf );
   }
   else
   {
    return -EC_SYNTAX;
   }
   index++;
  }
  else
  {
   error_code = -EC_SYNTAX;
  }
 }

 if ( (argc - index) > 0 ) error_code = -EC_EXTRA_IGNORED;
 return error_code;
}



static int CMD__AS_Ofscal( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x18 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Gancal( int board_id, int argc, char * argv[] )
{
 uint8_t tx_buf[1] = { 0x19 };
 (void) argc;
 (void) argv;
 return AS_Opcode_Write( board_id, tx_buf, 1 );
}



static int CMD__AS_Calibration_Gain( int board_id, int argc, char * argv[] )
{
 uint32_t fsc;
 int error_code;

 if ( argc > 0 )
 {
  fsc = (uint32_t) strtol( argv[0], NULL, 0 );
  error_code = AS_Calibration_Value_Write( board_id, AS_ADS1259_OFC0, fsc );
  if ( error_code < 0 ) return error_code;
 }
 else
 {
  error_code = AS_Calibration_Value_Read( board_id, AS_ADS1259_OFC0, &fsc );
  if ( error_code < 0 ) return error_code;
  printf( "Full Scale Calibration (FSC) = 0x%08X, %u\n", fsc, fsc );
 }
 return SUCCESS;
}



static int CMD__AS_Calibration_Offset( int board_id, int argc, char * argv[] )
{
 uint32_t ofc;
 int error_code;

 if ( argc > 0 )
 {
  ofc = (uint32_t) strtol( argv[0], NULL, 0 );
  error_code = AS_Calibration_Value_Write( board_id, AS_ADS1259_OFC0, ofc );
 }
 else
 {
  error_code = AS_Calibration_Value_Read( board_id, AS_ADS1259_FSC0, &ofc );
  if ( error_code < 0 ) return error_code;
  printf( "Offset Calibration (OFC) = 0x%08X, %u\n", ofc, ofc );
 }
 return SUCCESS;
}



static int CMD__AS_Register_Save( int board_id, int argc, char * argv[] )
{
 int error_code;
 FILE * fd;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 if ( argc < 1 ) return -EC_SYNTAX;

 error_code = AS_Registers_Read( board_id, AS_ADS1259_CONFIG0, AS_ADS1259_REGISTER_QTY, tx_buf, rx_buf );
 if ( error_code < 0 ) return error_code;

 fd = fopen( argv[0], "w" );
 if ( NULL != fd )
 {
  void * data_pointer = (void *) &(rx_buf[2]);
  fwrite( data_pointer, AS_ADS1259_REGISTER_QTY, 1, fd );
  fclose( fd );
 }
 return SUCCESS;
}
# 6164 "idi.c"
static int CMD__AS_Register_Load( int board_id, int argc, char * argv[] )
{
 int error_code;
 FILE * fd;
 void * data_pointer = NULL;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 if ( argc < 1 ) return -EC_SYNTAX;

 fd = fopen( argv[0], "r" );
 if ( NULL == fd )
 {

 }
 else
 {
  size_t file_size;

  fseek( fd, 0L, SEEK_END );
  file_size = (size_t) ftell( fd );
  fseek( fd, 0L, SEEK_SET );
  if ( file_size != AS_ADS1259_REGISTER_QTY )
  {

  }
  else
  {
   data_pointer = (void *) &(tx_buf[2]);
   fread( data_pointer, AS_ADS1259_REGISTER_QTY, 1, fd );
  }
  fclose( fd );
 }

 error_code = AS_Registers_Write( board_id, AS_ADS1259_CONFIG0, AS_ADS1259_REGISTER_QTY, tx_buf, rx_buf );
 return error_code;
}



static int CMD__AS_Parameter( int board_id, int argc, char * argv[] )
{
 int error_code = SUCCESS;
    int argc_new;
    char ** argv_new;
 int index;
 uint8_t tx_buf[12] = { 0x00 };
 uint8_t rx_buf[12] = { 0x00 };

 if ( argc >= 2 )
 {
  if ( 0 == strcasecmp( "ofc", argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   error_code = CMD__AS_Calibration_Offset( board_id, argc_new, argv_new );
  }
  else if ( 0 == strcasecmp( "fsc", argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   error_code = CMD__AS_Calibration_Gain( board_id, argc_new, argv_new );
  }
  else if ( ( index = AS_Register_Name_To_Offset( argv[0] ) ) >= 0 )
  {
   error_code = CMD__AS_Reg_Write_By_Name( board_id, argc, argv );
  }
  else if ( ( index = Bit_String_Index_By_Name( as_bit_string, argv[0] ) ) >= 0 )
  {
   struct bit_string_info * bsd;
   size_t temp;
   uint8_t mask = 0;
   bsd = &(as_bit_string[index]);
   error_code = AS_Registers_Read( board_id, bsd->register_offset, 1, tx_buf, rx_buf );

   for ( temp = 0; temp < bsd->bit_width; temp++ ) mask = ( mask << 1 ) | 0x01;
   temp = (size_t) strtol( argv[1], NULL, 0 );
   temp = temp & mask;
   temp = temp << bsd->bit_offset;
   rx_buf[2] = rx_buf[2] & ~( mask << bsd->bit_offset );
   tx_buf[2] = rx_buf[2] | ( (uint8_t) temp );
   error_code = AS_Registers_Write( board_id, bsd->register_offset, 1, tx_buf, rx_buf );
  }
  else
  {
   error_code = -EC_NOT_FOUND;
  }
 }
 else if ( argc < 1 )
 {
  argv_new = &(argv[1]);
  argc_new = argc - 1;
  printf( "Calibration offset: " );
  error_code = CMD__AS_Calibration_Offset( board_id, argc_new, argv_new );
  if ( error_code < 0 ) goto CMD__AS_PARAMETER_END;
  printf( "Calibration gain: " );
  error_code = CMD__AS_Calibration_Gain( board_id, argc_new, argv_new );
  if ( error_code < 0 ) goto CMD__AS_PARAMETER_END;
  printf( "Registers:\n" );
  for ( index = 0; index < AS_ADS1259_REGISTER_QTY; index++ )
  {
   error_code = CMD__AS_RReg( board_id, 1, &(as_register_name[index]) );
   if ( error_code < 0 ) goto CMD__AS_PARAMETER_END;
  }

  printf( "Bit String Parameters:\n" );
  index = 0;
  while ( NULL != as_bit_string[index].name )
  {
   struct bit_string_info * bsd;
   size_t i;
   uint8_t mask = 0;
   bsd = &(as_bit_string[index]);
   error_code = AS_Registers_Read( board_id, bsd->register_offset, 1, tx_buf, rx_buf );
   if ( error_code < 0 ) goto CMD__AS_PARAMETER_END;

   for ( i = 0; i < bsd->bit_width; i++ ) mask = ( mask << 1 ) | 0x01;
   rx_buf[2] = rx_buf[2] >> bsd->bit_offset;
   rx_buf[2] = rx_buf[2] & mask;
   printf( " %8s = %d\n", bsd->name, (int) rx_buf[2] );

   index++;
  }
 }
 else
 {
  if ( 0 == strcasecmp( "ofc", argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   error_code = CMD__AS_Calibration_Offset( board_id, argc_new, argv_new );
  }
  else if ( 0 == strcasecmp( "fsc", argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   error_code = CMD__AS_Calibration_Gain( board_id, argc_new, argv_new );
  }
  else if ( ( index = AS_Register_Name_To_Offset( argv[0] ) ) >= 0 )
  {
   error_code = CMD__AS_RReg( board_id, argc, argv );
  }
  else if ( ( index = Bit_String_Index_By_Name( as_bit_string, argv[0] ) ) >= 0 )
  {
   struct bit_string_info * bsd;
   size_t i;
   uint8_t mask = 0;
   bsd = &(as_bit_string[index]);
   error_code = AS_Registers_Read( board_id, bsd->register_offset, 1, tx_buf, rx_buf );
   if ( error_code < 0 ) goto CMD__AS_PARAMETER_END;

   for ( i = 0; i < bsd->bit_width; i++ ) mask = ( mask << 1 ) | 0x01;
   rx_buf[2] = rx_buf[2] >> bsd->bit_offset;
   rx_buf[2] = rx_buf[2] & mask;
   printf( "%8s = %d\n", bsd->name, (int) rx_buf[2] );
  }
  else
  {
   error_code = -EC_NOT_FOUND;
  }
 }
CMD__AS_PARAMETER_END:
 return error_code;
}





static struct command_line_board cmd_as[] =
{
 { NULL, CMD__AS_Wakeup, "wakeup", "ADS1259 exit sleep mode" },
 { NULL, CMD__AS_Sleep, "sleep", "ADS1259 enter sleep mode" },
 { NULL, CMD__AS_Reset, "reset", "ADS1259 register and filter reset" },
 { NULL, CMD__AS_Start, "start", "ADS1259 start conversion(s)" },
 { NULL, CMD__AS_Stop, "stop", "ADS1259 stop conversions" },
 { NULL, CMD__AS_Rdatac, "rdatac", "ADS1259 set read data continuous mode" },
 { NULL, CMD__AS_Sdatac, "sdatac", "ADS1259 stop read data continuous mode" },
 { NULL, CMD__AS_Rdata, "rdata", "ADS1259 read data in stop continuous mode" },
 { NULL, CMD__AS_RReg, "rreg", "ADS1259 read N registers, rreg <address> <count>" },
 { NULL, CMD__AS_WReg, "wreg", "ADS1259 write N registers, wreg <adress> <value> [<value>]"},
 { NULL, CMD__AS_Ofscal, "ofscal", "ADS1259 perform offset calibration, apply zero input" },
 { NULL, CMD__AS_Gancal, "gancal", "ADS1259 perform full-scale calibration, apply full-scale" },
 { NULL, CMD__AS_Reg_Write_By_Name, "wrn", "Write one or more registers by name, wrn <name> <value>" },
 { NULL, CMD__AS_Calibration_Gain, "fsc", "read/write fullscale calibration" },
 { NULL, CMD__AS_Calibration_Offset, "ofc", "read/write offset calibration" },
 { NULL, CMD__AS_Register_Save, "rsave", "save all registers to a file" },
 { NULL, CMD__AS_Register_Load, "rload", "restore all registers from file" },
 { NULL, CMD__AS_Parameter, "param", "read/write parameter" },
 { NULL, NULL, NULL, NULL },
};






int Command_Line_Analog_Stick( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;

    error_code = -EC_SYNTAX;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 index = 0;
 while ( NULL != cmd_as[index].cmd_fnc )
 {
  if ( 0 == strcasecmp( cmd_as[index].name, argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_as[index].cmd_fnc )( board_id, argc_new, argv_new );
   break;
  }
  index++;
 }
 return error_code;
}
# 6400 "idi.c"
static int CMD__FRAM_Dump( int board_id, int argc, char * argv[] )
{
 uint16_t address;
 uint16_t length;

 if ( argc < 1 ) return -EC_PARAMETER;

 address = (uint16_t) strtol( argv[0], NULL, 0 );
 if ( address > ( FRAM_DENSITY_BYTES - 1 ) ) return -EC_FRAM_ADDRESS_RANGE;

 if ( argc < 2 ) length = HEX_DUMP_BYTES_PER_LINE;
 else length = (uint16_t) strtol( argv[1], NULL, 0 );

 if ( ( address + length ) > FRAM_DENSITY_BYTES ) length = FRAM_DENSITY_BYTES - address;

 return FRAM_Report( board_id, address, length, stdout );
}






static int CMD__FRAM_Save( int board_id, int argc, char * argv[] )
{
 int error_code;
 uint16_t address;
 size_t length;
 FILE * out;

 if ( argc < 3 ) return -EC_PARAMETER;

 address = (uint16_t) strtol( argv[0], NULL, 0 );
 if ( address > ( FRAM_DENSITY_BYTES - 1 ) ) return -EC_FRAM_ADDRESS_RANGE;

 length = (uint16_t) strtol( argv[1], NULL, 0 );
 if ( (address + length - 1) > ( FRAM_DENSITY_BYTES - 1 ) ) return -EC_FRAM_ADDRESS_RANGE;
 out = fopen( argv[2], "w" );
 error_code = FRAM_Memory_To_File( board_id, address, length, out );
 fclose( out );
 return error_code;
}






static int CMD__FRAM_Load( int board_id, int argc, char * argv[] )
{
 int error_code;
 uint16_t address;

 FILE * out;

 if ( argc < 2 ) return -EC_PARAMETER;

 address = (uint16_t) strtol( argv[0], NULL, 0 );
 if ( address > ( FRAM_DENSITY_BYTES - 1 ) ) return -EC_FRAM_ADDRESS_RANGE;
 out = fopen( argv[2], "r" );
 error_code = FRAM_File_To_Memory( board_id, address, 0 , out );
 fclose( out );
 return error_code;
}






static int CMD__FRAM_Write( int board_id, int argc, char * argv[] )
{
 int error_code;
 size_t count;
 uint16_t address;
 struct board_dataset * dataset;
 dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 if ( argc < 2 ) return -EC_PARAMETER;

 address = (uint16_t) strtol( argv[0], NULL, 0 );
 if ( address > ( FRAM_DENSITY_BYTES - 1 ) ) return -EC_FRAM_ADDRESS_RANGE;

 error_code = CMD__SPI_Data_Interpreter( 1,
            argc,
            argv,
            256,
            &count,
            dataset->spi.fram_block
             );
 if ( error_code ) return error_code;
 error_code = FRAM__Memory_Write( board_id, address, count, dataset->spi.fram_block );
 return error_code;
}






static int CMD__FRAM_Init( int board_id, int argc, char * argv[] )
{
 int error_code;

 size_t tx_size_in_bytes;
 struct board_dataset * dataset;
 dataset = ( struct board_dataset * ) board_definition[board_id].dataset;


 if ( argc < 1 )
 {
  error_code = FRAM_Set( board_id, 0, NULL );
 }
 else
 {
  CMD__SPI_Data_Interpreter( 0,
          argc,
          argv,
          256,
          &tx_size_in_bytes,
          dataset->spi.fram_block
          );
# 6534 "idi.c"
  error_code = FRAM_Set( board_id, tx_size_in_bytes, dataset->spi.fram_block );
 }
 return error_code;
}






static int CMD__FRAM_WREN( int board_id, int argc, char * argv[] )
{
 (void) argc;
 (void) argv;
 return FRAM__Write_Enable_Latch_Set( board_id );
}






static int CMD__FRAM_WRDI( int board_id, int argc, char * argv[] )
{
 (void) argc;
 (void) argv;
 return FRAM__Write_Disable( board_id );
}






static int CMD__FRAM_RDSR( int board_id, int argc, char * argv[] )
{
 int error_code;
 uint8_t status;
 (void) argc;
 (void) argv;
 error_code = FRAM__Read_Status_Register( board_id, &status );
 printf( "FRAM STATUS: 0x%02X\n", ((int) status) );
 return error_code;
}






static int CMD__FRAM_WRSR( int board_id, int argc, char * argv[] )
{

 uint8_t status;

 if ( argc < 1 ) return -EC_PARAMETER;
 status = (uint8_t) strtol( argv[0], NULL, 0 );
 return FRAM__Write_Status_Register( board_id, status );
}






static int CMD__FRAM_RDID( int board_id, int argc, char * argv[] )
{
 uint32_t id;
 (void) argc;
 (void) argv;
 FRAM__Read_ID( board_id, &id );



 printf( "FRAM ID: 0x%08X\n", id );

 return SUCCESS;
}




static struct command_line_board cmd_fram[] =
{
 { NULL, CMD__FRAM_Dump, "dump", "params: <address> <length>" },
 { NULL, CMD__FRAM_Save, "save", "params: <address> <length> <binary destination file>" },
 { NULL, CMD__FRAM_Load, "load", "params: <address> <binary source file name>" },
 { NULL, CMD__FRAM_Write, "write", "params: <address> <data list: bytes/characters/strings>" },
 { NULL, CMD__FRAM_Init, "init", "params: [byte/character] [byte/character] ..." },
 { NULL, CMD__FRAM_WREN, "wren", "WRite Enable Latch Set" },
 { NULL, CMD__FRAM_WRDI, "wrdi", "WRite DIsable" },
 { NULL, CMD__FRAM_RDSR, "rdsr", "ReaD Status Register" },
 { NULL, CMD__FRAM_WRSR, "wrsr", "WRite Status Register.  Params: <status>" },
 { NULL, CMD__FRAM_RDID, "rdid", "ReaD ID Register" },
 { NULL, NULL, NULL, NULL },
};






int Command_Line_FRAM( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;

    error_code = -EC_SYNTAX;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 index = 0;
 while ( NULL != cmd_fram[index].cmd_fnc )
 {
  if ( 0 == strcasecmp( cmd_fram[index].name, argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_fram[index].cmd_fnc )( board_id, argc_new, argv_new );
   break;
  }
  index++;
 }
 return error_code;
}


typedef enum
{
 TEST_STATE_INIT = 0x000,
 TEST_STATE_READY = 0x100,
 TEST_STATE_ACTIVE = 0x200,
 TEST_STATE_COMPLETE = 0xF00,
 TEST_STATE_QUIT_ERROR = 0xF10,
 TEST_STATE_QUIT_USER = 0xF20,
 TEST_STATE_QUIT = 0xFFF
} TEST_STATE_ENUM;
# 6691 "idi.c"
int IDO_DOUT_ID_Get( int board_id, uint16_t * id )
{
 uint8_t lsb, msb;

 IO_Read_U8( board_id, IDO_ID_LSB, &lsb );
 IO_Read_U8( board_id, IDO_ID_MSB, &msb );
 *id = ( ((uint16_t) msb) << 8 ) | ((uint16_t) lsb);



 return SUCCESS;
}
# 6711 "idi.c"
BOOL IDO_DOUT_IsNotPresent( int board_id )
{
 uint16_t id;
 IDO_DOUT_ID_Get( board_id, &id );
 if (ID_DOUT == id ) return 0;
 return 1;
}
# 6728 "idi.c"
int IDO_DO_Channel_Get( int board_id, size_t channel, BOOL * value )
{
 size_t group;
 size_t bit;
 uint8_t reg_value;

 group = channel >> 3;
 bit = channel - group * 8;

 IO_Read_U8( board_id, IDO_DO_GROUP0 + group , &reg_value );

 if ( 0 != ( reg_value & ( 0x01 << bit ) ) ) *value = 1;
 else *value = 0;

 return SUCCESS;
}
# 6754 "idi.c"
int IDO_DO_Channel_Set( int board_id, size_t channel, BOOL value )
{
 size_t group;
 size_t bit;
 uint8_t reg_value;
 uint8_t mask;

 group = channel >> 3;
 bit = channel - group * 8;

 IO_Read_U8( board_id, IDO_DO_GROUP0 + group , &reg_value );
 mask = 0x01 << bit;
 if ( 1 == value ) reg_value |= mask;
 else reg_value &= ~mask;

 IO_Write_U8( board_id, IDO_DO_GROUP0 + group , reg_value );
 return SUCCESS;
}
# 6782 "idi.c"
int IDO_DO_Group_Get( int board_id, size_t group, uint8_t * value )
{
 IO_Read_U8( board_id, IDO_DO_GROUP0 + group , value );
 return SUCCESS;
}
# 6797 "idi.c"
int IDO_DO_Group_Set( int board_id, size_t group, uint8_t value )
{
 IO_Write_U8( board_id, IDO_DO_GROUP0 + group , value );
 return SUCCESS;
}





static int Print_Byte_List( const char * prefix_string,
       int argc,
       char ** argv,
       size_t list_count,
       uint8_t * list,
       FILE * out
        )
{
 enum { MODE_NONE = 0, MODE_BINARY = 1, MODE_HEX = 2, MODE_ALL = 3 } mode_out;
 int group;

 mode_out = MODE_ALL;
 if ( NULL == argv )
 {
  mode_out = MODE_ALL;
 }
 else
 {
  int index;
  for ( index = 0; index < argc; index++ )
  {
   if ( 0 == strcasecmp( "binary", argv[index] ) ) mode_out |= MODE_BINARY;
   else if ( 0 == strcasecmp( "group", argv[index] ) ) mode_out |= MODE_HEX;
   else if ( 0 == strcasecmp( "hex", argv[index] ) ) mode_out |= MODE_HEX;
   else mode_out |= MODE_ALL;
  }
 }

 if ( MODE_BINARY == ( mode_out & MODE_BINARY ) )
 {
  int cp;
  int channel;
  uint8_t mask;
  char message[64];

  cp = 0;
  group = 0;
  for ( group = 0; group < list_count; group++ )
  {
   mask = 0x01;
   for ( channel = 0; channel < 8; channel++ )
   {
    message[cp++] = !!(list[group] & mask) ? '1' : '0';
    mask = mask << 1;
   }
   message[cp++] = ' ';
  }
  message[cp] = '\0';
  fprintf( out, "%s: %s\n", prefix_string, message );
 }

 if ( MODE_HEX == ( mode_out & MODE_HEX ) )
 {
  fprintf( out, "%s:", prefix_string );
  for ( group = 0; group < list_count; group++ ) fprintf( out, " %02X", list[group] );
  fprintf( out, "\n" );
 }

 return SUCCESS;
}
# 6875 "idi.c"
static int IDO48_IDI48_Loopback_Test( int di_id, int do_id, uint8_t * di_list, uint8_t * do_list, size_t count )
{
 int group;
 for( group = 0; group < count; group++ )
 {
  IDO_DO_Group_Get( do_id, group, &(do_list[group]) );
  IDI_DIN_Group_Get( di_id, group, &(di_list[group]) );
  if ( di_list[group] != do_list[group] ) return -group;
 }
 return SUCCESS;
}



static int IDO48_IDI48_Loopback_Test_Output( char * message, FILE * out )
{
 int error_code;

 error_code = fprintf( stdout, message );
 if ( out != stdout )
 {
  error_code = fprintf( out, message );
 }
 return error_code;
}



static int CMD__IDO48_IDI48_Loopback( int board_id, int argc, char * argv[] )
{
 int error_code;
 struct ido_dataset * dataset;
 FILE * out;
 char * file_name;
 TEST_STATE_ENUM state;
 size_t group;
 size_t channel;
 BOOL di_value;
 BOOL do_value;



 uint8_t do_list[6];
 uint8_t di_list[6];
 uint8_t dog[6];
 char * mode_string[] = { "binary" };
 char out_default[] = { "stdout" };
 char * msg;

 state = TEST_STATE_INIT;
 dataset = NULL;
 switch( board_id )
 {
  case ID_IDO48:
   dataset = ( struct ido_dataset * ) board_definition[board_id].dataset;
   break;
  default:
   return -EC_BOARD_TYPE;
 }




 out = stdout;
 file_name = out_default;
 if ( argc > 0 )
 {
  out = fopen( argv[0], "w" );
  file_name = argv[0];
 }






 msg = &(dataset->message[0]);
 sprintf( msg, "=============================================\n" );
 IDO48_IDI48_Loopback_Test_Output( msg, out );

 sprintf( msg, "IDO48-IDI48 loopback test: %s", file_name );
 IDO48_IDI48_Loopback_Test_Output( msg, out );


 for( group = 0; group < 6; group++ )
 {
  do_list[group] = 0x00;
  IDO_DO_Group_Set( board_id, group, do_list[group] );



  IDI_DIN_Group_Get( ID_IDI48, group, &(di_list[group]) );
 }
 error_code = IDO48_IDI48_Loopback_Test( ID_IDI48, board_id, di_list, do_list, 6 );
 if ( error_code < 0 )
 {
  state = TEST_STATE_QUIT;
 }

 state = TEST_STATE_ACTIVE;
 channel = 0;
 while ( TEST_STATE_ACTIVE == state )
 {
  do_value = 1;
  IDO_DO_Channel_Set( board_id, channel, do_value );



  IDI_DIN_Channel_Get( ID_IDI48, channel, &di_value );

  if ( do_value != di_value )
  {
   state = TEST_STATE_QUIT_ERROR;
  }
  error_code = IDO48_IDI48_Loopback_Test( ID_IDI48, board_id, di_list, do_list, 6 );
  if ( error_code < 0 )
  {
   state = TEST_STATE_QUIT_ERROR;
  }


  do_value = 0;
  IDO_DO_Channel_Set( board_id, channel, do_value );



  IDI_DIN_Channel_Get( ID_IDI48, channel, &di_value );

  if ( do_value != di_value )
  {
   state = TEST_STATE_QUIT_ERROR;
  }
  error_code = IDO48_IDI48_Loopback_Test( ID_IDI48, board_id, di_list, do_list, 6 );
  if ( error_code < 0 )
  {
   state = TEST_STATE_QUIT_ERROR;
  }

  if ( 1 == Character_Get( NULL ) ) state = TEST_STATE_QUIT_USER;

  if ( TEST_STATE_ACTIVE == state )
  {
   channel++;
   sprintf( msg, "." );
   IDO48_IDI48_Loopback_Test_Output( msg, out );
   if ( channel >= ( 8 * 6 ) ) state = TEST_STATE_COMPLETE;
  }
 }
 sprintf( msg, "\n" );
 IDO48_IDI48_Loopback_Test_Output( msg, out );
 switch( state )
 {
  case TEST_STATE_COMPLETE:
   sprintf( msg, "PASS\n" );
   IDO48_IDI48_Loopback_Test_Output( msg, out );
   error_code = SUCCESS;
   break;
  case TEST_STATE_QUIT_ERROR:
   sprintf( msg, "FAIL at channel %d\n", (int) channel );
   IDO48_IDI48_Loopback_Test_Output( msg, out );
   error_code = EC_TEST_FAIL;

   for( group = 0; group < 6; group++ )
   {
    IDO_DO_Group_Get( board_id, group, &(dog[group]) );
   }
   Print_Byte_List( "DO:",
        1,
        mode_string,
        6,
        dog,
        stdout
         );

   if ( out != stdout )
   {
    Print_Byte_List( "DO:",
         1,
         mode_string,
         6,
         dog,
         out
          );
   }
   break;
  case TEST_STATE_QUIT_USER:
   sprintf( msg, "CANCEL BY USER at channel %d\n", (int) channel );
   IDO48_IDI48_Loopback_Test_Output( msg, out );
   error_code = EC_TEST_FAIL;
   break;
  default:
   break;
 }
 return SUCCESS;
}






static int CMD__IDO48_DOUT_Test_Alternate( int board_id, int argc, char * argv[] )
{
 TEST_STATE_ENUM state;
 size_t group;




 uint8_t pattern;
 uint8_t dog[6];
 char * mode_string[] = { "binary" };

 state = TEST_STATE_INIT;




 pattern = 0x55;

 if ( argc > 0 )
 {
  pattern = (uint8_t) strtol( argv[0], NULL, 0 );
 }

 if ( argc > 1 )
 {
  if ( 0 == strcasecmp( "time", argv[1] ) )
  {
   if ( argc > 2 )
   {



   }
   else if ( argc > 3 )
   {



   }
  }
 }


 for( group = 0; group < 6; group++ )
 {
  IDO_DO_Group_Set( board_id, group, 0x00 );
  dog[group] = 0x00;
 }

 state = TEST_STATE_ACTIVE;
 printf( "IDO48 Alternating sequence testing (press any key to quit):" );
 while ( TEST_STATE_ACTIVE == state )
 {
  for( group = 0; group < 6; group++ )
  {
   IDO_DO_Group_Set( board_id, group, pattern );
   dog[group] = pattern;
  }

  for( group = 0; group < 6; group++ )
  {
   IDO_DO_Group_Get( board_id, group, &(dog[group]) );
  }
  Print_Byte_List( "DO:",
       1,
       mode_string,
       6,
       dog,
       stdout
        );




  for( group = 0; group < 6; group++ )
  {
   IDO_DO_Group_Set( board_id, group, ~pattern );
   dog[group] = ~pattern;
  }

  for( group = 0; group < 6; group++ )
  {
   IDO_DO_Group_Get( board_id, group, &(dog[group]) );
  }
  Print_Byte_List( "DO:",
       1,
       mode_string,
       6,
       dog,
       stdout
        );



  if ( 1 == Character_Get( NULL ) ) state = TEST_STATE_QUIT_USER;
 }


 for( group = 0; group < 6; group++ )
 {
  IDO_DO_Group_Set( board_id, group, 0x00 );
 }
 return SUCCESS;
}




static int CMD__IDO48_DOUT_Test_One_Hot( int board_id, int argc, char * argv[] )
{
 TEST_STATE_ENUM state;
 size_t group;
 size_t channel;




 uint8_t dog[6];
 char * mode_string[] = { "binary" };

 state = TEST_STATE_INIT;




 if ( argc > 0 )
 {



 }
 else if ( argc > 1 )
 {



 }


 for( group = 0; group < 6; group++ )
 {
  dog[group] = 0x00;
  IDO_DO_Group_Set( board_id, group, dog[group] );
 }

 state = TEST_STATE_ACTIVE;
 printf( "IDO48 One-hot sequence testing (press any key to quit):" );
 channel = 0;
 while ( TEST_STATE_ACTIVE == state )
 {
  IDO_DO_Channel_Set( board_id, channel, 1 );

  for( group = 0; group < 6; group++ )
  {
   IDO_DO_Group_Get( board_id, group, &(dog[group]) );
  }
  Print_Byte_List( "DO:",
       1,
       mode_string,
       6,
       dog,
       stdout
        );




  IDO_DO_Channel_Set( board_id, channel, 0 );




  for( group = 0; group < 6; group++ )
  {
   IDO_DO_Group_Get( board_id, group, &(dog[group]) );
  }
  Print_Byte_List( "DO:",
       1,
       mode_string,
       6,
       dog,
       stdout
        );

  if ( 1 == Character_Get( NULL ) ) state = TEST_STATE_QUIT_USER;
  channel++;
  if ( channel >= ( 8 * 6 ) ) channel = 0;
 }


 for( group = 0; group < 6; group++ )
 {
  IDO_DO_Group_Set( board_id, group, 0x00 );
 }
 return SUCCESS;
}



static struct command_line_board cmd_ido48_test[] =
{
 { NULL, CMD__IDO48_DOUT_Test_One_Hot, "onehot", "toggling one at a time forever" },
 { NULL, CMD__IDO48_DOUT_Test_Alternate, "alternate", "alternate pattern at all ports forever" },

 { NULL, CMD__IDO48_IDI48_Loopback, "loopback", "IDI48 & IDO48 Loopback test" },

 { NULL, NULL, NULL, NULL },
};






static int CMD__IDO48_Test( int board_id, int argc, char * argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;
    char * endptr;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 error_code = -EC_SYNTAX;

 strtol( argv[0], &endptr, 0 );
 if ( argv[0] != endptr )
 {
  error_code = (* cmd_ido48_test[0].cmd_fnc )( board_id, argc, argv );
 }
 else
 {
  index = 0;
  while ( NULL != cmd_ido48_test[index].cmd_fnc )
  {
   if ( 0 == strcasecmp( cmd_ido48_test[index].name, argv[0] ) )
   {
    argv_new = &(argv[1]);
    argc_new = argc - 1;
    if ( 0 == argc_new ) argv_new = NULL;
    error_code = (* cmd_ido48_test[index].cmd_fnc )( board_id, argc_new, argv_new );
    break;
   }
   index++;
  }
 }
 return error_code;
}






static int CMD__IDO48_DO_ID( int board_id, int argc, char * argv[] )
{
 uint16_t id;
 (void) argc;
 (void) argv;
 IDO_DOUT_ID_Get( board_id, &id );
 printf( "IDO48 DOUT ID: 0x%04X\n", id );
 return SUCCESS;
}





static int CMD__IDO48_DO_All( int board_id, int argc, char * argv[] )
{

 int error_code;
 size_t group;
 uint8_t do_grp[6];



 for ( group = 0; group < 6; group++ )
 {
  error_code = IDO_DO_Group_Get( board_id, group, &(do_grp[group]) );
 }

 Print_Byte_List( "DO:",
      argc,
      argv,
      6,
      do_grp,
      stdout
       );
 return SUCCESS;
}






static int CMD__IDO48_DO_Channel( int board_id, int argc, char * argv[] )
{
 int error_code;
 int channel;
 char message[8];
 BOOL value;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 channel = (int) strtol( argv[0], NULL, 0 );

 if ( argc < 2 )
 {
  error_code = IDO_DO_Channel_Get( board_id, channel, &value );
  message[0] = value ? '1' : '0';
  message[1] = '\0';
  printf( "DO%02d: %s\n", channel, message );
 }
 else
 {
  value = String_To_Bool( argv[1] );
  error_code = IDO_DO_Channel_Set( board_id, channel, value );
 }
 return SUCCESS;
}






static int CMD__IDO48_DO_Group( int board_id, int argc, char * argv[] )
{
 int error_code;
 int group;
 int group_start;
 int group_end;

 BOOL read_cycle;
 uint8_t do_grp[6];


 if ( argc < 1 )
 {
  group_start = 0;
  group_end = 6 - 1;

  read_cycle = 1;
 }
 else if ( argc > 1 )
 {
  group_start = (int) strtol( argv[0], NULL, 0 );
  if ( group_start >= 6 ) return -EC_CHANNEL;
  group_end = 6 - 1;

  read_cycle = 0;
 }
 else
 {
  group_start = (int) strtol( argv[0], NULL, 0 );
  if ( group_start >= 6 ) return -EC_CHANNEL;
  group_end = group_start + 1;

  read_cycle = 1;
 }

 if ( 1 == read_cycle )
 {
  for ( group = group_start; group < group_end; group++ )
  {
   error_code = IDO_DO_Group_Get( board_id, group, &(do_grp[group]) );
  }

  printf( "DO_GROUP:" );
  for ( group = group_start; group < group_end; group++ )
  {
   printf( " 0x%02X", ((int) do_grp[group]) );
  }
  printf( "\n" );
 }
 else
 {
  int index;
  group_end = group_start;
  group = group_start;
  for ( index = 1; index < argc; index++ )
  {
   do_grp[group] = (int) strtol( argv[index], NULL, 0 );
   group++;
   group_end++;
   if ( group >= 6 ) break;
  }

  for ( group = group_start; group < group_end; group++ )
  {
   error_code = IDO_DO_Group_Set( board_id, group, do_grp[group] );
  }
 }
 return SUCCESS;
}



static struct command_line_board cmd_ido48[] =
{
 { NULL, CMD__IDO48_DO_ID, "id", "params: none.  Reports the DOUT board/component ID." },
 { NULL, CMD__IDO48_DO_Channel, "chan", "params: <channel> <value>" },
 { NULL, CMD__IDO48_DO_Group, "group", "params: [<group_channel | all>]" },
 { NULL, CMD__IDO48_DO_All, "all", "gets all digital outputs in binary and hex" },
 { cmd_ido48_test, CMD__IDO48_Test, "test", "semi-auto test functions" },
 { NULL, NULL, NULL, NULL }
};






int Command_Line_IDO48( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;
    char * endptr;


 if ( argc < 1 ) return -EC_NOT_FOUND;

 if ( ID_IDO48 != board_id ) return -EC_BOARD_TYPE;

 error_code = -EC_SYNTAX;


 strtol( argv[0], &endptr, 0 );
 if ( argv[0] != endptr )
 {
  error_code = (* cmd_ido48[0].cmd_fnc )( board_id, argc, argv );
 }
 else
 {
  index = 0;
  while ( NULL != cmd_ido48[index].cmd_fnc )
  {
   if ( 0 == strcasecmp( cmd_ido48[index].name, argv[0] ) )
   {
    argv_new = &(argv[1]);
    argc_new = argc - 1;
    if ( 0 == argc_new ) argv_new = NULL;
    error_code = (* cmd_ido48[index].cmd_fnc )( board_id, argc_new, argv_new );
    break;
   }
   index++;
  }
 }
 return error_code;
}
# 7554 "idi.c"
static BOOL CMD__IDI48_DIN_Helper_All_Values_False( uint8_t * dg, size_t group_qty )
{
 size_t group;

 for ( group = 0; group < group_qty; group++ )
 {
  if ( 0x00 != dg[group] ) return 0;
 }
 return 1;
}






static int CMD__IDI48_DIN_Test_Value( int board_id, int argc, char * argv[] )
{
 int error_code;
 TEST_STATE_ENUM state;
 size_t group;
 size_t bit;
 size_t index;
 uint8_t result;
 uint8_t dig[6];
 uint8_t dig_prev[6];
 uint8_t group_change;
 uint8_t mask;
 BOOL din_cmplt[( 8 * 6 )];
 (void) argc;
 (void) argv;

 state = TEST_STATE_INIT;

 for( group = 0; group < 6; group++ )
 {
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  dig_prev[group] = dig[group];
 }
 for ( bit = 0; bit < ( 8 * 6 ); bit++ ) din_cmplt[bit] = 0;

 printf( "DIN_TEST_VALUE:" );
 while ( ( TEST_STATE_QUIT != state ) && ( TEST_STATE_COMPLETE != state ) )
 {
  for ( group = 0; group < 6; group++ ) IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  switch( state )
  {
   case TEST_STATE_INIT:
    if ( 1 == CMD__IDI48_DIN_Helper_All_Values_False( dig, 6 ) )
    {
     state = TEST_STATE_READY;
     printf( " READY" );
    }
    break;
   case TEST_STATE_READY:
    printf( " " );
    state = TEST_STATE_ACTIVE;
    break;
   case TEST_STATE_ACTIVE:
    for ( group = 0; group < 6; group++ )
    {
     group_change = dig[group] ^ dig_prev[group];
     if ( 0x00 != group_change )
     {
      mask = 0x01;
      for ( bit = 0; bit < 8; bit++ )
      {
       index = bit + group * 8;
       if ( ( 0x00 != ( mask & group_change ) ) && ( 0 == din_cmplt[index] ) )
       {
        din_cmplt[index] = 1;
        printf( "." );
       }
       mask = mask << 1;
      }
     }
    }
    result = 1;
    for ( bit = 0; bit < ( 8 * 6 ); bit++ ) result = result & din_cmplt[bit];
    if ( 1 == result ) state = TEST_STATE_COMPLETE;
    break;
   case TEST_STATE_COMPLETE:
    break;
   case TEST_STATE_QUIT:
    break;
   default:
    break;
  }
  if ( 1 == Character_Get( NULL ) )
  {
   state = TEST_STATE_QUIT;
  }
  for ( group = 0; group < 6; group++ ) dig_prev[group] = dig[group];
 }

 if ( TEST_STATE_QUIT == state )
 {
  printf( " FAIL" ); error_code = EC_TEST_FAIL;
 }
 else
 {
  printf( " PASS" ); error_code = SUCCESS;
 }

 printf( "\n" );

 return error_code;
}




static int CMD__IDI48_DIN_Test_RE( int board_id, int argc, char * argv[] )
{
 int error_code;
 TEST_STATE_ENUM state;
 size_t group;
 size_t bit;
 size_t index;
 uint8_t result;
 uint8_t dig[6];
 uint8_t pending[6];
 uint8_t mask;
 BOOL din_cmplt[( 8 * 6 )];

 char message[64];
 int cp;
 int state_detect;

 (void) argc;
 (void) argv;

 state = TEST_STATE_INIT;

 for( group = 0; group < 6; group++ )
 {
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  IO_Write_U8( board_id, IDI_EDGE_GROUP0 + group, 0xFF );
  IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
  IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
 }
 for ( bit = 0; bit < ( 8 * 6 ); bit++ ) din_cmplt[bit] = 0;

 printf( "DIN_TEST_RISING_EDGE:" );
 for ( group = 0; group < 6; group++ )
 {
  IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  IO_Write_U8( board_id, IDI_INTR_BIT_GROUP0 + group, 0xFF );
 }
 while ( ( TEST_STATE_QUIT != state ) && ( TEST_STATE_COMPLETE != state ) )
 {
  switch( state )
  {
   case TEST_STATE_INIT:
    if ( 1 == CMD__IDI48_DIN_Helper_All_Values_False( dig, 6 ) )
    {
     state = TEST_STATE_READY;
     printf( " READY" );
    }
    for ( group = 0; group < 6; group++ ) IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
    break;
   case TEST_STATE_READY:

    cp = 0;
    strcpy( message, "" );
    state_detect = 2;
    printf( "\nPENDING:" );
    for ( group = 0; group < 6; group++ )
    {
     printf( " 0x%02X", pending[group] );
    }



    state = TEST_STATE_ACTIVE;
    break;
   case TEST_STATE_ACTIVE:
    for ( group = 0; group < 6; group++ )
    {
     if ( 0x00 != pending[group] )
     {
      mask = 0x01;
      for ( bit = 0; bit < 8; bit++ )
      {
       index = bit + group * 8;
       if ( ( 0x00 != (mask & pending[group]) ) && ( 0x00 != (dig[group] & mask) ) )
       {
        if ( 0 == din_cmplt[index] )
        {
         din_cmplt[index] = 1;


cp += sprintf( &(message[cp]), " [%2d]", (int) index );
state_detect = 1;



        }
       }
       mask = mask << 1;
      }
      IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
     }
    }

if ( state_detect < 3 )
{
 printf( "\nPENDING:" );
 for ( group = 0; group < 6; group++ )
 {
  printf( " 0x%02X", pending[group] );
 }
 printf( "   " );
 printf( "%s", message );
 cp = 0;
 state_detect++;
}
strcpy( message, "" );

    result = 1;
    for ( bit = 0; bit < ( 8 * 6 ); bit++ ) result = result & din_cmplt[bit];
    if ( 1 == result ) state = TEST_STATE_COMPLETE;

    for ( group = 0; group < 6; group++ )
    {
     IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
     IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
    }
    break;
   case TEST_STATE_COMPLETE:

    strcpy( message, "" );
    printf( "\nPENDING:" );
    for ( group = 0; group < 6; group++ )
    {
     printf( " 0x%02X", pending[group] );
    }
    printf( "   " );
    printf( "\n" );

    break;
   case TEST_STATE_QUIT:
    break;
   default:
    break;
  }
  if ( 1 == Character_Get( NULL ) )
  {
   state = TEST_STATE_QUIT;
  }
 }


 for ( group = 0; group < 6; group++ )
 {
  IO_Write_U8( board_id, IDI_INTR_BIT_GROUP0 + group, 0x00 );
 }

 if ( TEST_STATE_QUIT == state )
 {
  printf( " FAIL" ); error_code = EC_TEST_FAIL;
 }
 else
 {
  printf( " PASS" ); error_code = SUCCESS;
 }

 printf( "\n" );

 return error_code;
}




static int CMD__IDI48_DIN_Test_FE( int board_id, int argc, char * argv[] )
{
 int error_code;
 TEST_STATE_ENUM state;
 size_t group;
 size_t bit;
 size_t index;
 uint8_t result;
 uint8_t dig[6];
 uint8_t pending[6];
 uint8_t mask;
 BOOL din_cmplt[( 8 * 6 )];

 char message[64];
 int cp;
 int state_detect;

 (void) argc;
 (void) argv;

 state = TEST_STATE_INIT;

 for( group = 0; group < 6; group++ )
 {
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  IO_Write_U8( board_id, IDI_EDGE_GROUP0 + group, 0x00 );
  IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
  IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
 }
 for ( bit = 0; bit < ( 8 * 6 ); bit++ ) din_cmplt[bit] = 0;

 printf( "DIN_TEST_FALLING_EDGE:" );
 for ( group = 0; group < 6; group++ )
 {
  IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  IO_Write_U8( board_id, IDI_INTR_BIT_GROUP0 + group, 0xFF );
 }
 while ( ( TEST_STATE_QUIT != state ) && ( TEST_STATE_COMPLETE != state ) )
 {
  switch( state )
  {
   case TEST_STATE_INIT:
    if ( 1 == CMD__IDI48_DIN_Helper_All_Values_False( dig, 6 ) )
    {
     state = TEST_STATE_READY;
     printf( " READY" );
    }
    for ( group = 0; group < 6; group++ ) IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
    break;
   case TEST_STATE_READY:

    cp = 0;
    strcpy( message, "" );
    state_detect = 2;
    printf( "\nPENDING:" );
    for ( group = 0; group < 6; group++ )
    {
     printf( " 0x%02X", pending[group] );
    }



    state = TEST_STATE_ACTIVE;
    break;
   case TEST_STATE_ACTIVE:
    for ( group = 0; group < 6; group++ )
    {
     if ( 0x00 != pending[group] )
     {
      mask = 0x01;
      for ( bit = 0; bit < 8; bit++ )
      {
       index = bit + group * 8;
       if ( ( 0x00 != (mask & pending[group]) ) && ( 0x00 == (dig[group] & mask) ) )
       {
        if ( 0 == din_cmplt[index] )
        {
         din_cmplt[index] = 1;


cp += sprintf( &(message[cp]), " [%2d]", (int) index );
state_detect = 1;



        }
       }
       mask = mask << 1;
      }
      IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
     }
    }

if ( state_detect < 3 )
{
 printf( "\nPENDING:" );
 for ( group = 0; group < 6; group++ )
 {
  printf( " 0x%02X", pending[group] );
 }
 printf( "   " );
 printf( "%s", message );
 cp = 0;
 state_detect++;
}
strcpy( message, "" );

    result = 1;
    for ( bit = 0; bit < ( 8 * 6 ); bit++ ) result = result & din_cmplt[bit];
    if ( 1 == result ) state = TEST_STATE_COMPLETE;

    for ( group = 0; group < 6; group++ )
    {
     IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
     IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
    }
    break;
   case TEST_STATE_COMPLETE:

    strcpy( message, "" );
    printf( "\nPENDING:" );
    for ( group = 0; group < 6; group++ )
    {
     printf( " 0x%02X", pending[group] );
    }
    printf( "   " );
    printf( "\n" );

    break;
   case TEST_STATE_QUIT:
    break;
   default:
    break;
  }
  if ( 1 == Character_Get( NULL ) )
  {
   state = TEST_STATE_QUIT;
  }
 }


 for ( group = 0; group < 6; group++ )
 {
  IO_Write_U8( board_id, IDI_INTR_BIT_GROUP0 + group, 0x00 );
 }

 if ( TEST_STATE_QUIT == state )
 {
  printf( " FAIL" ); error_code = EC_TEST_FAIL;
 }
 else
 {
  printf( " PASS" ); error_code = SUCCESS;
 }

 printf( "\n" );

 return error_code;
}
# 8059 "idi.c"
static int CMD__IDI48_DIN_Test_Interrupt( int board_id, int argc, char * argv[] )
{
 struct idi_dataset * idi_dataset;

 int error_code;
 TEST_STATE_ENUM state;
 size_t group;
 size_t bit;
 size_t index;
 size_t irq_count_local;
 uint8_t result;
 uint8_t irq_pending_local;
 uint8_t dig[6];
 uint8_t pending[6];
 uint8_t mask;
 BOOL io_report_backup, io_simulate_backup;
 BOOL din_cmplt[( 8 * 6 )];

 char message[64];
 int cp;
 int state_detect;
# 8102 "idi.c"
 (void) argc;
 (void) argv;

 switch( board_id )
 {
  case ID_IDI48:
   idi_dataset = ( struct idi_dataset * ) board_definition[board_id].dataset;
   break;
  default:
   return -EC_BOARD;
 }


 IO_Write_U8( board_id, IDI_SPI_CONFIG, 0 );
 io_report_backup = idi_dataset->io_report;
 io_simulate_backup = idi_dataset->io_simulate;

 idi_dataset->irq_count_previous = 0;
 idi_dataset->irq_count = 0;

 state = TEST_STATE_INIT;
 irq_pending_local = 0;
 irq_count_local = 0;


 for( group = 0; group < 6; group++ )
 {
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
  IO_Write_U8( board_id, IDI_EDGE_GROUP0 + group, 0xFF );
  IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
  IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
 }
 for ( bit = 0; bit < ( 8 * 6 ); bit++ ) din_cmplt[bit] = 0;

 printf( "DIN_INTERRUPT:" );
 for ( group = 0; group < 6; group++ )
 {
  IO_Read_U8( board_id, IDI_PEND_GROUP0 + group, &(pending[group]) );
  IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
 }
# 8155 "idi.c"
 state = TEST_STATE_QUIT;
 error_code = -EC_INTERRUPT_UNAVAILABLE;
 goto CMD__IDI48_DIN_Test_Interrupt_Terminate;



 for ( group = 0; group < 6; group++ )
 {
  IO_Write_U8( board_id, IDI_INTR_BIT_GROUP0 + group, 0xFF );
 }

 idi_dataset->irq_handler_active = 1;

 while ( ( TEST_STATE_QUIT != state ) && ( TEST_STATE_COMPLETE != state ) )
 {

  switch( state )
  {
   case TEST_STATE_INIT:
    for ( group = 0; group < 6; group++ )
    {
     IDI_DIN_Group_Get( board_id, group, &(dig[group]) );
    }
    if ( 1 == CMD__IDI48_DIN_Helper_All_Values_False( dig, 6 ) )
    {
     state = TEST_STATE_READY;
     printf( " READY" );
    }
    for ( group = 0; group < 6; group++ ) IO_Write_U8( board_id, IDI_CLEAR_GROUP0 + group, 0xFF );
    break;
   case TEST_STATE_READY:

    cp = 0;
    strcpy( message, "" );
    state_detect = 2;
    printf( "\nPENDING:" );
    for ( group = 0; group < 6; group++ )
    {
     printf( " 0x%02X", pending[group] );
    }



    state = TEST_STATE_ACTIVE;
    break;
   case TEST_STATE_ACTIVE:

    if ( 1 == Character_Get( NULL ) ) state = TEST_STATE_QUIT;




    irq_count_local = idi_dataset->irq_count;
    for ( group = 0; group < 6; group++ )
    {
     pending[group] = idi_dataset->isr_pending_list[group];
     if ( 0 != pending[group] ) irq_pending_local++;
    }




    if ( irq_count_local != idi_dataset->irq_count_previous )
    {
     if ( irq_count_local > idi_dataset->irq_count_previous )
     {
      index = irq_count_local - idi_dataset->irq_count_previous;
     }
     else
     {
      index = UINT_MAX - idi_dataset->irq_count_previous;
      index = index + irq_count_local + 1;
     }
     idi_dataset->irq_count_previous = irq_count_local;
     irq_count_local = index;
    }
    else
    {
     irq_count_local = 0;
     irq_pending_local = 0;
    }

    if ( irq_count_local > 0 )
    {

cp += sprintf( &(message[cp]), " {%2d}", (int) irq_count_local );

     for ( group = 0; group < 6; group++ )
     {
      if ( 0x00 != pending[group] )
      {
       mask = 0x01;
       for ( bit = 0; bit < 8; bit++ )
       {
        index = bit + group * 8;
        if ( 0x00 != (mask & pending[group]) )
        {
         if ( 0 == din_cmplt[index] )
         {
          din_cmplt[index] = 1;

cp += sprintf( &(message[cp]), " [%2d]", (int) index );
state_detect = 1;



         }
        }
        mask = mask << 1;
       }
      }
     }
    }

if ( state_detect < 3 )
{
 printf( "\nPENDING:" );
 for ( group = 0; group < 6; group++ )
 {
  printf( " 0x%02X", pending[group] );
 }
 printf( "   " );
 printf( "%s", message );
 cp = 0;
 state_detect++;
}
strcpy( message, "" );

    result = 1;
    for ( bit = 0; bit < ( 8 * 6 ); bit++ ) result = result & din_cmplt[bit];
    if ( 1 == result ) state = TEST_STATE_COMPLETE;
    break;
   case TEST_STATE_COMPLETE:

    strcpy( message, "" );
    printf( "\nPENDING:" );
    for ( group = 0; group < 6; group++ )
    {
     printf( " 0x%02X", pending[group] );
    }
    printf( "   " );
    printf( "\n" );

    break;
   case TEST_STATE_QUIT:
    break;
   default:
    break;
  }
  if ( 1 == Character_Get( NULL ) )
  {
   state = TEST_STATE_QUIT;
  }
 }


 for ( group = 0; group < 6; group++ )
 {
  IO_Write_U8( board_id, IDI_INTR_BIT_GROUP0 + group, 0x00 );
 }






CMD__IDI48_DIN_Test_Interrupt_Terminate:

 idi_dataset->io_report = io_report_backup;
 idi_dataset->io_simulate = io_simulate_backup;

 if ( TEST_STATE_QUIT == state )
 {
  printf( " FAIL" ); error_code = EC_TEST_FAIL;
 }
 else
 {
  printf( " PASS" ); error_code = SUCCESS;
 }

 printf( "\n" );

 return error_code;
}



static struct command_line_board cmd_idi48_test[] =
{
 { NULL, CMD__IDI48_DIN_Test_Value, "value", "loop, until all have toggled" },
 { NULL, CMD__IDI48_DIN_Test_RE, "re", "loop, rising-edge detect  (led perspective)" },
 { NULL, CMD__IDI48_DIN_Test_FE, "fe", "loop, falling-edge detect (led perspective)" },
 { NULL, CMD__IDI48_DIN_Test_Interrupt, "interrupt","loop, test interrupt on all inputs" },
 { NULL, NULL, NULL, NULL },
};




static int CMD__IDI48_DIN_Test( int board_id, int argc, char * argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;
    char * endptr;


 if ( argc < 1 ) return -EC_NOT_FOUND;

 error_code = -EC_SYNTAX;


 strtol( argv[0], &endptr, 0 );
 if ( argv[0] != endptr )
 {
  error_code = (* cmd_idi48_test[0].cmd_fnc )( board_id, argc, argv );
 }
 else
 {
  index = 0;
  while ( NULL != cmd_idi48_test[index].cmd_fnc )
  {
   if ( 0 == strcasecmp( cmd_idi48_test[index].name, argv[0] ) )
   {
    argv_new = &(argv[1]);
    argc_new = argc - 1;
    if ( 0 == argc_new ) argv_new = NULL;
    error_code = (* cmd_idi48_test[index].cmd_fnc )( board_id, argc_new, argv_new );
    break;
   }
   index++;
  }
 }
 return error_code;
}







static int CMD__IDI48_DIN_ID( int board_id, int argc, char * argv[] )
{
 uint16_t id;
 (void) argc;
 (void) argv;
 IDI_DIN_ID_Get( board_id, &id );
 printf( "IDI48 DIN ID: 0x%04X\n", id );
 return SUCCESS;
}






static int CMD__IDI48_DIN_All( int board_id, int argc, char * argv[] )
{
 int error_code;
 int channel;

 int cp;
 enum { MODE_NONE = 0, MODE_BINARY = 1, MODE_HEX = 2, MODE_ALL = 3 } mode_out;
 int group;
 char message[64];
 uint8_t din_grp[6];
 uint8_t mask;
 (void) argc;
 (void) argv;

 mode_out = MODE_ALL;
 if ( argc > 0 )
 {
  int index;
  mode_out = MODE_NONE;
  for ( index = 0; index < argc; index++ )
  {
   if ( 0 == strcasecmp( "binary", argv[index] ) ) mode_out |= MODE_BINARY;
   else if ( 0 == strcasecmp( "group", argv[index] ) ) mode_out |= MODE_HEX;
   else if ( 0 == strcasecmp( "hex", argv[index] ) ) mode_out |= MODE_HEX;
   else mode_out |= MODE_ALL;
  }
 }

 cp = 0;
 group = 0;
 for ( group = 0; group < 6; group++ )
 {
  error_code = IDI_DIN_Group_Get( board_id, group, &(din_grp[group]) );
  mask = 0x01;
  for ( channel = 0; channel < 8; channel++ )
  {
   message[cp++] = !!(din_grp[group] & mask) ? '1' : '0';
   mask = mask << 1;
  }
  message[cp++] = ' ';
 }
 message[cp] = '\0';
 if ( MODE_BINARY == ( mode_out & MODE_BINARY ) )
 {
  printf( "DIN: %s\n", message );
 }
 if ( MODE_HEX == ( mode_out & MODE_HEX ) )
 {
  printf( "DIN:" );
  for ( group = 0; group < 6; group++ ) printf( " %02X", din_grp[group] );
  printf( "\n" );
 }

 return SUCCESS;
}






static int CMD__IDI48_DIN_Channel( int board_id, int argc, char * argv[] )
{
 int error_code;
 int channel;
 char message[6 + 2];
 BOOL value;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 channel = (int) strtol( argv[0], NULL, 0 );
 error_code = IDI_DIN_Channel_Get( board_id, channel, &value );
 message[0] = value ? '1' : '0';
 message[1] = '\0';

 printf( "DIN%02d: %s\n", channel, message );
 return SUCCESS;
}






static int CMD__IDI48_DIN_Group( int board_id, int argc, char * argv[] )
{
 int error_code;

 int group;
 int group_count;
 BOOL do_all;
 uint8_t din_grp[6];

 if ( argc < 1 ) do_all = 1;
 else do_all = 0;

 if ( 0 == strcasecmp( "all", argv[0] ) ) do_all = 1;

 if ( do_all )
 {
  for ( group = 0; group < 6; group++ )
  {
   error_code = IDI_DIN_Group_Get( board_id, group, &(din_grp[group]) );
  }
  group_count = 6;
 }
 else
 {
  group = (int) strtol( argv[0], NULL, 0 );
  error_code = IDI_DIN_Group_Get( board_id, group, &(din_grp[0]) );
  group_count = 1;
 }

 printf( "DIN_GROUP:" );
 for ( group = 0; group < group_count; group++ )
 {
  printf( " 0x%02X", ((int) din_grp[group]) );
 }
 printf( "\n" );
 return SUCCESS;
}




static struct command_line_board cmd_idi48[] =
{
 { NULL, CMD__IDI48_DIN_ID, "id", "params: none.  Reports the DIN board/component ID." },
 { NULL, CMD__IDI48_DIN_Channel, "chan", "params: <channel>" },
 { NULL, CMD__IDI48_DIN_Group, "group", "params: [<group_channel | all>]" },
 { NULL, CMD__IDI48_DIN_All, "all", "reports all digital inputs in binary and hex" },
 { cmd_idi48_test, CMD__IDI48_DIN_Test, "test", "semi-auto test functions" },
 { NULL, NULL, NULL, NULL },
};






int Command_Line_IDI48( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;
    char * endptr;


 if ( argc < 1 ) return -EC_NOT_FOUND;

 if ( ID_IDI48 != board_id ) return -EC_BOARD_TYPE;

 error_code = -EC_SYNTAX;


 strtol( argv[0], &endptr, 0 );
 if ( argv[0] != endptr )
 {
  error_code = (* cmd_idi48[0].cmd_fnc )( board_id, argc, argv );
 }
 else
 {
  index = 0;
  while ( NULL != cmd_idi48[index].cmd_fnc )
  {
   if ( 0 == strcasecmp( cmd_idi48[index].name, argv[0] ) )
   {
    argv_new = &(argv[1]);
    argc_new = argc - 1;
    if ( 0 == argc_new ) argv_new = NULL;
    error_code = (* cmd_idi48[index].cmd_fnc )( board_id, argc_new, argv_new );
    break;
   }
   index++;
  }
 }
 return error_code;
}
# 8619 "idi.c"
int Command_Line_Register_Transaction( int board_id, int argc, char* argv[] )
{
 int error_code;
 BOOL valid_bank_reg;
 int index;
 struct reg_definition * definition;


 definition = ( struct reg_definition * ) board_definition[board_id].definition;


 if ( argc < 1 ) return -EC_NOT_FOUND;

 error_code = Register_Acronym_To_Row( board_id, argv[0], &index );
 if ( error_code ) return error_code;






 valid_bank_reg = 0;
 switch( board_id )
 {
  case ID_IDI48: if ( IDI_BANK == definition[index].symbol ) valid_bank_reg = 1; break;
  case ID_IDO48: if ( IDO_BANK == definition[index].symbol ) valid_bank_reg = 1; break;
 }
 if ( valid_bank_reg )
 {
  if ( argc < 2 )
  {
   uint8_t value;
   error_code = IO_Read_U8( board_id, definition[index].symbol, &value );
   if ( SUCCESS == error_code )
   {
    printf( "RD: %s=%s  (0x%02X)\n", definition[index].acronym, Bank_Symbol_To_Name( board_id, ((int) value) ), value );
   }
  }
  else
  {
   uint8_t value;
   int bank;

   error_code = Bank_Name_To_Symbol( board_id, argv[1], &bank );
   if ( error_code )
   {
    value = (uint8_t) strtol( argv[1], NULL, 0 );
   }
   else
   {
    value = (uint8_t) bank;
   }
   error_code = IO_Write_U8( board_id, definition[index].symbol, value );
   if ( SUCCESS == error_code )
   {
    printf( "WR: %s=0x%02X\n", definition[index].acronym, value );
   }
  }
 }
 else
 {
  if ( argc < 2 )
  {
   uint8_t value;
   error_code = IO_Read_U8( board_id, definition[index].symbol, &value );
   if ( SUCCESS == error_code )
   {
    printf( "RD: %s=0x%02X\n", definition[index].acronym, value );
   }
  }
  else
  {
   uint8_t value;
   value = (uint8_t) strtol( argv[1], NULL, 0 );
   error_code = IO_Write_U8( board_id, definition[index].symbol, value );
   if ( SUCCESS == error_code )
   {
    printf( "WR: %s=0x%02X\n", definition[index].acronym, value );
   }
  }
 }

    return SUCCESS;
}







static int CMD__Main_IO_Behavior( int board_id, int argc, char * argv[] )
{
 struct board_dataset * dataset;
 dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 if ( argc < 1 )
 {
  printf( "IO Simulate = %s\n", dataset->io_simulate ? "true" : "false" );
  printf( "IO Report   = %s\n", dataset->io_report ? "true" : "false" );
 }
 else if ( argc > 1 )
 {
  if ( 0 == strcasecmp( "simulate", argv[0] ) )
  {
   dataset->io_simulate = String_To_Bool( argv[1] );
  }
  else if ( 0 == strcasecmp( "report", argv[0] ) )
  {
   dataset->io_report = String_To_Bool( argv[1] );
  }
  printf( "OK\n" );
 }
 else
 {
  if ( 0 == strcasecmp( "simulate", argv[0] ) )
  {
   printf( "IO Simulate = %s\n", dataset->io_simulate ? "true" : "false" );
  }
  else if ( 0 == strcasecmp( "report", argv[0] ) )
  {
   printf( "IO Report   = %s\n", dataset->io_report ? "true" : "false" );
  }
 }
 return SUCCESS;
}






static int CMD__Main_Base( int board_id, int argc, char * argv[] )
{
 struct board_dataset * dataset;
 dataset = ( struct board_dataset * ) board_definition[board_id].dataset;

 if ( argc < 1 )
 {
  printf( "base        = 0x%04X\n", dataset->base_address );
 }
 else
 {
  dataset->base_address = (uint16_t) strtol( argv[0], NULL, 0 );
  printf( "OK\n" );
 }
 return SUCCESS;
}






static int CMD__Main_Irq_Number( int board_id, int argc, char * argv[] )
{
 struct idi_dataset * idi_dataset = NULL;

 switch( board_id )
 {
  case ID_IDI48:
   idi_dataset = ( struct idi_dataset * ) board_definition[board_id].dataset;
   break;
 }

 if ( argc < 1 )
 {
  if ( NULL == idi_dataset ) return SUCCESS;



  printf( "irq         = %u\n", idi_dataset->irq_number );

 }
 else
 {
  if ( NULL == idi_dataset ) return -EC_BOARD_TYPE;
  idi_dataset->irq_number = (unsigned int) strtol( argv[0], NULL, 0 );
  printf( "OK\n" );
 }
 return SUCCESS;
}
# 8810 "idi.c"
static int CMD__Main_I_Count( int board_id, int argc, char * argv[] )
{
 struct idi_dataset * idi_dataset = NULL;

 switch( board_id )
 {
  case ID_IDI48:
   idi_dataset = ( struct idi_dataset * ) board_definition[board_id].dataset;
   break;
 }

 if ( argc < 1 )
 {
  if ( NULL == idi_dataset ) return SUCCESS;



  printf( "iqty        = %lu\n", idi_dataset->irq_quantity );

 }
 else
 {
  if ( NULL == idi_dataset ) return -EC_BOARD_TYPE;
  idi_dataset->irq_quantity = (size_t) strtol( argv[0], NULL, 0 );
  printf( "OK\n" );
 }
 return SUCCESS;
}
# 8912 "idi.c"
static struct command_line_board cmd_set[] =
{
 { NULL, CMD__Main_Base, "base", "params: [<address>]" },
 { NULL, CMD__Main_IO_Behavior, "io", "params: [<simulate>/<report>]" },
 { NULL, CMD__Main_Irq_Number, "irq", "params: [<irq_number 0 to 15>]" },
 { NULL, CMD__Main_I_Count, "iqty", "params: [<number>].  Number of interrupts." },

 { NULL, NULL, NULL, NULL },
};






int Command_Line_Set( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;
    (void) board_id;

    error_code = -EC_SYNTAX;

 if ( argc < 1 )
 {
  index = 0;
  while ( NULL != cmd_set[index].cmd_fnc )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_set[index].cmd_fnc )( board_id, argc_new, argv_new );
   index++;
  }
 }
 else
 {
  index = 0;
  while ( NULL != cmd_set[index].cmd_fnc )
  {
   if ( 0 == strcasecmp( cmd_set[index].name, argv[0] ) )
   {
    argv_new = &(argv[1]);
    argc_new = argc - 1;
    if ( 0 == argc_new ) argv_new = NULL;
    error_code = (* cmd_set[index].cmd_fnc )( board_id, argc_new, argv_new );
    break;
   }
   index++;
  }
 }
 return error_code;
}






int Command_Line_Dump( int board_id, int argc, char* argv[] )
{
 int error_code;
 FILE * fd_out;



 if ( argc > 0 )
 {
  fd_out = fopen( argv[0], "w" );
  if ( NULL == fd_out ) fd_out = stdout;
 }
 else
 {
  fd_out = stdout;
 }
 error_code = Register_Report_CSV( board_id, fd_out );

 if ( (argc > 0) && (NULL != fd_out) && (stdout != fd_out) )
 {
  fclose( fd_out );
 }
 return error_code;
}






int Command_Line_IO_Write( int board_id, int argc, char* argv[] )
{
 int error_code;
 int address;
 uint8_t value;
 (void) board_id;

 if ( argc < 2 ) return -EC_NOT_FOUND;

 address = (int) strtol( argv[0], NULL, 0 );
 value = (uint8_t) strtol( argv[1], NULL, 0 );
 error_code = IO_Write_U8_Port( NULL, address, value );
 printf( "OK\n" );
 return error_code;
}






int Command_Line_IO_Read( int board_id, int argc, char* argv[] )
{
 int error_code;
 int address;
 uint8_t value;
 (void) board_id;

 if ( argc < 1 ) return -EC_NOT_FOUND;

 address = (int) strtol( argv[0], NULL, 0 );
 error_code = IO_Read_U8_Port( NULL, address, &value );
 if ( error_code ) return error_code;
 printf( "0x%02X\n", value );
 return error_code;
}




int Command_Line_Wait( int board_id, int argc, char* argv[] )
{
 (void) board_id;
 (void) argc;
 (void) argv;

 if ( global_loop_command ) return SUCCESS;
 global_loop_command = 1;
 return SUCCESS;
}






static void Help_Pause_Helper( BOOL skip_pause, size_t * line )
{
 if ( 1 == skip_pause ) return;
 if ( *line > 20 )
 {
  printf( "Press any key for more....." );
  while ( !Character_Get( NULL ) ) { }
  printf( "\r" );
  *line = 0;
 }
}




static void Help_Output( BOOL skip_pause,
       int depth,
       size_t * line,
       struct command_line_board * table,
       FILE * out
        )
{
 size_t row;
 int index;
 const char * prefix = { "       " };

 row = 0;
 while ( NULL != table[row].name )
 {
  if ( 0 == depth )
  {
   fprintf( out, "%-4s", table[row].name );
  }
  else
  {
   for ( index = 0; index < depth; index++ ) fprintf( out, "%s", prefix );
   fprintf( out, "%-8s", table[row].name );
  }
  fprintf( out, " - %s\n", table[row].help );
  *line += 1;



  if ( NULL != table[row].link )
  {
   Help_Output( skip_pause, depth + 1, line, table[row].link, out );
   fprintf( out, "\n" );
   *line += 1;
  }
  row++;
 }
}





static void IDI_Help( size_t * line, FILE * out )
{
 fprintf( out, "IDI48 board supported\n" );
 fprintf( out, " Examples:\n" );
 fprintf( out, "   idi dig0          <-- reports the digital input group 0 port.\n" );
 fprintf( out, "   idi loop dig0     <-- loops until key pressed\n" );
 fprintf( out, "   idi irq loop dig0 <-- loops while counting interrupts or until iqty reached\n" );
 fprintf( out, "   idi irq dig0      <-- does command once and uses interrupts for short time\n" );
 *line += 7;
}





static void IDO_Help( size_t * line, FILE * out )
{
 fprintf( out, "IDO48 board supported\n" );
 fprintf( out, " Examples:\n" );
 fprintf( out, "   ido dog0          <-- reports the digital output group 0 port.\n" );
 fprintf( out, "   ido loop dog0     <-- loops until key pressed\n" );
 *line += 5;
}


static struct command_line_board cmd_top[];
static struct command_line cmd_prefix[];







static void Help( BOOL skip_pause, FILE * out )
{
 size_t line;
 int top;

 line = 0;
 fprintf( out, "\n" );
 fprintf( out, "STDBus General Test Code\n" );
 fprintf( out, "Apex Embedded Systems\n" );
 fprintf( out, "SVN software revision: " "$Date: 2015-08-03 13:35:01 -0500 (Mon, 03 Aug 2015) $" "\n" );
 fprintf( out, "Supporting:\n" );
 line += 5;

 IDI_Help( &line, out );
 IDO_Help( &line, out );

 fprintf( out, "\n" );
 fprintf( out, "help - outputs help information\n" );
 line += 2;

 top = 0;
 while ( NULL != cmd_prefix[top].name )
 {
  fprintf( out, "\n" );
  fprintf( out, "%-4s - %s\n", cmd_prefix[top].name, cmd_prefix[top].help );
  top++;
  line += 2;
  Help_Pause_Helper( skip_pause, &line );
 }

 Help_Output( skip_pause, 0, &line, (struct command_line_board *) cmd_top , out );
 fprintf( out, "\n" );
}




int Command_Line_Help( int board_id, int argc, char* argv[] )
{
 FILE * out;
 FILE * fd = NULL;
 BOOL skip_pause = 0;
 (void) board_id;

 out = stdout;
 if ( argc > 0 )
 {
  fd = fopen( argv[0], "w" );
  if ( NULL != fd )
  {
   out = fd; skip_pause = 1;
  }
 }
 Help( skip_pause, out );
 if ( NULL != fd ) fclose( fd );

 return SUCCESS;
}
# 9236 "idi.c"
static struct command_line_board cmd_top[] =
{
 { NULL, Command_Line_Dump, "dump", "Register information in CSV format" }, { cmd_set, Command_Line_Set, "set", "Set/Get main parameters" }, { cmd_spi, Command_Line_SPI, "spi", "SPI related functions" }, { cmd_as, Command_Line_Analog_Stick, "as", "Analog Stick related functions" }, { cmd_fram, Command_Line_FRAM, "fram", "FRAM related functions" }, { cmd_idi48, Command_Line_IDI48, "di", "Digital input related functions" }, { cmd_ido48, Command_Line_IDO48, "do", "Digital output related functions" }, { NULL, Command_Line_IO_Write, "o", "unrestricted I/O write <address> <data>" }, { NULL, Command_Line_IO_Read, "i", "unrestricted I/O read  <address>" }, { NULL, Command_Line_Wait, "wait", "wait for any key press" }, { NULL, Command_Line_Help, "help", "very brief command summary" }, { NULL, NULL, NULL, NULL },
};
static BOOL cmd_top__board_type_required[] =
{
  1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
};
# 9256 "idi.c"
int Command_Line_Main( int board_id, int argc, char* argv[] )
{
 int error_code;
 int index;
 BOOL not_found;
    int argc_new;
    char ** argv_new;


    error_code = -EC_SYNTAX;

    if ( argc < 1 ) return -EC_NOT_FOUND;


 not_found = 1;
 index = 0;
 while ( NULL != cmd_top[index].cmd_fnc )
 {
  if ( 0 == strcasecmp( cmd_top[index].name, argv[0] ) )
  {
   not_found = 0;
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_top[index].cmd_fnc )( board_id, argc_new, argv_new );
   if ( error_code ) goto COMMAND_LINE_MAIN_TERMINATE;
   break;
  }
  index++;
 }

 if ( not_found )
 {
  argv_new = &(argv[0]);
  argc_new = argc - 0;
  error_code = Command_Line_Register_Transaction( board_id, argc_new, argv_new );
  if ( error_code ) goto COMMAND_LINE_MAIN_TERMINATE;
 }
COMMAND_LINE_MAIN_TERMINATE:
 return error_code;
}





enum CLM_BTS
{
 CLM_BTS_NORMAL = 0,
 CLM_BTS_NOT_REQUIRED = 1,
 CLM_BTS_IMPLIED = 2
};
# 9319 "idi.c"
static enum CLM_BTS Command_Line_Main__Board_Type_Status( const char * cmd_string, int * board_id )
{
 int index;
 enum CLM_BTS status;
 index = 0;
 status = CLM_BTS_NORMAL;
 *board_id = ID_BOARD_UNKNOWN;
 while ( NULL != cmd_top[index].cmd_fnc )
 {
# 9336 "idi.c"
  if ( 0 == strcasecmp( "do", cmd_string ) )
  {
   *board_id = ID_IDO48; status = CLM_BTS_IMPLIED;
  }
  else if ( 0 == strcasecmp( "di", cmd_string ) )
  {
   *board_id = ID_IDI48; status = CLM_BTS_IMPLIED;
  }



  if ( 0 == strcasecmp( cmd_top[index].name, cmd_string ) )
  {
   if ( 0 == cmd_top__board_type_required[index] )
   {
    if ( CLM_BTS_NORMAL == status ) status = CLM_BTS_NOT_REQUIRED;
   }
   return status;
  }
  index++;
 }
 return status;
}




static int Command_Line_Loop_Count( int argc,
         char* argv[]
             )
{
 int error_code;

 if ( argc > 0 )
 {
  if ( argv[0][0] >= '0' && argv[0][0] <= '9' )
  {
   global_loop_count = (int) strtol( argv[0], NULL, 0 );
   global_loop_count_counter = global_loop_count;
   error_code = 1;
  }
  else
  {
   error_code = -EC_SYNTAX;
  }
 }
 else
 {
  error_code = -EC_SYNTAX;
 }
 return error_code;
}




static int Command_Line_Loop_Delay( int argc,
         char* argv[]
             )
{
 int error_code;

 if ( argc > 0 )
 {
  if ( argv[0][0] >= '0' && argv[0][0] <= '9' )
  {
   global_loop_delay_ms = (int) strtol( argv[0], NULL, 0 );
   error_code = 1;
  }
  else
  {
   error_code = -EC_SYNTAX;
  }
 }
 else
 {
  error_code = -EC_SYNTAX;
 }
 return error_code;
}




static struct command_line cmd_loop[] =
{
 { NULL, Command_Line_Loop_Count, "count", "loop for N counts" },
 { NULL, Command_Line_Loop_Delay, "delay", "loop with delay <milliseconds>" },
 { NULL, NULL, NULL, NULL },
};




static int Command_Line_Prefix_Loop( int argc,
          char* argv[]
           )
{
 int error_code;
 int index;
 int ai;

    int argc_new;
    char ** argv_new;

    global_loop_command = 1;

 index = 0;
 ai = 0;
 while ( NULL != cmd_loop[index].cmd_fnc )
 {
  if ( 0 == strcasecmp( cmd_loop[index].name, argv[ai] ) )
  {

   argv_new = &(argv[ai + 1]);
   argc_new = argc - (ai + 1);
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_loop[index].cmd_fnc )( argc_new, argv_new );
   if ( error_code < 0 ) goto COMMAND_LINE_PREFIX_LOOP_TERMINATE;
   else ai += 1 + error_code;
   index = 0;
  }
  else
  {
   index++;
  }
 }
 return ai;
COMMAND_LINE_PREFIX_LOOP_TERMINATE:
 return error_code;
}




static int Command_Line_Prefix_Irq( int argc,
         char* argv[]
             )
{
 (void) argc;
 (void) argv;

 global_irq_please_install_handler_request = 1;
# 9490 "idi.c"
 return 0;
}




static struct command_line cmd_prefix[] =
{
 { NULL, Command_Line_Prefix_Irq, "irq", "allows commands to handle interrupts" },
 { cmd_loop, Command_Line_Prefix_Loop, "loop", "any command loops until key pressed" },
 { NULL, NULL, NULL, NULL },
};






int Command_Line_Prefix( int argc, char* argv[] )
{
 int error_code;
 int index;
 int ai;
    int argc_new;
    char ** argv_new;

    if ( argc < 1 ) return 0;

 index = 0;
 ai = 0;
 while ( NULL != cmd_prefix[index].cmd_fnc )
 {
  if ( 0 == strcasecmp( cmd_prefix[index].name, argv[0] ) )
  {
   argv_new = &(argv[1]);
   argc_new = argc - 1;
   if ( 0 == argc_new ) argv_new = NULL;
   error_code = (* cmd_prefix[index].cmd_fnc )( argc_new, argv_new );
   if ( error_code < 0 ) goto COMMAND_LINE_PREFIX_TERMINATE;
   else ai = 1 + error_code;
   break;
  }
  index++;
 }
 return ai;
COMMAND_LINE_PREFIX_TERMINATE:
 return error_code;
}
# 9558 "idi.c"
static int IDI_Termination( struct idi_dataset * dataset )
{
 FILE * fd;



 if ( dataset->irq_handler_active )
 {



  printf( " --> irq %u: count = %lu\n", dataset->irq_number, dataset->irq_count );

 }
 dataset->irq_handler_active = 0;
 dataset->irq_please_install_handler_request = 0;


 fd = fopen( "idi_init.bin", "wb" );
 if ( NULL == fd )
 {
  return -EC_INIT_FILE;
 }
 else
 {



  fwrite( dataset, sizeof( struct idi_dataset ), 1, fd );
  fclose( fd );
 }
 return SUCCESS;
}





static int IDO_Termination( struct ido_dataset * dataset )
{
 FILE * fd;

 fd = fopen( "ido_init.bin", "wb" );
 if ( NULL == fd )
 {
  return -EC_INIT_FILE;
 }
 else
 {



  fwrite( dataset, sizeof( struct ido_dataset ), 1, fd );
  fclose( fd );
 }
 return SUCCESS;
}
# 9623 "idi.c"
int Termination( int board_id )
{
 int error_code;
 error_code = SUCCESS;
 switch( board_id )
 {
  case ID_IDI48:
   error_code = IDI_Termination( (struct idi_dataset *) board_definition[board_id].dataset );
   break;
  case ID_IDO48:
   error_code = IDO_Termination( (struct ido_dataset *) board_definition[board_id].dataset );
   break;
 }
 return error_code;
}




void IDI_Dataset_Defaults( struct idi_dataset * ds )
{
 int index;

 printf( "Warning - using main IDI48 dataset defaults\n" );

 memset( ds, 0, sizeof(struct idi_dataset) );

 ds->base_address = 0x0110;


 for ( index = 0; index < 16; index++ )
 {
  ds->reg_init[index].used = 0;
  ds->reg_init[index].address = 0;
  ds->reg_init[index].location = IDI_UNDEFINED;
  ds->reg_init[index].value = 0x00;
 }
}




void IDO_Dataset_Defaults( struct ido_dataset * ds )
{
 int index;

 printf( "Warning - using main IDO48 dataset defaults\n" );

 memset( ds, 0, sizeof(struct ido_dataset) );

 ds->base_address = 0x0230;


 for ( index = 0; index < 16; index++ )
 {
  ds->reg_init[index].used = 0;
  ds->reg_init[index].address = 0;
  ds->reg_init[index].location = IDO_UNDEFINED;
  ds->reg_init[index].value = 0x00;
 }
}




void Signal_Handler( int signal )
{
 struct board_dataset * dataset = ( struct board_dataset * ) board_definition[global_board_id].dataset;
 (void) signal;
 dataset->quit_application = 1;
}






static void IDI_Initialization_Data_Structure_Load( struct idi_dataset * dataset )
{
 FILE * fd;
 size_t file_size;

 fd = fopen( "idi_init.bin", "rb" );
 if ( NULL == fd )
 {
  IDI_Dataset_Defaults( dataset );



 }
 else
 {
  fseek( fd, 0L, SEEK_END );
  file_size = (size_t) ftell( fd );
  fseek( fd, 0L, SEEK_SET );
  if ( file_size != sizeof( struct idi_dataset ) )
  {
   IDI_Dataset_Defaults( dataset );



  }
  else
  {
   fread( dataset, sizeof( struct idi_dataset ), 1, fd );



  }
  fclose( fd );
 }
 dataset->svn_revision_string = svn_revision_string;
 dataset->irq_handler_active = 0;
 dataset->irq_please_install_handler_request = 0;
 dataset->irq_count = 0;
 dataset->irq_count_previous = 0;

 dataset->bank_previous = IDI_BANK_UNDEFINED;
}





static void IDO_Initialization_Data_Structure_Load( struct ido_dataset * dataset )
{
 FILE * fd;
 size_t file_size;

 fd = fopen( "ido_init.bin", "rb" );
 if ( NULL == fd )
 {
  IDO_Dataset_Defaults( dataset );



 }
 else
 {
  fseek( fd, 0L, SEEK_END );
  file_size = (size_t) ftell( fd );
  fseek( fd, 0L, SEEK_SET );
  if ( file_size != sizeof( struct ido_dataset ) )
  {
   IDO_Dataset_Defaults( dataset );



  }
  else
  {
   fread( dataset, sizeof( struct ido_dataset ), 1, fd );



  }
  fclose( fd );
 }
 dataset->svn_revision_string = svn_revision_string;
 dataset->irq_handler_active = 0;
 dataset->irq_please_install_handler_request = 0;
 dataset->irq_count = 0;
 dataset->irq_count_previous = 0;

 dataset->bank_previous = IDO_BANK_UNDEFINED;
}





static void IDI_Initialization_Register( int board_id, struct idi_dataset * dataset )
{
 int index;

 for ( index = 0; index < 16; index++ )
 {
  if ( dataset->reg_init[index].used )
  {
   if ( IDI_UNDEFINED != dataset->reg_init[index].location )
   {
    IO_Write_U8( board_id, dataset->reg_init[index].location, dataset->reg_init[index].value );
   }
   else
   {
    IO_Write_U8_Port( (struct board_dataset *) dataset,
         dataset->reg_init[index].address,
         dataset->reg_init[index].value
        );
   }
  }
 }
}





static void IDO_Initialization_Register( int board_id, struct ido_dataset * dataset )
{
 int index;

 for ( index = 0; index < 16; index++ )
 {
  if ( dataset->reg_init[index].used )
  {
   if ( IDO_UNDEFINED != dataset->reg_init[index].location )
   {
    IO_Write_U8( board_id, dataset->reg_init[index].location, dataset->reg_init[index].value );
   }
   else
   {
    IO_Write_U8_Port( (struct board_dataset *) dataset,
         dataset->reg_init[index].address,
         dataset->reg_init[index].value
        );
   }
  }
 }
}
# 9854 "idi.c"
int Initialization( int board_id )
{
 struct board_dataset * dataset;
 (void) board_id;

 dataset = (struct board_dataset *) board_definition[ID_IDI48].dataset;
 dataset->quit_application = 0;
 IDI_Initialization_Data_Structure_Load( (struct idi_dataset *) dataset );
 dataset = (struct board_dataset *) board_definition[ID_IDO48].dataset;
 dataset->quit_application = 0;
 IDO_Initialization_Data_Structure_Load( (struct ido_dataset *) dataset );




 dataset = (struct board_dataset *) board_definition[ID_IDI48].dataset;
 IDI_Initialization_Register( ID_IDI48, (struct idi_dataset *) dataset );
 dataset = (struct board_dataset *) board_definition[ID_IDO48].dataset;
 IDO_Initialization_Register( ID_IDO48, (struct ido_dataset *) dataset );


 signal( SIGINT, Signal_Handler );
# 9913 "idi.c"
    return SUCCESS;
}





int IDI_Main_Loop_Testing( struct idi_dataset * dataset )
{
 if ( dataset->irq_handler_active )
 {
  if ( dataset->irq_count != dataset->irq_count_previous )
  {

   dataset->irq_count_previous = dataset->irq_count;




   printf( " --> irq %u: count = %lu\n", dataset->irq_number, dataset->irq_count );

   if ( dataset->irq_count_previous >= dataset->irq_quantity )
   {
    return -1;
   }
  }
 }
 return 0;
}




static void Main_Versalogic( void )
{





}
# 9967 "idi.c"
int main( int argc, char* argv[] )
{


 int board_id;
 int error_code;
 int index;
    int argc_new;
    char ** argv_new;
 struct board_dataset * dataset;




    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
# 9999 "idi.c"
    Main_Versalogic();

    error_code = SUCCESS;
    board_id = ID_BOARD_UNKNOWN;
    global_board_id = board_id;
    index = 1;
    if ( argc > 1 )
    {







  argv_new = &(argv[index]);
  argc_new = argc - index;
  error_code = Command_Line_Prefix( argc_new, argv_new );
  if ( error_code < 0 ) goto Main_Termination_Skip_Termination;
  else index += error_code;




   switch( Command_Line_Main__Board_Type_Status( argv[index], &board_id ) )
   {
    case CLM_BTS_NORMAL:
     break;
    case CLM_BTS_IMPLIED:
     global_board_id = board_id;
     goto Main_Initialization_Start;
    case CLM_BTS_NOT_REQUIRED:
     goto Main_Loop_Start;
   }


   if ( 0 == strcasecmp( "idi", argv[index]) )
   {
    board_id = ID_IDI48;
    global_board_id = board_id;
    index++;
   }
   else if ( 0 == strcasecmp( "ido", argv[index]) )
   {
    board_id = ID_IDO48;
    global_board_id = board_id;
    index++;
   }
   else
   {
    error_code = -EC_BOARD_TYPE;
    goto Main_Termination_Error_Codes_Skip_Termination;
   }


Main_Initialization_Start:
        error_code = Initialization( board_id );
        if ( error_code ) goto Main_Termination;

        dataset = ( struct board_dataset * ) board_definition[board_id].dataset;


Main_Loop_Start:
  do
  {
   argv_new = &(argv[index]);
   argc_new = argc - index;
   error_code = Command_Line_Main( board_id, argc_new, argv_new );
   if ( error_code ) goto Main_Termination_Error_Codes;

   switch( board_id )
   {
    case ID_IDI48:
     if ( -1 == IDI_Main_Loop_Testing( (struct idi_dataset *) dataset ) )
     {
      goto Main_Termination;
     }
     break;
   }

   if ( global_loop_command )
   {
    if ( global_loop_delay_ms > 0 )
    {



    }

    if ( global_loop_count > 0 )
    {
     global_loop_count_counter--;
     if ( 0 == global_loop_count_counter ) global_loop_command = 0;
    }

    if ( Character_Get(NULL) ) global_loop_command = 0;
   }

  } while ( global_loop_command );
    }
    else
    {
     Help( 0 , stdout );
     goto Main_Termination_Skip_Termination;
    }

Main_Termination:
    Termination( board_id );
Main_Termination_Skip_Termination:
    return error_code;

Main_Termination_Error_Codes:
 Termination( board_id );
Main_Termination_Error_Codes_Skip_Termination:
 printf( "ERROR: %d, %s\n", error_code, EC_Code_To_Human_Readable( error_code ) );
 return error_code;
}
